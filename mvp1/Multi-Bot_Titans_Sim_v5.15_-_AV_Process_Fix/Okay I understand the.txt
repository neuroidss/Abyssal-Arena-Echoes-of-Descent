Okay, I understand the issue. The VisPy visualization window is blocking the main simulation loop, likely because `vispy.app.run()` is taking control of the thread it's called from, even if it's intended to be a background thread, potentially due to interactions with `eventlet`.

We will address this by:

1.  **Ensuring VisPy runs truly independently:** Modify the threading approach, potentially using `multiprocessing` if simple threading conflicts with `eventlet` and VisPy's event loop.
2.  **Refining VisPy Initialization:** Ensure all VisPy components are created *within* the dedicated thread/process.
3.  **Adding Flexibility for Alternatives:** Structure the `AVManager` to support different visualization backends easily, even if only VisPy is fully implemented initially. We'll add placeholders/ideas for web-based (like Plotly/Three.js via SocketIO) and Matplotlib as requested alternatives.

Here are the modified files:

--- START OF MODIFIED FILE `audiovisualization.py` ---

```python
# Filename: audiovisualization.py
# coding: utf-8

import numpy as np
import torch
import threading
import multiprocessing as mp # Use multiprocessing for GUI isolation
import time
import queue
import traceback
import math
from scipy.signal import chirp # For more interesting sounds
import sys # For checking platform

print("Audiovisualization Library Loading...")

# --- Attempt to import optional libraries ---
VISPY_AVAILABLE = False
SOUNDDEVICE_AVAILABLE = False
SKLEARN_AVAILABLE = False # For PCA/t-SNE
MATPLOTLIB_AVAILABLE = False # For Matplotlib alternative

try:
    # VisPy needs to be imported *before* checking platform sometimes
    import vispy.app
    import vispy.scene
    from vispy.scene import visuals
    VISPY_AVAILABLE = True
    print("VisPy library imported successfully.")
except ImportError:
    print("Warning: VisPy library not found. VisPy visualization disabled. (Install with: pip install vispy)")
except Exception as e:
    print(f"Warning: VisPy library failed to import ({e}). VisPy visualization disabled.")


try:
    import sounddevice as sd
    SOUNDDEVICE_AVAILABLE = True
    print("SoundDevice library imported successfully.")
except ImportError:
    print("Warning: SoundDevice library not found. Audio output disabled. (Install with: pip install sounddevice)")
except Exception as e:
    # SoundDevice can sometimes raise other errors on import if system libs are missing
    print(f"Warning: SoundDevice library failed to import ({e}). Audio output disabled.")


try:
    from sklearn.decomposition import PCA
    # from sklearn.manifold import TSNE # t-SNE is much slower, PCA is better for real-time
    SKLEARN_AVAILABLE = True
    print("Scikit-learn library imported successfully (for PCA).")
except ImportError:
     print("Warning: Scikit-learn library not found. Dimensionality reduction (PCA) for visuals disabled. (Install with: pip install scikit-learn)")

try:
    import matplotlib.pyplot as plt
    import matplotlib.animation as animation
    MATPLOTLIB_AVAILABLE = True
    print("Matplotlib library imported successfully (for alternative visualization).")
except ImportError:
    print("Warning: Matplotlib library not found. Matplotlib visualization disabled. (Install with: pip install matplotlib)")


# --- Constants ---
SAMPLE_RATE = 44100  # Audio sample rate
AUDIO_BLOCK_SIZE = 1024 # Samples per audio callback buffer
MAX_BOTS_FOR_AUDIO = 16 # Limit simultaneous distinct audio streams for performance/clarity
VISUAL_UPDATE_RATE_HZ = 20 # Target FPS for VisPy/Matplotlib window (Lowered slightly)
AUDIO_UPDATE_INTERVAL_S = 0.05 # How often to update audio parameters
QUEUE_TIMEOUT_S = 0.1 # Timeout for getting data from queue

# --- Visualization Process Target Functions ---

def _vispy_process_target(data_queue: mp.Queue, stop_event: mp.Event, num_bots, dim, pca_available):
    """ Target function for the VisPy visualization process. """
    if not VISPY_AVAILABLE:
        print("VisPy Process: VisPy not available, exiting.")
        return

    print("VisPy Process: Starting...")
    canvas = None
    view = None
    bot_visuals = None
    bot_positions = np.zeros((num_bots, 3), dtype=np.float32) # x, y, z
    bot_colors = np.ones((num_bots, 4), dtype=np.float32) # r, g, b, a
    bot_sizes = np.full(num_bots, 10, dtype=np.float32)
    pca = None
    if pca_available and dim > 2:
        try:
            pca = PCA(n_components=2)
            print("VisPy Process: PCA initialized.")
        except Exception as e:
            print(f"VisPy Process: Warning - PCA init failed: {e}")
            pca = None
    elif dim == 2:
        print("VisPy Process: Using raw 2D vectors for positioning.")
    else:
        print("VisPy Process: PCA not available or dim <= 2. Using basic positioning.")

    def process_data_for_visuals(av_data_batch):
        """ Updates internal visual state (positions, colors, sizes) from batch data. """
        nonlocal bot_positions, bot_colors, bot_sizes # Modify outer scope variables
        if not av_data_batch: return

        all_retrieved_vectors = []
        indices_in_batch = []

        # --- Collect data for PCA (if applicable) ---
        if pca or dim == 2:
            for av_idx, data in av_data_batch.items():
                if 0 <= av_idx < num_bots and data.get('retrieved_memory_vector') is not None:
                    # Data should already be numpy array from the main process
                    vec = data['retrieved_memory_vector'] # Expecting numpy array
                    if isinstance(vec, np.ndarray) and vec.shape == (dim,):
                        all_retrieved_vectors.append(vec)
                        indices_in_batch.append(av_idx)

            # --- Apply PCA or use raw vectors ---
            if indices_in_batch:
                vectors_np = np.array(all_retrieved_vectors)
                transformed_positions = np.zeros((len(vectors_np), 2)) # Default
                if pca:
                    try:
                        if len(vectors_np) >= 2: # Need at least 2 samples for PCA
                             transformed_positions = pca.fit_transform(vectors_np)
                        # else: Keep zeros
                    except Exception as pca_err:
                         print(f"VisPy Process: Warning - PCA failed: {pca_err}. Using zeros.")
                         # Keep zeros
                elif dim == 2:
                     transformed_positions = vectors_np

                # --- Update bot positions based on PCA/raw vectors ---
                for i, av_idx in enumerate(indices_in_batch):
                    # Scale positions for better visualization range (e.g., -5 to 5)
                    bot_positions[av_idx, 0] = transformed_positions[i, 0] * 5
                    bot_positions[av_idx, 1] = transformed_positions[i, 1] * 5
                    anomaly = data.get('anomaly_score', 0.0) # Expecting float
                    bot_positions[av_idx, 2] = np.clip(anomaly * 10, -5, 5) # Z based on anomaly

        # --- Update Colors and Sizes for all bots in the batch ---
        for av_idx, data in av_data_batch.items():
            if 0 <= av_idx < num_bots:
                anomaly = data.get('anomaly_score', 0.0)
                weight_change = data.get('weight_change_metric', 0.0)
                mode_code = data.get('mode_code', 5)
                is_player = data.get('is_player_controlled', False)

                # Color based on mode, player status, and anomaly
                alpha = np.clip(0.5 + anomaly * 5.0, 0.5, 1.0)
                color = [0.5, 0.5, 0.5, alpha * 0.8] # Default Grey
                if is_player: color = [0.1, np.clip(0.5 + anomaly * 5, 0.5, 1.0), 0.1, alpha] # Greenish
                elif mode_code == 0: color = [np.clip(0.5 + anomaly * 5, 0.5, 1.0), 0.1, 0.1, alpha] # Exploit (Reddish)
                elif mode_code == 1 or mode_code == 2: color = [0.1, 0.1, np.clip(0.5 + anomaly * 5, 0.5, 1.0), alpha] # Explore (Bluish)
                elif mode_code == 3 or mode_code == 4: color = [np.clip(0.5 + anomaly * 5, 0.5, 1.0), np.clip(0.5 + anomaly * 5, 0.5, 1.0), 0.1, alpha] # Player Target/Direct (Yellowish)

                bot_colors[av_idx] = color

                # Size based on weight change
                base_size = 8
                size_boost = np.clip(weight_change * 50.0, 0, 15)
                bot_sizes[av_idx] = base_size + size_boost

        # If no PCA/2D, use a default layout
        if not pca and dim != 2:
             sqrt_num = math.ceil(math.sqrt(num_bots))
             spacing = 10.0 / (sqrt_num + 1)
             for av_idx, data in av_data_batch.items():
                  if 0 <= av_idx < num_bots:
                       row = av_idx // sqrt_num
                       col = av_idx % sqrt_num
                       bot_positions[av_idx, 0] = (col - sqrt_num / 2 + 0.5) * spacing
                       bot_positions[av_idx, 1] = (row - sqrt_num / 2 + 0.5) * spacing
                       anomaly = data.get('anomaly_score', 0.0)
                       bot_positions[av_idx, 2] = np.clip(anomaly * 10, -5, 5)

    def update_vispy_callback(event):
        """ Called periodically by VisPy timer to update visuals from queue data. """
        nonlocal bot_visuals # Access outer scope
        try:
            latest_data = None
            # Drain the queue, keeping only the most recent batch
            while not data_queue.empty():
                try:
                    latest_data = data_queue.get_nowait()
                except queue.Empty:
                    break
                except (EOFError, BrokenPipeError):
                    print("VisPy Process: Data queue broken, stopping.")
                    vispy.app.quit()
                    return

            if latest_data:
                process_data_for_visuals(latest_data)

            # Update VisPy visual elements if they exist
            if bot_visuals:
                bot_visuals.set_data(pos=bot_positions, size=bot_sizes, face_color=bot_colors, edge_color=None)
                # canvas.update() # Might not be needed

            # Check if the main process requested stop
            if stop_event.is_set():
                print("VisPy Process: Stop event received, quitting.")
                vispy.app.quit()

        except Exception as e:
            print(f"VisPy Process: Error during VisPy update: {e}")
            # traceback.print_exc() # Can be noisy

    try:
        # Create canvas and view *inside the process*
        canvas = vispy.scene.SceneCanvas(keys='interactive', show=True, title=f'Bot Memory Visualization ({num_bots} bots)')
        view = canvas.central_widget.add_view()
        view.camera = 'turntable' # Use a 3D camera

        # Create Markers visual for bots
        bot_visuals = visuals.Markers(parent=view.scene)
        bot_visuals.set_data(pos=bot_positions, size=bot_sizes, face_color=bot_colors, edge_color=None)

        # Add axes for context
        visuals.XYZAxis(parent=view.scene)

        # Setup a timer to process data from the queue
        timer = vispy.app.Timer(interval=1.0/VISUAL_UPDATE_RATE_HZ, connect=update_vispy_callback, start=True)

        print("VisPy Process: Setup complete. Running event loop...")
        vispy.app.run() # Start the event loop - THIS WILL BLOCK THIS PROCESS

    except Exception as e:
        print(f"VisPy Process: CRITICAL ERROR: {e}")
        traceback.print_exc()
    finally:
        if canvas:
            try:
                canvas.close()
            except Exception as ce:
                print(f"VisPy Process: Error closing canvas: {ce}")
        print("VisPy Process: Stopped.")

# --- Matplotlib Process Target (Placeholder/Example) ---
def _matplotlib_process_target(data_queue: mp.Queue, stop_event: mp.Event, num_bots, dim, pca_available):
    if not MATPLOTLIB_AVAILABLE:
        print("Matplotlib Process: Matplotlib not available, exiting.")
        return

    print("Matplotlib Process: Starting...")
    fig, ax = plt.subplots(subplot_kw={'projection': '3d'})
    scatter = None # Store the scatter plot object

    bot_positions = np.zeros((num_bots, 3), dtype=np.float32)
    bot_colors = np.array([[0.5, 0.5, 0.5, 0.8]] * num_bots, dtype=np.float32) # Default Grey
    bot_sizes = np.full(num_bots, 30, dtype=np.float32) # Matplotlib sizes are different scale
    pca = None
    if pca_available and dim > 2: pca = PCA(n_components=2)

    def process_data_for_matplotlib(av_data_batch):
        # Similar logic to VisPy's process_data_for_visuals, but update numpy arrays used by Matplotlib
        nonlocal bot_positions, bot_colors, bot_sizes
        # ... (Adapt the data processing logic from VisPy's function here) ...
        # Ensure the arrays bot_positions, bot_colors, bot_sizes are updated
        # Example snippet (needs full adaptation):
        indices_in_batch = list(av_data_batch.keys())
        if not indices_in_batch: return

        # --- PCA/Positioning (Simplified Example) ---
        if pca or dim == 2:
            vectors = [d.get('retrieved_memory_vector') for d in av_data_batch.values() if d.get('retrieved_memory_vector') is not None]
            if vectors:
                vectors_np = np.array(vectors)
                transformed = np.zeros((len(vectors_np), 2))
                if pca and len(vectors_np) >= 2: transformed = pca.fit_transform(vectors_np)
                elif dim == 2: transformed = vectors_np
                for i, av_idx in enumerate(indices_in_batch):
                     if 0 <= av_idx < num_bots:
                         bot_positions[av_idx, 0] = transformed[i, 0] * 5
                         bot_positions[av_idx, 1] = transformed[i, 1] * 5
        # --- Color/Size (Simplified Example) ---
        for av_idx, data in av_data_batch.items():
             if 0 <= av_idx < num_bots:
                 anomaly = data.get('anomaly_score', 0.0)
                 weight_change = data.get('weight_change_metric', 0.0)
                 # ... (set color based on mode/player) ...
                 bot_colors[av_idx] = [np.clip(0.5 + anomaly * 5, 0.5, 1.0), 0.1, 0.1, np.clip(0.5 + anomaly * 5.0, 0.5, 1.0)] # Example: Reddish based on anomaly
                 bot_sizes[av_idx] = 20 + np.clip(weight_change * 100.0, 0, 60)
                 bot_positions[av_idx, 2] = np.clip(anomaly * 10, -5, 5) # Z based on anomaly

    def update_plot(frame):
        nonlocal scatter # Modify outer scope
        try:
            latest_data = None
            while not data_queue.empty():
                try:
                    latest_data = data_queue.get_nowait()
                except queue.Empty: break
                except (EOFError, BrokenPipeError): print("Matplotlib Process: Queue broken."); plt.close(fig); return None

            if latest_data:
                process_data_for_matplotlib(latest_data)

            if scatter is None: # First frame
                # Initial plot setup
                scatter = ax.scatter(bot_positions[:, 0], bot_positions[:, 1], bot_positions[:, 2],
                                     c=bot_colors, s=bot_sizes, depthshade=True)
                ax.set_xlabel("PCA 1 / X")
                ax.set_ylabel("PCA 2 / Y")
                ax.set_zlabel("Anomaly / Z")
                ax.set_title("Bot Memory State (Matplotlib)")
                ax.set_xlim(-6, 6)
                ax.set_ylim(-6, 6)
                ax.set_zlim(-6, 6)
            else:
                # Update existing scatter plot data (more efficient)
                # Note: Updating colors and sizes might require recreating scatter or using specific methods
                scatter._offsets3d = (bot_positions[:, 0], bot_positions[:, 1], bot_positions[:, 2])
                # scatter.set_sizes(bot_sizes) # Update sizes
                # scatter.set_facecolor(bot_colors) # Update colors (facecolor)
                # scatter.set_edgecolor(None) # Optional: remove edge colors

            if stop_event.is_set():
                print("Matplotlib Process: Stop event received, closing plot.")
                plt.close(fig)
                return None # Stop animation

            return scatter, # Return tuple of artists to update

        except Exception as e:
            print(f"Matplotlib Process: Error during update: {e}")
            # traceback.print_exc()
            return scatter,

    try:
        # Use FuncAnimation for periodic updates
        ani = animation.FuncAnimation(fig, update_plot,
                                      interval=1000.0/VISUAL_UPDATE_RATE_HZ, # Interval in ms
                                      blit=False, # Blitting can be complex with 3D/changing colors/sizes
                                      cache_frame_data=False)
        plt.show(block=True) # block=True runs the event loop

    except Exception as e:
        print(f"Matplotlib Process: CRITICAL ERROR: {e}")
        traceback.print_exc()
    finally:
        print("Matplotlib Process: Stopped.")


# --- AVManager Class ---
class AVManager:
    def __init__(self, num_bots, dim, device, enable_output, visualization_mode='vispy'):
        self.num_bots = num_bots
        self.dim = dim
        self.device = torch.device(device) # Ensure it's a device object
        self.visualization_mode = visualization_mode if enable_output else 'none'
        self.enable_audio_output = enable_output and SOUNDDEVICE_AVAILABLE
        self.enable_visual_output = enable_output and (
            (visualization_mode == 'vispy' and VISPY_AVAILABLE) or
            (visualization_mode == 'matplotlib' and MATPLOTLIB_AVAILABLE) or
            (visualization_mode == 'web') # Web mode doesn't need specific backend libs here
        )

        self.is_setup = False
        self.audio_thread = None # SoundDevice can run in a thread
        self.visual_process = None # VisPy/Matplotlib run in separate process
        self.visual_data_queue = None # Queue for sending data to visual process
        self.stop_event = mp.Event() if self.enable_visual_output else threading.Event() # Use mp.Event for processes

        # --- Visual State ---
        self.pca = None
        self.pca_available = SKLEARN_AVAILABLE
        if self.pca_available and self.dim > 2:
            try:
                # Initialize PCA here for potential use in data prep
                self.pca = PCA(n_components=2)
                print("AVManager: PCA initialized for data preparation.")
            except Exception as e:
                print(f"AVManager: Warning - PCA init failed: {e}")
                self.pca = None
                self.pca_available = False # Mark as unavailable if init fails
        elif self.dim == 2:
             print("AVManager: Using raw 2D vectors for visual positioning.")
        else:
             print("AVManager: PCA not available or dim <= 2. Using basic positioning.")


        # --- Audio State ---
        self.audio_stream = None
        self.audio_params = {} # bot_av_idx -> {freq, amp, decay, phase, waveform}
        self.last_audio_update_time = 0
        self.active_audio_indices = set() # Track which bots are making sound
        self.last_audio_frame = 0 # Moved here

        # --- Web Visualization State ---
        self.socketio_instance = None # To be set if using web mode
        self.socketio_namespace = '/visuals' # Example namespace

        print(f"AVManager initialized: Bots={num_bots}, Dim={dim}, Device={device}, Audio={self.enable_audio_output}, Visuals={self.visualization_mode if self.enable_visual_output else 'none'}")

    def set_socketio_instance(self, sio):
        """ Set the SocketIO instance if using web visualization mode. """
        if self.visualization_mode == 'web':
            self.socketio_instance = sio
            print("AVManager: SocketIO instance set for web visualization.")

    def _audio_callback(self, outdata: np.ndarray, frames: int, time_info, status):
        """ SoundDevice callback to generate audio. (Runs in SoundDevice's thread) """
        if status: print(f"Audio Callback Status: {status}", flush=True)
        try:
            t = (self.last_audio_frame + np.arange(frames)) / SAMPLE_RATE
            outdata.fill(0)

            # Use a copy of keys/indices to avoid issues if the main thread modifies dict/set
            active_indices_copy = list(self.active_audio_indices)
            params_copy = self.audio_params.copy()

            num_active_audio = 0
            for av_idx in active_indices_copy:
                 if av_idx in params_copy:
                    params = params_copy[av_idx]
                    freq = params['freq']
                    amp = params['amp'] * params['decay']
                    phase = params['phase']
                    waveform_type = params.get('waveform', 'sine')

                    # Generate waveform
                    signal = np.zeros(frames, dtype=np.float32)
                    if waveform_type == 'sine': signal = np.sin(2 * np.pi * freq * t + phase)
                    elif waveform_type == 'square': signal = np.sign(np.sin(2 * np.pi * freq * t + phase))
                    elif waveform_type == 'chirp':
                         chirp_end_freq = freq * 1.2
                         # Need to calculate chirp phase correctly across blocks - simplified here
                         signal = chirp(t, f0=freq, f1=chirp_end_freq, t1=frames/SAMPLE_RATE, method='linear', phi=phase * 180 / np.pi) # Approx phase
                    else: signal = np.sin(2 * np.pi * freq * t + phase)

                    outdata[:, 0] += (signal * amp).astype(np.float32)
                    num_active_audio += 1

                    # Update state for the *original* dict for next block (needs thread safety if accessed elsewhere, but updates are infrequent)
                    # This direct update might be okay as _process_data_for_audio runs less often
                    if av_idx in self.audio_params:
                        self.audio_params[av_idx]['decay'] *= 0.99
                        new_phase = (phase + 2 * np.pi * freq * (frames / SAMPLE_RATE)) % (2 * np.pi)
                        self.audio_params[av_idx]['phase'] = new_phase
                        if self.audio_params[av_idx]['decay'] < 0.01:
                            # Schedule removal in the main thread? Or handle potential key errors in _process_data_for_audio
                            # For simplicity, let's try removing directly here, but be aware of potential race conditions
                            self.active_audio_indices.discard(av_idx)
                            # del self.audio_params[av_idx] # Safer to let _process_data handle cleanup

            if num_active_audio > 0:
                 max_val = np.max(np.abs(outdata))
                 if max_val > 1.0: outdata /= max_val

            outdata[:] = np.ascontiguousarray(outdata, dtype=np.float32)
            self.last_audio_frame += frames

        except Exception as e:
            print(f"Error in audio callback: {e}")
            outdata.fill(0)

    def _process_data_for_audio(self, av_data_batch):
        """ Updates internal audio parameters based on batch data. (Runs in main server thread/loop) """
        if not self.enable_audio_output: return

        now = time.monotonic()
        if now - self.last_audio_update_time < AUDIO_UPDATE_INTERVAL_S: return
        self.last_audio_update_time = now

        num_can_add = MAX_BOTS_FOR_AUDIO - len(self.active_audio_indices)
        added_count = 0

        # Clean up sounds that have decayed in the callback (check if key still exists)
        indices_to_remove = {idx for idx in self.active_audio_indices if idx not in self.audio_params or self.audio_params[idx]['decay'] < 0.01}
        for idx in indices_to_remove:
            self.active_audio_indices.discard(idx)
            if idx in self.audio_params:
                del self.audio_params[idx]

        # Sort bots by anomaly score
        sorted_indices = sorted(av_data_batch.keys(), key=lambda idx: av_data_batch[idx].get('anomaly_score', torch.tensor(0.0)).item(), reverse=True)

        for av_idx in sorted_indices:
            if 0 <= av_idx < self.num_bots:
                # Data comes in as tensors, convert to CPU float/bool
                data = av_data_batch[av_idx]
                anomaly = data.get('anomaly_score', torch.tensor(0.0)).item()
                weight_change = data.get('weight_change_metric', torch.tensor(0.0)).item()
                mode_code = data.get('mode_code', 5) # Already int
                is_player = data.get('is_player_controlled', False) # Already bool

                should_trigger = anomaly > 0.1 or weight_change > 0.05

                if av_idx in self.active_audio_indices and av_idx in self.audio_params:
                     # Update existing sound parameters
                     params = self.audio_params[av_idx]
                     params['freq'] = 220 + np.clip(anomaly * 2000, 0, 2000)
                     params['amp'] = np.clip(0.1 + weight_change * 5, 0.1, 0.8)
                     params['decay'] = 1.0 # Reset decay
                     if is_player: params['waveform'] = 'square'
                     elif mode_code == 0: params['waveform'] = 'sine'
                     elif mode_code == 1 or mode_code == 2: params['waveform'] = 'chirp'
                     else: params['waveform'] = 'sine'

                elif should_trigger and added_count < num_can_add:
                     # Add new sound
                     new_params = {
                         'freq': 220 + np.clip(anomaly * 2000, 0, 2000),
                         'amp': np.clip(0.1 + weight_change * 5, 0.1, 0.8),
                         'decay': 1.0,
                         'phase': np.random.rand() * 2 * np.pi,
                         'waveform': 'sine'
                     }
                     if is_player: new_params['waveform'] = 'square'
                     elif mode_code == 0: new_params['waveform'] = 'sine'
                     elif mode_code == 1 or mode_code == 2: new_params['waveform'] = 'chirp'

                     self.audio_params[av_idx] = new_params
                     self.active_audio_indices.add(av_idx)
                     added_count += 1

    def _prepare_data_for_visual_queue(self, av_data_batch):
        """ Converts tensor data to numpy/primitives suitable for inter-process queue. """
        prepared_batch = {}
        for av_idx, data in av_data_batch.items():
            prep_data = {}
            # Convert tensors to numpy arrays on CPU
            retrieved = data.get('retrieved_memory_vector')
            if retrieved is not None:
                prep_data['retrieved_memory_vector'] = retrieved.squeeze().detach().cpu().numpy()

            anomaly = data.get('anomaly_score')
            if anomaly is not None:
                prep_data['anomaly_score'] = anomaly.item() # Float

            weight_change = data.get('weight_change_metric')
            if weight_change is not None:
                prep_data['weight_change_metric'] = weight_change.item() # Float

            # Copy other primitive types
            prep_data['mode_code'] = data.get('mode_code', 5)
            prep_data['is_player_controlled'] = data.get('is_player_controlled', False)
            # Add input stream vector if needed by visualizer (optional)
            # input_vec = data.get('input_stream_vector')
            # if input_vec is not None:
            #     prep_data['input_stream_vector'] = input_vec.squeeze().detach().cpu().numpy()

            prepared_batch[av_idx] = prep_data
        return prepared_batch

    def _prepare_data_for_web(self, av_data_batch):
        """ Converts data to JSON-serializable format for SocketIO emission. """
        json_batch = {}
        # Similar to _prepare_data_for_visual_queue, but maybe less data needed
        # Example: Only send position, color, size components
        # This part depends heavily on the specific web visualization needs
        # For now, let's reuse the queue prep logic
        prepared_data = self._prepare_data_for_visual_queue(av_data_batch)

        # Further convert numpy arrays to lists if needed for JSON
        for av_idx, data in prepared_data.items():
            json_data = {}
            for key, value in data.items():
                if isinstance(value, np.ndarray):
                    json_data[key] = value.tolist() # Convert numpy arrays to lists
                else:
                    json_data[key] = value # Keep primitives
            json_batch[av_idx] = json_data
        return json_batch


    def setup(self):
        """ Initializes and starts the output systems based on mode. """
        if not self.enable_audio_output and not self.enable_visual_output:
            print("AVManager: All outputs disabled, setup skipped.")
            self.is_setup = False
            return

        print(f"AVManager: Setting up outputs (Audio: {self.enable_audio_output}, Visual: {self.visualization_mode})...")
        try:
            # --- Start Audio Thread ---
            if self.enable_audio_output:
                print(f"AVManager: Setting up SoundDevice stream (Rate: {SAMPLE_RATE}, Blocksize: {AUDIO_BLOCK_SIZE})...")
                self.last_audio_frame = 0
                self.audio_stream = sd.OutputStream(
                    samplerate=SAMPLE_RATE,
                    blocksize=AUDIO_BLOCK_SIZE,
                    channels=1, # Mono output
                    callback=self._audio_callback,
                    dtype='float32'
                )
                # Start stream in a separate thread to avoid potential blocking issues?
                # sd.OutputStream usually manages its own thread via the callback.
                self.audio_stream.start()
                print("AVManager: SoundDevice stream started.")
            else: print("AVManager: Audio output disabled.")

            # --- Start Visualization Process ---
            if self.enable_visual_output:
                if self.visualization_mode == 'vispy' and VISPY_AVAILABLE:
                    print("AVManager: Starting VisPy visualization process...")
                    self.visual_data_queue = mp.Queue()
                    self.visual_process = mp.Process(
                        target=_vispy_process_target,
                        args=(self.visual_data_queue, self.stop_event, self.num_bots, self.dim, self.pca_available),
                        daemon=True # Make daemon so it exits if main process exits
                    )
                    self.visual_process.start()
                elif self.visualization_mode == 'matplotlib' and MATPLOTLIB_AVAILABLE:
                    print("AVManager: Starting Matplotlib visualization process...")
                    self.visual_data_queue = mp.Queue()
                    self.visual_process = mp.Process(
                        target=_matplotlib_process_target,
                         args=(self.visual_data_queue, self.stop_event, self.num_bots, self.dim, self.pca_available),
                        daemon=True
                    )
                    self.visual_process.start()
                elif self.visualization_mode == 'web':
                    print("AVManager: Web visualization mode enabled. Waiting for SocketIO instance.")
                    # Setup happens when set_socketio_instance is called
                else:
                    print(f"AVManager: Visual output mode '{self.visualization_mode}' disabled or library not available.")
                    self.enable_visual_output = False # Ensure flag is false if not started

            self.is_setup = True
            print("AVManager: Setup complete.")

        except Exception as e:
            print(f"AVManager: ERROR during setup: {e}")
            traceback.print_exc()
            self.is_setup = False
            self.stop() # Attempt cleanup

    def update(self, av_data_batch: dict):
        """ Receives data from the server and processes/queues it. """
        if not self.is_setup or not av_data_batch:
            return

        # --- Process data directly for audio ---
        if self.enable_audio_output:
             try: self._process_data_for_audio(av_data_batch)
             except Exception as e: print(f"Error processing audio data: {e}")

        # --- Queue/Emit data for Visuals ---
        if self.enable_visual_output:
            if self.visualization_mode in ['vispy', 'matplotlib'] and self.visual_process and self.visual_process.is_alive():
                if self.visual_data_queue:
                    try:
                        # Prepare data (convert tensors to numpy/primitives)
                        prepared_data = self._prepare_data_for_visual_queue(av_data_batch)
                        # Put data in the queue for the visual process
                        self.visual_data_queue.put(prepared_data, block=False)
                    except queue.Full:
                        # print("Warning: Visual data queue full, dropping frame.") # Can be noisy
                        pass
                    except Exception as e:
                        print(f"Error preparing/queuing visual data: {e}")
            elif self.visualization_mode == 'web' and self.socketio_instance:
                 try:
                     # Prepare data for JSON serialization
                     json_data = self._prepare_data_for_web(av_data_batch)
                     # Emit data over SocketIO
                     self.socketio_instance.emit('visual_update', json_data, namespace=self.socketio_namespace)
                 except Exception as e:
                     print(f"Error preparing/emitting web visual data: {e}")


    def stop(self):
        """ Stops output threads/processes and cleans up resources. """
        print("AVManager: Stopping...")
        self.stop_event.set() # Signal threads/processes to stop

        # --- Stop Audio ---
        if self.audio_stream:
            try:
                print("AVManager: Stopping SoundDevice stream...")
                self.audio_stream.stop()
                self.audio_stream.close(ignore_errors=True)
                print("AVManager: SoundDevice stream stopped and closed.")
            except Exception as e:
                print(f"AVManager: Error stopping audio stream: {e}")
            self.audio_stream = None

        # --- Stop Visualization Process ---
        if self.visual_process and self.visual_process.is_alive():
             print(f"AVManager: Waiting for {self.visualization_mode} process to finish...")
             # Process should detect stop_event and exit gracefully
             self.visual_process.join(timeout=5.0) # Wait for process to exit
             if self.visual_process.is_alive():
                  print(f"AVManager: Warning: {self.visualization_mode} process did not exit gracefully. Terminating.")
                  self.visual_process.terminate() # Force terminate if needed
                  self.visual_process.join(timeout=1.0) # Wait after terminate
             else:
                  print(f"AVManager: {self.visualization_mode} process joined.")
        if self.visual_data_queue:
            self.visual_data_queue.close()
            self.visual_data_queue.join_thread() # Ensure queue feeder threads are finished

        self.visual_process = None
        self.visual_data_queue = None
        self.is_setup = False
        print("AVManager: Stop sequence complete.")

# --- Global Functions for Server Interaction ---

# Keep track of the manager instance globally within this module
_current_av_manager = None

def setup_av_system(num_bots, dim, device, enable_output, visualization_mode, socketio_instance=None):
    """ Creates, sets up, and returns the AVManager instance. """
    global _current_av_manager
    if _current_av_manager:
        print("Warning: Existing AVManager found during setup. Stopping previous one.")
        stop_av_system(_current_av_manager)
        _current_av_manager = None

    # Check library availability based on mode
    libs_ok = True
    if visualization_mode == 'vispy' and not VISPY_AVAILABLE: libs_ok = False
    if visualization_mode == 'matplotlib' and not MATPLOTLIB_AVAILABLE: libs_ok = False
    if not SOUNDDEVICE_AVAILABLE and enable_output: # Audio is independent of visual mode
        print("Warning: SoundDevice not available, audio output will be disabled.")
        # Don't set libs_ok to False, just disable audio

    if not libs_ok and enable_output:
         print(f"AV Setup Skipped: Required library for mode '{visualization_mode}' is not available.")
         return None

    try:
        print(f"Setting up AV System: Mode={visualization_mode}, Bots={num_bots}, Dim={dim}, Device={device}, Output={enable_output}")
        manager = AVManager(num_bots, dim, device, enable_output, visualization_mode)

        # Pass SocketIO instance if using web mode
        if visualization_mode == 'web' and socketio_instance:
            manager.set_socketio_instance(socketio_instance)

        manager.setup() # Initialize VisPy/SoundDevice/etc.

        if manager.is_setup or not enable_output: # Consider setup successful if output was disabled
             _current_av_manager = manager
             print("AV System setup successful.")
             return manager
        else:
             print("AV System setup failed.")
             manager.stop() # Ensure cleanup even if setup failed
             return None
    except Exception as e:
        print(f"FATAL ERROR during AV setup: {e}")
        traceback.print_exc()
        if _current_av_manager: # Cleanup if partially created
             _current_av_manager.stop()
             _current_av_manager = None
        return None

def update_av_system(manager: AVManager, av_data_batch: dict):
    """ Updates the AV system with new data. """
    # Check manager exists, is setup, AND has at least one output enabled
    if manager and manager.is_setup and (manager.enable_audio_output or manager.enable_visual_output):
        try:
            manager.update(av_data_batch)
        except Exception as e:
            print(f"Error during AV update: {e}")
            # traceback.print_exc() # Can be noisy

def stop_av_system(manager: AVManager):
    """ Stops the AV system and cleans up resources. """
    global _current_av_manager
    if manager:
        print("Stopping AV System...")
        try:
            manager.stop()
            print("AV System stopped.")
        except Exception as e:
            print(f"Error during AV stop: {e}")
            traceback.print_exc()
    if manager is _current_av_manager:
         _current_av_manager = None # Clear global ref if it's the current one

print("Audiovisualization Library Loaded.")
# Add a check for MacOS backend issue with multiprocessing and VisPy/Matplotlib
if sys.platform == "darwin":
    try:
        # Check if the backend is 'tk' which often causes issues on MacOS with multiprocessing
        # This might need adjustment based on the actual backend used by VisPy/Matplotlib
        # vispy.use(app='glfw') # Example: Try forcing GLFW backend for VisPy if available
        # import matplotlib
        # current_backend = matplotlib.get_backend()
        # if 'tk' in current_backend.lower():
        #      print("\nWARNING: Detected 'TkAgg' Matplotlib backend on MacOS.")
        #      print("Visualization via Matplotlib in a separate process might be unstable or require specific setup.")
        #      print("Consider using 'vispy' mode or 'web' mode if issues occur.\n")
        # Forcing backend might need to happen earlier or via environment variables
        pass # Keep check simple for now
    except Exception as e:
        print(f"Note: Could not check visualization backend details ({e})")

```
--- END OF MODIFIED FILE `audiovisualization.py` ---

--- START OF MODIFIED FILE `server.py` ---

```python
# Filename: server.py
# coding: utf-8
import os
import time
import math
import random
import numpy as np
from collections import deque, namedtuple
from functools import partial
import copy # For deep copying states if needed
import traceback # For detailed error logging
import sys # For stderr printing
import multiprocessing as mp # Import multiprocessing

# --- Eventlet Monkey Patching (IMPORTANT: Must be done early) ---
# Consider conditional patching if VisPy/Matplotlib have issues with it
# For now, keep it enabled as SocketIO relies on it.
import eventlet
# Check if we need to avoid patching 'thread' if using certain AV modes?
# Needs testing, but patching is usually required for SocketIO async modes.
eventlet.monkey_patch()
print("Eventlet monkey patching applied.")

# --- Flask & SocketIO Setup ---
from flask import Flask, render_template, request, jsonify, Response # Added Response
from flask_socketio import SocketIO, emit, Namespace # Added Namespace

app = Flask(__name__, template_folder='.') # Look for index.html in the same directory
app.config['SECRET_KEY'] = os.urandom(24)
# Use eventlet for async mode
socketio = SocketIO(app, async_mode='eventlet', cors_allowed_origins="*")

print("Flask and SocketIO initialized.")

# --- PyTorch Setup ---
import torch
from torch import nn, Tensor, is_tensor, cat, stack
import torch.nn.functional as F
from torch.nn import Module, ModuleList, Linear, Parameter, ParameterList

# --- Import Custom Libraries ---
try:
    from neural_memory_lib import NeuralMemoryManager, NeuralMemState, mem_state_detach
    print("Neural Memory Library imported successfully.")
    NEURAL_LIB_AVAILABLE = True
except ImportError as e:
    print(f"FATAL ERROR: Failed to import neural_memory_lib.py: {e}")
    traceback.print_exc()
    NEURAL_LIB_AVAILABLE = False
    NeuralMemoryManager = None # Define as None if import fails
    NeuralMemState = namedtuple('DummyNeuralMemState', ['seq_index', 'weights', 'optim_state'])
    mem_state_detach = lambda state: state

try:
    # Import AV functions/class from the new file
    from audiovisualization import setup_av_system, update_av_system, stop_av_system, AVManager
    print("Audiovisualization Library imported successfully.")
    AV_LIB_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Failed to import audiovisualization.py: {e}. AV features disabled.")
    AV_LIB_AVAILABLE = False
    # Define dummy functions so calls don't break server logic
    setup_av_system = lambda *args, **kwargs: None
    update_av_system = lambda *args, **kwargs: None
    stop_av_system = lambda *args, **kwargs: None
    AVManager = None # Define AVManager as None

# --- Determine Device ---
try:
    if torch.cuda.is_available():
        # Check if multiprocessing context needs to be set for CUDA
        if sys.platform != 'win32': # 'fork' context (default on Linux/Mac) can have issues with CUDA
            if mp.get_start_method(allow_none=True) is None or mp.get_start_method(allow_none=True) == 'fork':
                print("Warning: Setting multiprocessing start method to 'spawn' for CUDA compatibility.")
                # mp.set_start_method('spawn', force=True) # Use spawn for CUDA safety
                # NOTE: 'spawn' is generally safer but might be slower.
                # If 'spawn' causes issues elsewhere, consider 'forkserver'.
                # Forcing can be problematic if libraries expect 'fork'. Test carefully.
                # Let's try without forcing first, rely on user setting CUDA_VISIBLE_DEVICES if needed.
                pass

        device = torch.device("cuda")
        print(f"CUDA available. Using GPU: {torch.cuda.get_device_name(torch.cuda.current_device())}")
        try:
            _ = torch.tensor([1.0], device=device)
            torch.cuda.empty_cache()
            print("CUDA device test successful and memory cache cleared.")
        except Exception as e:
            print(f"Warning: CUDA device error during test/clear cache: {e}. Falling back to CPU.")
            traceback.print_exc()
            device = torch.device("cpu")
    else:
        device = torch.device("cpu")
        print("CUDA not available. Using CPU.")
except Exception as e:
    print(f"Error during PyTorch device setup: {e}. Falling back to CPU.")
    device = torch.device("cpu")

# ================================================================
# --- DEFAULT CONFIGURATION ---
# ================================================================
DEFAULT_CONFIG = {
    # Simulation Params
    "GRID_SIZE": 25,
    "NUM_HC_BOTS": 1,
    "NUM_LEARNING_BOTS": 4,
    "NUM_GOALS": 5,
    "OBSTACLES_FACTOR_MIN": 0.03,
    "OBSTACLES_FACTOR_MAX": 0.08,
    "MAX_STEPS_PER_ROUND": 1000,
    "SIMULATION_SPEED_MS": 30,
    "FREEZE_DURATION": 15,
    "VISIBILITY_RANGE": 8,
    "NUM_ACTIONS": 6, # 0:Up, 1:Left, 2:Right, 3:Down, 4:Punch, 5:ClaimGoal
    "RANDOMIZE_ENV_PER_ROUND": True, # Generate new obstacles/starts each round?

    # Titans-Inspired Learning Bot Params (Library)
    "LEARNING_BOT_DIM": 128,
    "LEARNING_BOT_MEM_DEPTH": 2,
    "LEARNING_BOT_LR": 0.001,
    "LEARNING_BOT_WEIGHT_DECAY": 0.01,
    "LEARNING_BOT_MOMENTUM": 0.9,
    "LEARNING_BOT_MAX_GRAD_NORM": 1.0,

    # Learning Bot Behavior (Outside Library)
    "LEARNING_BOT_BASE_EXPLORATION_RATE": 15.0, # Percentage 0-100
    "LEARNING_BOT_RULE_EXPLORE_PERCENT": 60.0, # Percentage 0-100
    "PLAYER_CONTROL_PERCENT": 100.0, # Player control influence (0-100)

    # Env Generation Params
    "MIN_GOAL_START_DISTANCE_FACTOR": 0.15,
    "MIN_BOT_START_DISTANCE_FACTOR": 0.25,
    "MIN_BOT_GOAL_DISTANCE_FACTOR": 0.15,

    # Audiovisualization Options
    "ENABLE_AV": True, # Default to True, but requires libs
    "ENABLE_AV_OUTPUT": True, # Default to True, controls VisPy/SoundDevice/etc.
    "VISUALIZATION_MODE": "vispy", # Options: 'vispy', 'matplotlib', 'web', 'none'
}
current_config = copy.deepcopy(DEFAULT_CONFIG)

# --- Global State ---
bots = {} # bot_id -> bot_state_dict
players = {} # sid -> {'player_bot_id': player_bot_id, 'original_bot_id': original_learning_bot_id}
environment = None
neural_memory_manager = None # Instance of NeuralMemoryManager
av_manager = None # Instance of AVManager (or None if disabled/failed)
simulation_running = False
simulation_loop_task = None
round_number = 0
stats = {'hc_total_goals': 0, 'learning_total_goals': 0}
player_direct_actions = {} # sid -> action_code (for mobile buttons)

# --- Function to Update NN Manager ---
def update_neural_memory_manager_instance():
    """ Creates or updates the NeuralMemory manager based on current_config """
    global neural_memory_manager
    if not NEURAL_LIB_AVAILABLE:
        print("Error: Cannot update NN Manager, library not available.")
        neural_memory_manager = None
        return False

    print("Updating Neural Memory Manager...")
    try:
        # Check if manager exists and if relevant params changed
        needs_new_manager = True
        if neural_memory_manager:
             current_dim = getattr(neural_memory_manager, 'dim', -1)
             current_lr = neural_memory_manager.optimizer_config.get('lr', -1)
             current_wd = neural_memory_manager.optimizer_config.get('weight_decay', -1)
             current_beta1 = neural_memory_manager.optimizer_config.get('betas', (-1,))[0]
             current_grad_norm = getattr(neural_memory_manager, 'max_grad_norm', -1)
             current_depth = 0
             if hasattr(neural_memory_manager, 'memory_model_template') and hasattr(neural_memory_manager.memory_model_template, 'net'):
                 current_depth = sum(1 for m in neural_memory_manager.memory_model_template.net if isinstance(m, nn.Linear))

             if (current_dim == current_config['LEARNING_BOT_DIM'] and
                 abs(current_lr - current_config['LEARNING_BOT_LR']) < 1e-9 and
                 abs(current_wd - current_config['LEARNING_BOT_WEIGHT_DECAY']) < 1e-9 and
                 abs(current_beta1 - current_config['LEARNING_BOT_MOMENTUM']) < 1e-9 and
                 abs(current_grad_norm - current_config['LEARNING_BOT_MAX_GRAD_NORM']) < 1e-9 and
                 current_depth == current_config['LEARNING_BOT_MEM_DEPTH'] and
                 neural_memory_manager.target_device == device):
                  needs_new_manager = False
             else:
                  print("NNM parameters changed, recreating...")
                  if neural_memory_manager.target_device != device:
                       print(f"  Device changed from {neural_memory_manager.target_device} to {device}")

        if needs_new_manager:
            print("Creating new NN Manager instance...")
            if neural_memory_manager: del neural_memory_manager; torch.cuda.empty_cache() if device.type == 'cuda' else None

            neural_memory_manager = NeuralMemoryManager(
                dim=current_config['LEARNING_BOT_DIM'],
                mem_model_depth=current_config['LEARNING_BOT_MEM_DEPTH'],
                learning_rate=current_config['LEARNING_BOT_LR'],
                weight_decay=current_config['LEARNING_BOT_WEIGHT_DECAY'],
                momentum_beta=current_config['LEARNING_BOT_MOMENTUM'],
                max_grad_norm=current_config['LEARNING_BOT_MAX_GRAD_NORM'],
                target_device=device
            )
            print(f"New Neural Memory Manager ready on device: {device}")
            return True # Indicates manager was recreated
        else:
            print("Existing NN Manager is compatible, reusing.")
            return False # Indicates manager was reused

    except Exception as e:
         print(f"FATAL: Failed to create/update Neural Memory Manager: {e}")
         traceback.print_exc()
         neural_memory_manager = None
         return False

# --- Function to Update AV Manager ---
def update_av_manager_instance():
    """ Creates or stops/recreates the AV manager based on config """
    global av_manager
    enable_av = current_config.get("ENABLE_AV", False)
    enable_av_output = current_config.get("ENABLE_AV_OUTPUT", False)
    visualization_mode = current_config.get("VISUALIZATION_MODE", "none")

    if not AV_LIB_AVAILABLE and enable_av:
        print("Warning: AV Library not available, cannot enable AV Manager.")
        enable_av = False # Force disable if lib missing

    state_changed = False
    if enable_av:
        num_av_bots = current_config.get('NUM_LEARNING_BOTS', 0)
        av_dim = current_config.get('LEARNING_BOT_DIM', 0)

        needs_new_av_manager = True
        if av_manager and isinstance(av_manager, AVManager):
            if (av_manager.num_bots == num_av_bots and
                av_manager.dim == av_dim and
                av_manager.enable_audio_output == (enable_av_output and SOUNDDEVICE_AVAILABLE) and # Check actual audio capability
                av_manager.visualization_mode == (visualization_mode if enable_av_output else 'none') and # Check actual visual mode
                str(av_manager.device) == str(device)):
                needs_new_av_manager = False
                print(f"Existing AV Manager compatible (Mode: {av_manager.visualization_mode}, Audio: {av_manager.enable_audio_output}).")
            else:
                print("AV parameters, device, or mode changed, recreating AV Manager...")
                stop_av_system(av_manager)
                av_manager = None

        if needs_new_av_manager:
            print(f"Creating new AV Manager instance (Mode: {visualization_mode})...")
            if av_manager: stop_av_system(av_manager) # Ensure stop again

            # Pass socketio instance if web mode is selected
            sio_instance = socketio if visualization_mode == 'web' else None

            av_manager = setup_av_system(
                num_bots=num_av_bots,
                dim=av_dim,
                device=device,
                enable_output=enable_av_output,
                visualization_mode=visualization_mode,
                socketio_instance=sio_instance # Pass socketio instance
            )
            if av_manager:
                 print("New AV Manager created successfully.")
                 state_changed = True
            else:
                 print("Warning: Failed to create new AV Manager instance.")
                 # Keep av_manager as None
    else:
        # AV should be disabled
        if av_manager:
            print("Disabling and stopping AV Manager...")
            stop_av_system(av_manager)
            av_manager = None
            state_changed = True

    return state_changed

# ================================================================
# --- Simulation Environment (No changes needed from previous version) ---
# ================================================================
class GridEnvironment:
    def __init__(self, size, num_goals, obstacles_factor_range, num_hc_bots, num_learning_bots, config_factors):
        self.size = max(10, int(size))
        self.num_goals = max(0, int(num_goals))
        self.min_obstacles_factor, self.max_obstacles_factor = obstacles_factor_range
        self.num_hc_bots = max(0, int(num_hc_bots))
        self.num_learning_bots = max(0, int(num_learning_bots))
        self.config_factors = {
            'goal_dist': config_factors.get('MIN_GOAL_START_DISTANCE_FACTOR', 0.15),
            'bot_dist': config_factors.get('MIN_BOT_START_DISTANCE_FACTOR', 0.25),
            'bot_goal_dist': config_factors.get('MIN_BOT_GOAL_DISTANCE_FACTOR', 0.15)
        }
        self.obstacles = set()
        self.goals = []
        self.claimed_goals = set()
        self.start_positions = []
        self._initial_goals = []

        try:
            self.randomize() # Initial randomization
        except Exception as e:
            print(f"FATAL ERROR during environment initialization: {e}")
            traceback.print_exc()
            # Provide minimal safe defaults
            self.size=10; self.num_goals=0; self.num_hc_bots=0; self.num_learning_bots=0
            self.goals=[]; self.obstacles=set(); self.start_positions=[]; self._initial_goals = []


    def _manhattan_distance(self, pos1, pos2):
        if not pos1 or not pos2 or 'x' not in pos1 or 'y' not in pos1 or 'x' not in pos2 or 'y' not in pos2: return float('inf')
        return abs(pos1['x'] - pos2['x']) + abs(pos1['y'] - pos2['y'])

    def randomize(self):
        """Generates a new layout for obstacles, goals, and bot start positions."""
        self.obstacles.clear()
        self.goals = []
        self.claimed_goals.clear()
        self.start_positions = []
        total_bots = self.num_hc_bots + self.num_learning_bots
        total_cells = self.size * self.size
        required_items = total_bots + self.num_goals
        print(f"Randomizing Env: Size={self.size}x{self.size}, Goals={self.num_goals}, HC={self.num_hc_bots}, Lrn={self.num_learning_bots}")

        if total_cells <= 0: raise ValueError("Grid size must be positive.")
        if required_items == 0: print("No goals or bots to place."); # Still place obstacles below

        occupied = set()
        max_placement_attempts = max(required_items * 100, total_cells * 20) # Increased attempts
        attempts = 0

        def is_valid_placement(pos_tuple, occupied_set, check_dists={}):
            if not (0 <= pos_tuple[0] < self.size and 0 <= pos_tuple[1] < self.size): return False
            if pos_tuple in occupied_set: return False
            pos_dict = {'x': pos_tuple[0], 'y': pos_tuple[1]}
            # Check distances (more efficiently)
            if 'goal_min_dist' in check_dists:
                min_d = check_dists['goal_min_dist']
                if any(self._manhattan_distance(pos_dict, g) < min_d for g in self.goals): return False
            if 'bot_min_dist' in check_dists:
                min_d = check_dists['bot_min_dist']
                if any(self._manhattan_distance(pos_dict, sp) < min_d for sp in self.start_positions): return False
            if 'bot_goal_min_dist' in check_dists:
                min_d = check_dists['bot_goal_min_dist']
                if any(self._manhattan_distance(pos_dict, g) < min_d for g in self.goals): return False
            return True

        # --- Place Goals ---
        min_goal_dist = max(2, int(self.size * self.config_factors['goal_dist']))
        goal_id_counter = 0
        attempts = 0
        while len(self.goals) < self.num_goals and attempts < max_placement_attempts:
            attempts += 1
            pos = (random.randint(0, self.size - 1), random.randint(0, self.size - 1))
            if is_valid_placement(pos, occupied, {'goal_min_dist': min_goal_dist}):
                goal = {'x': pos[0], 'y': pos[1], 'id': f'G{goal_id_counter}'}
                self.goals.append(goal); occupied.add(pos); goal_id_counter += 1
        if len(self.goals) < self.num_goals: print(f"Warning: Placed only {len(self.goals)}/{self.num_goals} goals after {attempts} attempts.")

        # --- Place Bots ---
        min_bot_dist = max(3, int(self.size * self.config_factors['bot_dist']))
        min_bot_goal_dist = max(3, int(self.size * self.config_factors['bot_goal_dist']))
        attempts = 0
        placed_bots = 0
        # Create bot positions first, then assign types/IDs
        temp_bot_positions = []
        while len(temp_bot_positions) < total_bots and attempts < max_placement_attempts:
            attempts += 1
            pos = (random.randint(0, self.size - 1), random.randint(0, self.size - 1))
            # Need to check against already placed temp bots too
            temp_occupied = occupied.union(set(temp_bot_positions))
            if is_valid_placement(pos, temp_occupied, {'bot_min_dist': min_bot_dist, 'bot_goal_min_dist': min_bot_goal_dist}):
                temp_bot_positions.append(pos)

        # Assign IDs and types sequentially to the successfully placed positions
        hc_placed = 0; ln_placed = 0
        for idx, pos in enumerate(temp_bot_positions):
             bot_type = 'Hardcoded' if idx < self.num_hc_bots else 'Learning'
             if bot_type == 'Hardcoded': bot_num = hc_placed; hc_placed += 1
             else: bot_num = ln_placed; ln_placed += 1
             bot_id = f'{bot_type[0]}{bot_num}'
             self.start_positions.append({'x': pos[0], 'y': pos[1], 'type': bot_type, 'id': bot_id})
             occupied.add(pos) # Add to main occupied set

        if len(self.start_positions) < total_bots:
             print(f"CRITICAL Warning: Placed only {len(self.start_positions)}/{total_bots} bots. Adjusting counts.")
             self.num_hc_bots = hc_placed
             self.num_learning_bots = ln_placed


        # --- Place Obstacles ---
        num_obstacles_to_place = random.randint(
            int(total_cells * self.min_obstacles_factor),
            int(total_cells * self.max_obstacles_factor)
        ) if total_cells > 0 else 0
        attempts = 0
        placed_obstacles = 0
        while placed_obstacles < num_obstacles_to_place and attempts < max_placement_attempts:
             attempts += 1
             pos = (random.randint(0, self.size - 1), random.randint(0, self.size - 1))
             if is_valid_placement(pos, occupied): # Check against goals and bots
                 self.obstacles.add(pos); occupied.add(pos); placed_obstacles += 1

        self._initial_goals = [{'x': g['x'], 'y': g['y'], 'id': g['id']} for g in self.goals]
        print(f"Environment randomized. Placed {len(self.goals)} goals, {len(self.start_positions)} bots, {len(self.obstacles)} obstacles.")

    def reset_round_state(self):
        """Resets goal claims, keeping the same obstacle/start layout."""
        self.claimed_goals.clear()
        # Use the stored initial goals to reset
        self.goals = [{'x': g['x'], 'y': g['y'], 'id': g['id']} for g in self._initial_goals]
        print(f"Round state reset. {len(self.goals)} goals active.")

    def is_valid(self, pos):
        """Checks if a position is within bounds and not an obstacle."""
        if not pos or 'x' not in pos or 'y' not in pos: return False
        x, y = pos['x'], pos['y']
        return 0 <= x < self.size and 0 <= y < self.size and (x, y) not in self.obstacles

    def find_path(self, start_pos, goal_pos, all_bots_dict=None, moving_bot_id=None):
        """ Finds a path using BFS, avoiding obstacles and other bots (optional). """
        if not self.is_valid(start_pos) or goal_pos is None: return None # Goal might be invalid if claimed
        # Check if goal is valid before proceeding
        if not (0 <= goal_pos.get('x', -1) < self.size and 0 <= goal_pos.get('y', -1) < self.size):
             return None # Goal is outside bounds

        start_tuple = (start_pos['x'], start_pos['y'])
        goal_tuple = (goal_pos['x'], goal_pos['y'])
        if start_tuple == goal_tuple: return []

        current_obstacles = self.obstacles.copy()
        if all_bots_dict:
            for bot_id, bot_state in all_bots_dict.items():
                if bot_id == moving_bot_id: continue # Don't block self
                current_obstacles.add((bot_state['pos']['x'], bot_state['pos']['y']))

        queue = deque([(start_tuple, [])])
        visited = {start_tuple}
        # Up, Left, Right, Down actions
        deltas = [(0, -1, 0), (-1, 0, 1), (1, 0, 2), (0, 1, 3)]

        max_path_len = self.size * self.size # Limit search depth reasonably

        while queue:
            current_pos_tuple, path = queue.popleft()

            if len(path) >= max_path_len: continue # Limit search depth

            for dx, dy, action in deltas: # Corrected order dx, dy, action
                next_x, next_y = current_pos_tuple[0] + dx, current_pos_tuple[1] + dy
                next_pos_tuple = (next_x, next_y)

                if next_pos_tuple == goal_tuple: # Found goal
                    return path + [action]

                if (0 <= next_x < self.size and 0 <= next_y < self.size and
                    next_pos_tuple not in current_obstacles and next_pos_tuple not in visited):
                    visited.add(next_pos_tuple)
                    new_path = path + [action]
                    queue.append((next_pos_tuple, new_path))
        return None # No path found


    def get_sensory_data(self, acting_bot, all_bots_dict, visibility_range):
        """ Gathers sensory information for a bot. """
        bot_pos = acting_bot['pos']
        vis_range = max(1, int(visibility_range))
        senses = {
            'wall_distance_N': bot_pos['y'],
            'wall_distance_S': self.size - 1 - bot_pos['y'],
            'wall_distance_W': bot_pos['x'],
            'wall_distance_E': self.size - 1 - bot_pos['x'],
            'nearest_goal_dist': vis_range + 1,
            'nearest_goal_dx': 0,
            'nearest_goal_dy': 0,
            'num_visible_goals': 0,
            'nearest_opponent_dist': vis_range + 1,
            'nearest_opponent_dx': 0,
            'nearest_opponent_dy': 0,
            'opponent_is_frozen': 0.0, # Float 0.0 or 1.0
            'opponent_type_HC': 0.0,
            'opponent_type_LN': 0.0,
            'opponent_type_PL': 0.0,
            'self_is_frozen': 1.0 if acting_bot['freezeTimer'] > 0 else 0.0,
            '_visibleGoals': [], # Internal list for HC bot logic
            '_nearestOpponent': None # Internal dict for HC bot logic
        }

        min_goal_dist = vis_range + 1
        nearest_goal_obj = None
        for goal in self.goals:
             if goal['id'] not in self.claimed_goals:
                 dist = self._manhattan_distance(bot_pos, goal)
                 if dist <= vis_range:
                     senses['num_visible_goals'] += 1
                     senses['_visibleGoals'].append({'x': goal['x'], 'y': goal['y'], 'id': goal['id'], 'dist': dist})
                     if dist < min_goal_dist:
                         min_goal_dist = dist
                         nearest_goal_obj = goal

        senses['nearest_goal_dist'] = min_goal_dist
        if nearest_goal_obj:
             senses['nearest_goal_dx'] = nearest_goal_obj['x'] - bot_pos['x']
             senses['nearest_goal_dy'] = nearest_goal_obj['y'] - bot_pos['y']

        min_opp_dist = vis_range + 1
        nearest_opponent_obj = None
        for opp_id, opponent_bot in all_bots_dict.items():
             if opp_id == acting_bot['id']: continue
             dist = self._manhattan_distance(bot_pos, opponent_bot['pos'])
             if dist <= vis_range:
                 if dist < min_opp_dist:
                     min_opp_dist = dist
                     nearest_opponent_obj = opponent_bot

        senses['nearest_opponent_dist'] = min_opp_dist
        if nearest_opponent_obj:
            senses['_nearestOpponent'] = nearest_opponent_obj # Store full obj for HC logic
            senses['nearest_opponent_dx'] = nearest_opponent_obj['pos']['x'] - bot_pos['x']
            senses['nearest_opponent_dy'] = nearest_opponent_obj['pos']['y'] - bot_pos['y']
            senses['opponent_is_frozen'] = 1.0 if nearest_opponent_obj['freezeTimer'] > 0 else 0.0
            is_player = nearest_opponent_obj.get('is_player_controlled', False)
            if is_player: senses['opponent_type_PL'] = 1.0
            elif nearest_opponent_obj['type'] == 'Hardcoded': senses['opponent_type_HC'] = 1.0
            elif nearest_opponent_obj['type'] == 'Learning': senses['opponent_type_LN'] = 1.0


        # Sort visible goals by distance for HC logic
        senses['_visibleGoals'].sort(key=lambda g: g['dist'])
        return senses


    def perform_move_action(self, bot_pos, action_index):
        """ Calculates the resulting position from a move action. """
        next_pos = bot_pos.copy()
        # 0:Up, 1:Left, 2:Right, 3:Down
        delta = [(0, -1), (-1, 0), (1, 0), (0, 1)] # Corrected deltas (dx, dy)
        if 0 <= action_index <= 3:
            dx, dy = delta[action_index]
            next_pos['x'] += dx
            next_pos['y'] += dy
        return next_pos

    def get_adjacent_unclaimed_goal(self, bot_pos):
        """ Finds an adjacent, unclaimed goal. """
        for goal in self.goals:
            if goal['id'] not in self.claimed_goals:
                if self._manhattan_distance(bot_pos, goal) == 1:
                    return goal
        return None

    def claim_goal(self, goal_id, bot_id):
        """ Marks a goal as claimed if it exists and is not claimed. """
        if goal_id in self.claimed_goals: return False
        goal_exists = any(g['id'] == goal_id for g in self.goals)
        if goal_exists:
            self.claimed_goals.add(goal_id)
            return True
        return False

    def are_all_goals_claimed(self):
         """ Checks if all initially placed goals are claimed. """
         return len(self._initial_goals) > 0 and len(self.claimed_goals) >= len(self._initial_goals)

    def get_state(self):
        """ Gets the current serializable state of the environment. """
        active_goals = [g for g in self.goals if g['id'] not in self.claimed_goals]
        return {
            'size': self.size,
            'goals': active_goals,
            'obstacles': list(self.obstacles), # Convert set to list for JSON
            'claimedGoals': list(self.claimed_goals) # Convert set to list
        }

# ================================================================
# --- Bot Logic (No changes needed from previous version) ---
# ================================================================

# --- Hardcoded Bot Logic ---
def get_hardcoded_action(bot_state, senses, env, all_bots_dict):
    bot_id, pos = bot_state['id'], bot_state['pos']
    bot_state.setdefault('stuckCounter', 0)
    bot_state.setdefault('currentPath', None)
    bot_state.setdefault('lastAction', -1)
    bot_state.setdefault('targetGoalId', None)
    bot_state.setdefault('lastPos', {'x': -1, 'y': -1})
    bot_state.setdefault('randomMoveCounter', 0)

    if pos == bot_state['lastPos']: bot_state['stuckCounter'] += 1
    else: bot_state['stuckCounter'] = 0; bot_state['lastPos'] = pos.copy(); bot_state['randomMoveCounter'] = 0

    if bot_state['freezeTimer'] > 0:
        bot_state['stuckCounter'] = 0; bot_state['currentPath'] = None; bot_state['targetGoalId'] = None; bot_state['randomMoveCounter'] = 0
        return -1, "Frozen"

    adjacent_goal = env.get_adjacent_unclaimed_goal(pos)
    if adjacent_goal:
        bot_state['stuckCounter'] = 0; bot_state['currentPath'] = None; bot_state['targetGoalId'] = None; bot_state['randomMoveCounter'] = 0
        return 5, f"Claim {adjacent_goal['id']}"

    nearest_opponent = senses.get('_nearestOpponent')
    if nearest_opponent and senses.get('nearest_opponent_dist', 99) == 1 and not senses.get('opponent_is_frozen'):
        bot_state['stuckCounter'] = 0; bot_state['currentPath'] = None; bot_state['targetGoalId'] = None; bot_state['randomMoveCounter'] = 0
        return 4, f"Punch {nearest_opponent['id']}"

    if bot_state['stuckCounter'] >= 5 and bot_state['randomMoveCounter'] < 3:
         bot_state['randomMoveCounter'] += 1
         bot_state['currentPath'] = None; bot_state['targetGoalId'] = None
         valid_moves = []
         for action_idx in range(4):
             next_p = env.perform_move_action(pos, action_idx)
             occupied_by_active = any(bid != bot_id and b['pos'] == next_p and b.get('freezeTimer', 0) <= 0 for bid, b in all_bots_dict.items())
             if env.is_valid(next_p) and not occupied_by_active: valid_moves.append(action_idx)
         if valid_moves: return random.choice(valid_moves), f"StuckRandom ({bot_state['stuckCounter']})"
         else: return -1, "StuckBlocked"
    elif bot_state['stuckCounter'] >= 5:
         return -1, f"Stuck ({bot_state['stuckCounter']})"

    current_path = bot_state.get('currentPath')
    if current_path:
        next_action = current_path[0]
        intended_pos = env.perform_move_action(pos, next_action)
        is_pos_valid = env.is_valid(intended_pos)
        is_pos_occupied_by_other = any(other_id != bot_id and other_bot['pos'] == intended_pos for other_id, other_bot in all_bots_dict.items())

        if is_pos_valid and not is_pos_occupied_by_other:
            bot_state['currentPath'].pop(0)
            mode_str = f"Path ({len(bot_state['currentPath'])} left)"
            if not bot_state['currentPath']: bot_state['targetGoalId'] = None; mode_str = "Path End"
            bot_state['randomMoveCounter'] = 0
            return next_action, mode_str
        else:
            bot_state['currentPath'] = None; bot_state['targetGoalId'] = None

    visible_goals = senses.get('_visibleGoals', [])
    target_goal_obj = None
    if bot_state['targetGoalId']:
        potential_target = next((g for g in visible_goals if g['id'] == bot_state['targetGoalId']), None)
        if potential_target: target_goal_obj = potential_target
        else: bot_state['targetGoalId'] = None

    if not target_goal_obj and visible_goals:
        target_goal_obj = visible_goals[0]; bot_state['targetGoalId'] = target_goal_obj['id']

    if target_goal_obj:
        path_to_goal = env.find_path(pos, target_goal_obj, all_bots_dict, bot_id)
        if path_to_goal:
            bot_state['currentPath'] = path_to_goal
            if bot_state['currentPath']:
                next_action = bot_state['currentPath'].pop(0)
                mode_str = f"NewPath ({len(bot_state['currentPath'])} left)"
                if not bot_state['currentPath']: bot_state['targetGoalId'] = None; mode_str="NewPath End"
                bot_state['randomMoveCounter'] = 0
                return next_action, mode_str
            else:
                 bot_state['targetGoalId'] = None; bot_state['currentPath'] = None

    valid_moves = []
    for action_idx in range(4):
        next_p = env.perform_move_action(pos, action_idx)
        occupied_by_active = any(bid != bot_id and b['pos'] == next_p and b.get('freezeTimer', 0) <= 0 for bid, b in all_bots_dict.items())
        if env.is_valid(next_p) and not occupied_by_active: valid_moves.append(action_idx)

    if not valid_moves:
        return -1, "Blocked"

    last_action = bot_state.get('lastAction', -1)
    reverse_action = -1
    if 0 <= last_action <= 3: reverse_map = {0: 3, 1: 2, 2: 1, 3: 0}; reverse_action = reverse_map.get(last_action)

    non_reverse_moves = [m for m in valid_moves if m != reverse_action]
    chosen_move = -1

    if non_reverse_moves: chosen_move = random.choice(non_reverse_moves)
    elif valid_moves: chosen_move = random.choice(valid_moves)

    bot_state['currentPath'] = None
    return chosen_move, f"Random ({bot_state['stuckCounter']})"

# --- Learning Bot Input Encoding ---
def _get_input_tensor_for_bot(bot_state, senses, config):
    """ Encodes bot's senses and last action into a tensor for the NeuralMemory """
    dim = config['LEARNING_BOT_DIM']
    vis_range = config['VISIBILITY_RANGE']
    num_actions = config['NUM_ACTIONS']

    if dim <= 0: raise ValueError("LEARNING_BOT_DIM must be positive.")

    features = []
    bl = np # Use numpy for feature construction

    def norm_capped(val, cap=vis_range):
        v = float(val) if val is not None else 0.0
        c = float(cap); return 0.0 if c <= 0 else math.copysign(min(abs(v), c), v) / c

    features.append(norm_capped(senses.get('wall_distance_N')))
    features.append(norm_capped(senses.get('wall_distance_S')))
    features.append(norm_capped(senses.get('wall_distance_W')))
    features.append(norm_capped(senses.get('wall_distance_E')))
    features.append(norm_capped(senses.get('nearest_goal_dist')))
    features.append(norm_capped(senses.get('nearest_goal_dx')))
    features.append(norm_capped(senses.get('nearest_goal_dy')))
    features.append(min(1.0, max(0.0, senses.get('num_visible_goals', 0) / 5.0)))
    features.append(norm_capped(senses.get('nearest_opponent_dist')))
    features.append(norm_capped(senses.get('nearest_opponent_dx')))
    features.append(norm_capped(senses.get('nearest_opponent_dy')))
    features.append(float(senses.get('opponent_is_frozen', 0.0)))
    features.append(float(senses.get('opponent_type_HC', 0.0)))
    features.append(float(senses.get('opponent_type_LN', 0.0)))
    features.append(float(senses.get('opponent_type_PL', 0.0)))
    features.append(float(senses.get('self_is_frozen', 0.0)))

    last_action = bot_state.get('lastAction', -1)
    action_enc = bl.zeros(num_actions)
    if 0 <= last_action < num_actions: action_enc[last_action] = 1.0
    features.extend(action_enc.tolist())

    current_len = len(features)
    if current_len < dim: features.extend([0.0] * (dim - current_len))
    elif current_len > dim: print(f"Warning: Feature vector length ({current_len}) > DIM ({dim}). Truncating."); features = features[:dim]

    try:
        np_features = np.array(features, dtype=np.float32)
        input_tensor = torch.from_numpy(np_features).to(device).unsqueeze(0).unsqueeze(0) # Shape [1, 1, dim]
        if input_tensor.shape != (1, 1, dim): raise ValueError(f"Shape mismatch: {input_tensor.shape}")
        return input_tensor
    except Exception as e:
        print(f"Error creating input tensor: {e}"); traceback.print_exc()
        return torch.zeros((1, 1, dim), dtype=torch.float32, device=device)

# --- Learning Bot Action Selection ---
def get_learning_action(bot_state, senses, env, all_bots_dict, direct_player_action, config):
    """ Determines the action for a learning bot, handling AI, player target, and direct player actions """
    bot_id = bot_state['id']
    chosen_action = -1; mode_code = 5; mode_str = "Idle"

    if bot_state['freezeTimer'] > 0:
        bot_state['target_coordinate'] = None; mode_code = 5; mode_str = "Frozen"
        return -1, mode_str, mode_code

    if bot_state.get('is_player_controlled', False):
        control_influence_percent = max(0.0, min(100.0, config['PLAYER_CONTROL_PERCENT']))
        player_action = -1; player_mode_str = "Player Idle"; player_mode_code = 5

        if direct_player_action is not None and 0 <= direct_player_action < config['NUM_ACTIONS']:
            player_action = direct_player_action; player_mode_str = f"Player Direct ({player_action})"; player_mode_code = 3
            bot_state['target_coordinate'] = None
        elif bot_state.get('target_coordinate'):
            target = bot_state['target_coordinate']; current_pos = bot_state['pos']
            dist = env._manhattan_distance(current_pos, target); player_mode_code = 4

            if dist == 0: player_action = -1; player_mode_str = "Player Target Reached"; bot_state['target_coordinate'] = None
            else:
                temp_action = -1
                if dist == 1:
                    opponent_at_target = next((b for bid, b in all_bots_dict.items() if bid != bot_id and b['pos'] == target and b['freezeTimer'] <= 0), None)
                    if opponent_at_target: temp_action = 4; player_mode_str = f"Player Target Punch"
                    else:
                        goal_at_target = next((g for g in env.goals if g['id'] not in env.claimed_goals and g['x'] == target['x'] and g['y'] == target['y']), None)
                        if goal_at_target: temp_action = 5; player_mode_str = f"Player Target Claim"

                if temp_action == -1:
                    path_to_target = env.find_path(current_pos, target, all_bots_dict, bot_id)
                    if path_to_target: temp_action = path_to_target[0]; player_mode_str = f"Player Target Move {temp_action}"
                    else: temp_action = -1; player_mode_str = "Player Target Blocked"
                player_action = temp_action

        if control_influence_percent < 100.0 and player_action != -1:
            ai_action = -1; ai_mode_str = "AI Blend"
            if neural_memory_manager and NEURAL_LIB_AVAILABLE:
                memory_state = bot_state.get('memory_state'); policy_head = bot_state.get('policy_head')
                if memory_state and policy_head:
                    try:
                        input_tensor = _get_input_tensor_for_bot(bot_state, senses, config)
                        retrieved, _, _, _, _ = neural_memory_manager.forward_step(input_tensor, memory_state, detach_next_state=True)
                        policy_head.eval(); policy_head = policy_head.to(device)
                        with torch.no_grad(): action_logits = policy_head(retrieved.to(device).squeeze(0))
                        ai_action = torch.argmax(action_logits, dim=-1).item()
                    except Exception as e: print(f"Error in AI blend pred: {e}"); ai_action = random.choice(list(range(config['NUM_ACTIONS'])))
                else: ai_action = random.choice(list(range(config['NUM_ACTIONS'])))
            else: ai_action = random.choice(list(range(config['NUM_ACTIONS'])))

            if random.uniform(0, 100) < control_influence_percent: chosen_action = player_action; mode_str = player_mode_str; mode_code = player_mode_code
            else: chosen_action = ai_action; mode_str = ai_mode_str; mode_code = 0
        else: chosen_action = player_action; mode_str = player_mode_str; mode_code = player_mode_code

    else: # AI Control Logic
        if not neural_memory_manager or not NEURAL_LIB_AVAILABLE: mode_str = "Error (No NNM)"; mode_code = 5; return -1, mode_str, mode_code
        memory_state = bot_state.get('memory_state'); policy_head = bot_state.get('policy_head')
        if not memory_state or not policy_head: mode_str = "Error (Components)"; mode_code = 5; return -1, mode_str, mode_code

        base_explore_rate_percent = config['LEARNING_BOT_BASE_EXPLORATION_RATE']
        anomaly_factor = min(3.0, 1.0 + bot_state.get('last_anomaly_proxy', 0.0) * 10.0)
        current_exploration_threshold_percent = min(98.0, base_explore_rate_percent * anomaly_factor)
        is_exploring = random.uniform(0, 100) < current_exploration_threshold_percent

        if is_exploring:
            rule_explore_percent_chance = config['LEARNING_BOT_RULE_EXPLORE_PERCENT']
            if random.uniform(0, 100) < rule_explore_percent_chance:
                mode_code = 2; hc_action, hc_mode = get_hardcoded_action(bot_state, senses, env, all_bots_dict)
                chosen_action = hc_action; mode_str = f"Explore Rule ({current_exploration_threshold_percent:.1f}%) -> {hc_mode}"
            else:
                mode_code = 1; chosen_action = random.choice(list(range(config['NUM_ACTIONS'])))
                mode_str = f"Explore Random ({current_exploration_threshold_percent:.1f}%)"
        else: # Exploitation
            mode_code = 0
            try:
                input_tensor = _get_input_tensor_for_bot(bot_state, senses, config)
                retrieved, _, _, _, _ = neural_memory_manager.forward_step(input_tensor, memory_state, detach_next_state=True)
                policy_head.eval(); policy_head = policy_head.to(device)
                retrieved_on_device = retrieved.to(device)
                with torch.no_grad(): action_logits = policy_head(retrieved_on_device.squeeze(0))
                chosen_action = torch.argmax(action_logits, dim=-1).item()
                mode_str = f"Exploit (Predict {chosen_action})"
            except Exception as e:
                print(f"Error: Exploitation failed for AI bot {bot_id}: {e}"); traceback.print_exc()
                mode_str = "Error (Exploitation)"; mode_code = 5
                chosen_action = random.choice(list(range(config['NUM_ACTIONS'])))

    if not isinstance(chosen_action, int) or chosen_action < -1 or chosen_action >= config['NUM_ACTIONS']:
        chosen_action = -1
        if mode_code != 5: mode_str += " -> IdleFallback"

    return chosen_action, mode_str, mode_code


# ================================================================
# --- Simulation Setup & Control ---
# ================================================================

def create_learning_bot_instance(bot_id, start_pos, config):
    """ Creates the state dictionary for a new learning bot using the manager """
    global neural_memory_manager
    if not neural_memory_manager or not NEURAL_LIB_AVAILABLE:
         raise RuntimeError(f"NN Manager not ready. Cannot create learning bot {bot_id}.")

    nnm_dim = neural_memory_manager.dim
    print(f"Creating Learning Bot {bot_id} (DIM={nnm_dim}) on {device}")
    initial_mem_state = neural_memory_manager.get_initial_state()

    try:
        policy_head = nn.Linear(nnm_dim, config['NUM_ACTIONS']).to(device)
        nn.init.xavier_uniform_(policy_head.weight)
        if policy_head.bias is not None: nn.init.zeros_(policy_head.bias)
    except Exception as e:
        print(f"FATAL ERROR: Failed to create policy head for {bot_id} on {device}: {e}")
        traceback.print_exc(); raise

    return {
        'id': bot_id, 'type': 'Learning', 'pos': start_pos.copy(),
        'steps': 0, 'goalsReachedThisRound': 0, 'goalsReachedTotal': 0,
        'freezeTimer': 0, 'lastAction': -1, 'mode': 'Init', 'senses': {},
        'memory_state': initial_mem_state, # NeuralMemState tuple
        'policy_head': policy_head,        # nn.Module instance
        'last_anomaly_proxy': 0.0,         # EMA of anomaly score
        'is_player_controlled': False, 'target_coordinate': None,
        'original_bot_id': bot_id,
        'lastPos': {'x':-1,'y':-1}, 'stuckCounter': 0, 'lastMoveAttempt': -1,
        'currentPath': None, 'targetGoalId': None, 'randomMoveCounter': 0,
        'last_av_data': None
    }

def create_hardcoded_bot_instance(bot_id, start_pos):
     """ Creates the state dictionary for a new hardcoded bot """
     return {
         'id': bot_id, 'type': 'Hardcoded', 'pos': start_pos.copy(),
         'steps': 0, 'goalsReachedThisRound': 0, 'goalsReachedTotal': 0,
         'freezeTimer': 0, 'lastAction': -1, 'mode': 'Init', 'senses': {},
         'lastPos': {'x':-1,'y':-1}, 'stuckCounter': 0, 'lastMoveAttempt': -1,
         'currentPath': None, 'targetGoalId': None, 'randomMoveCounter': 0
     }

def setup_simulation(full_reset=False, new_environment=False):
    """ Sets up or resets the simulation environment and bots. """
    global environment, bots, round_number, stats, current_config, players, player_direct_actions, av_manager
    print(f"--- Setting up Simulation (Full Reset: {full_reset}, New Env: {new_environment}) ---")

    # Stop AV system *before* potentially changing bot counts or NNM
    if av_manager:
        print("Stopping existing AV system before setup...")
        stop_av_system(av_manager)
        av_manager = None

    if full_reset:
        print("Performing full reset...")
        round_number = 0; stats = {'hc_total_goals': 0, 'learning_total_goals': 0}
        nnm_recreated_or_moved = update_neural_memory_manager_instance()
        if not neural_memory_manager:
            print("CRITICAL: NN Manager update failed during full reset. Aborting setup.")
            return False
        print("Clearing existing bot states..."); bots.clear(); players.clear(); player_direct_actions.clear()
        environment = None; new_environment = True
        if device.type == 'cuda': torch.cuda.empty_cache()
    else: # Round reset
        round_number += 1
        if environment:
             env_structure_keys = ['GRID_SIZE', 'NUM_HC_BOTS', 'NUM_LEARNING_BOTS', 'NUM_GOALS']
             env_changed_structurally = any(
                 current_config[k] != getattr(environment, k.lower().replace('num_','num_'), None)
                 for k in env_structure_keys if hasattr(environment, k.lower().replace('num_','num_'))
             )
             if env_changed_structurally:
                  print("Environment structure change detected, forcing full reset logic...")
                  full_reset = True; new_environment = True; environment = None
             elif new_environment or current_config.get("RANDOMIZE_ENV_PER_ROUND", False):
                  print("Randomizing environment for new round..."); environment.randomize()
             else: environment.reset_round_state()
        else: print("No environment found, forcing full reset..."); full_reset = True; new_environment = True
        player_direct_actions.clear()

    # --- Recreate Environment if needed ---
    if environment is None:
         print("Recreating environment...")
         try:
             obstacle_range = (current_config['OBSTACLES_FACTOR_MIN'], current_config['OBSTACLES_FACTOR_MAX'])
             dist_factors = {k: current_config.get(k) for k in ['MIN_GOAL_START_DISTANCE_FACTOR', 'MIN_BOT_START_DISTANCE_FACTOR', 'MIN_BOT_GOAL_DISTANCE_FACTOR']}
             environment = GridEnvironment(current_config['GRID_SIZE'], current_config['NUM_GOALS'], obstacle_range, current_config['NUM_HC_BOTS'], current_config['NUM_LEARNING_BOTS'], dist_factors)
             if environment.num_hc_bots != current_config['NUM_HC_BOTS'] or environment.num_learning_bots != current_config['NUM_LEARNING_BOTS']:
                 print(f"Environment adjusted bot counts: HC={environment.num_hc_bots}, Lrn={environment.num_learning_bots}. Updating config.")
                 current_config['NUM_HC_BOTS'] = environment.num_hc_bots
                 current_config['NUM_LEARNING_BOTS'] = environment.num_learning_bots
             full_reset = True # Treat as full reset for bot handling
         except Exception as e: print(f"FATAL: Environment creation failed: {e}"); traceback.print_exc(); return False

    # --- Create/Reset Bot States ---
    new_bots = {}
    bot_starts = environment.start_positions if environment else []
    required_bots = environment.num_hc_bots + environment.num_learning_bots
    if len(bot_starts) != required_bots:
         print(f"FATAL MISMATCH: Env start positions ({len(bot_starts)}) != env bot counts ({required_bots}). Setup failed.")
         return False

    try:
        for start_pos_data in bot_starts:
            bot_id = start_pos_data['id']; bot_type = start_pos_data['type']
            start_pos = {'x': start_pos_data['x'], 'y': start_pos_data['y']}
            controlling_sid = next((sid for sid, p_data in players.items() if p_data['original_bot_id'] == bot_id), None)

            if bot_id in bots and not full_reset: # Reset existing bot
                existing_bot = bots[bot_id]
                existing_bot.update({
                    'pos': start_pos.copy(), 'steps': 0, 'goalsReachedThisRound': 0,
                    'freezeTimer': 0, 'lastAction': -1, 'mode': 'Reset', 'senses': {},
                    'lastPos': {'x':-1,'y':-1}, 'stuckCounter': 0, 'lastMoveAttempt': -1,
                    'currentPath': None, 'targetGoalId': None, 'randomMoveCounter': 0,
                    'last_av_data': None
                })
                if bot_type == 'Learning':
                     existing_bot['last_anomaly_proxy'] = 0.0
                     existing_bot['target_coordinate'] = None
                     if neural_memory_manager: existing_bot['memory_state'] = neural_memory_manager.get_initial_state()
                     else: print(f"Warning: NNM missing during reset for {bot_id}")
                     existing_bot['is_player_controlled'] = bool(controlling_sid)
                new_bots[bot_id] = existing_bot
            else: # Create new bot instance
                if bot_type == 'Hardcoded': new_bots[bot_id] = create_hardcoded_bot_instance(bot_id, start_pos)
                elif bot_type == 'Learning':
                    if neural_memory_manager:
                         new_bots[bot_id] = create_learning_bot_instance(bot_id, start_pos, current_config)
                         if controlling_sid: new_bots[bot_id]['is_player_controlled'] = True; players[controlling_sid]['player_bot_id'] = bot_id
                    else: print(f"Warning: Cannot create new learning bot {bot_id}, NNM not ready.")

        bots = new_bots
        # Cleanup players whose original bots no longer exist
        for sid, player_data in list(players.items()):
            if player_data['original_bot_id'] not in bots:
                print(f"Removing player SID {sid} as their original bot {player_data['original_bot_id']} no longer exists.")
                del players[sid]

    except Exception as e: print(f"Error: Bot creation/reset failed: {e}"); traceback.print_exc(); return False

    # --- Setup AV system *after* bots are created/reset ---
    num_learning_bots_actual = sum(1 for b in bots.values() if b['type'] == 'Learning')
    if current_config.get("ENABLE_AV", False) and AV_LIB_AVAILABLE:
        print("Setting up AV system...")
        av_dim = current_config.get('LEARNING_BOT_DIM', 0)
        vis_mode = current_config.get("VISUALIZATION_MODE", "none")
        enable_output = current_config.get("ENABLE_AV_OUTPUT", False)
        sio_instance = socketio if vis_mode == 'web' else None

        av_manager = setup_av_system(
            num_bots=num_learning_bots_actual,
            dim=av_dim,
            device=device,
            enable_output=enable_output,
            visualization_mode=vis_mode,
            socketio_instance=sio_instance
        )
        if not av_manager:
            print("Warning: AV setup failed but simulation continues.")
        elif not av_manager.is_setup and enable_output:
             print(f"Warning: AV Manager created but failed to setup output (Mode: {vis_mode}). Check library installs/permissions.")
        elif av_manager.is_setup:
             print(f"AV Manager setup successful (Mode: {vis_mode}, Audio: {av_manager.enable_audio_output}).")

    print(f"Setup complete for Round {round_number}. Active Bots: {list(bots.keys())}")
    socketio.emit('config_update', current_config) # Send potentially updated config
    return True

# --- Simulation Step ---
def simulation_step():
    """ Performs one step of the simulation for all active bots """
    global player_direct_actions, av_manager
    if not environment or not bots: return False

    round_over = False
    max_steps_reached_for_all = True
    bot_ids_this_step = list(bots.keys())
    current_direct_actions = player_direct_actions.copy()
    player_direct_actions.clear()
    live_av_data = {} # Collect data for AV system {av_idx: {data}}

    learning_bot_ids = sorted([bid for bid, b in bots.items() if b['type'] == 'Learning'])
    bot_id_to_av_idx = {bot_id: idx for idx, bot_id in enumerate(learning_bot_ids)}

    # --- Bot Action Phase ---
    for bot_id in bot_ids_this_step:
        if bot_id not in bots: continue
        bot_state = bots[bot_id]

        if bot_state['steps'] >= current_config['MAX_STEPS_PER_ROUND']: continue
        else: max_steps_reached_for_all = False

        action_attempted = -1; mode_str = "Idle"; mode_code = 5
        next_pos = bot_state['pos'].copy()

        try:
            bot_state['senses'] = environment.get_sensory_data(bot_state, bots, current_config['VISIBILITY_RANGE'])

            if bot_state['freezeTimer'] > 0: action_attempted = -1; mode_str = "Frozen"; mode_code = 5
            elif bot_state['type'] == 'Hardcoded': action_attempted, mode_str = get_hardcoded_action(bot_state, bot_state['senses'], environment, bots); mode_code = 2
            elif bot_state['type'] == 'Learning':
                direct_action = None
                if bot_state.get('is_player_controlled', False):
                    controlling_sid = next((sid for sid, p_data in players.items() if p_data['player_bot_id'] == bot_id), None)
                    if controlling_sid and controlling_sid in current_direct_actions: direct_action = current_direct_actions[controlling_sid]
                action_attempted, mode_str, mode_code = get_learning_action(bot_state, bot_state['senses'], environment, bots, direct_action, current_config)

            bot_state['mode'] = mode_str

            # --- Execute Action ---
            if action_attempted != -1 and bot_state['freezeTimer'] <= 0:
                if 0 <= action_attempted <= 3: # Move
                    intended_pos = environment.perform_move_action(bot_state['pos'], action_attempted)
                    occupied = any(bid != bot_id and b['pos'] == intended_pos for bid, b in bots.items())
                    if environment.is_valid(intended_pos) and not occupied: next_pos = intended_pos
                    else: bot_state['mode'] += " (Blocked)"
                elif action_attempted == 4: # Punch
                    target_bot = next((ob for ob_id, ob in bots.items() if ob_id != bot_id and environment._manhattan_distance(bot_state['pos'], ob['pos']) == 1 and ob['freezeTimer'] <= 0), None)
                    if target_bot: target_bot['freezeTimer'] = current_config['FREEZE_DURATION']; bot_state['mode'] += f" (Hit {target_bot['id']})"
                    else: bot_state['mode'] += " (Punch Miss)"
                elif action_attempted == 5: # Claim
                    adj_goal = environment.get_adjacent_unclaimed_goal(bot_state['pos'])
                    if adj_goal and environment.claim_goal(adj_goal['id'], bot_id):
                         bot_state['goalsReachedThisRound'] += 1; bot_state['goalsReachedTotal'] += 1
                         if bot_state['type'] == 'Hardcoded': stats['hc_total_goals'] += 1
                         else: stats['learning_total_goals'] += 1
                         bot_state['mode'] += f" (Claimed {adj_goal['id']})"
                         if environment.are_all_goals_claimed(): round_over = True; print(f"--- Round {round_number} Over: All goals claimed! ---")
                    else: bot_state['mode'] += " (Claim Failed)"

            bot_state['pos'] = next_pos
            bot_state['steps'] += 1
            if bot_state['freezeTimer'] > 0: bot_state['freezeTimer'] -= 1

            # --- Update Neural Memory & Collect AV Data (Learning Bots Only) ---
            if bot_state['type'] == 'Learning' and neural_memory_manager:
                try:
                    bot_state_for_update = bot_state.copy(); bot_state_for_update['lastAction'] = action_attempted
                    input_tensor = _get_input_tensor_for_bot(bot_state_for_update, bot_state['senses'], current_config)
                    input_tensor_on_device = input_tensor.to(neural_memory_manager.target_device)

                    retrieved, next_mem_state, anomaly, weight_diff, _ = neural_memory_manager.forward_step(
                        input_tensor_on_device, bot_state['memory_state'], detach_next_state=True
                    )
                    bot_state['memory_state'] = next_mem_state
                    current_anomaly_val = anomaly.item()
                    bot_state['last_anomaly_proxy'] = current_anomaly_val * 0.1 + bot_state.get('last_anomaly_proxy', 0.0) * 0.9

                    # Store data needed for AV (references to GPU tensors if using CUDA)
                    av_idx = bot_id_to_av_idx.get(bot_id)
                    # Check if AV is enabled AND manager exists AND has output enabled
                    if current_config.get("ENABLE_AV", False) and av_manager and av_idx is not None and \
                       (av_manager.enable_audio_output or av_manager.enable_visual_output):
                        av_data_packet = {
                            'anomaly_score': anomaly, # Tensor
                            'retrieved_memory_vector': retrieved, # Tensor [1,1,dim]
                            'weight_change_metric': weight_diff, # Tensor
                            'input_stream_vector': input_tensor_on_device, # Tensor [1,1,dim]
                            'mode_code': mode_code, # int
                            'is_player_controlled': bot_state.get('is_player_controlled', False) # bool
                        }
                        live_av_data[av_idx] = av_data_packet

                except Exception as e:
                    print(f"Error: NNM update failed for bot {bot_id} (Action: {action_attempted}): {e}"); traceback.print_exc()

            bot_state['lastAction'] = action_attempted

        except Exception as e:
            print(f"CRITICAL Error processing bot {bot_id}: {e}"); traceback.print_exc()
            global simulation_running; simulation_running = False
            socketio.emit('simulation_stopped', {'message': f'Error processing bot {bot_id}.'})
            return False # Stop simulation

    # --- Update AV System (After processing all bots) ---
    if current_config.get("ENABLE_AV", False) and av_manager and live_av_data:
        update_av_system(av_manager, live_av_data) # Pass dict {av_idx: data_packet}

    # Check for round end conditions
    if not round_over and max_steps_reached_for_all:
        round_over = True; print(f"--- Round {round_number} Over: Max steps reached! ---")

    return not round_over # True to continue round, False to end


# --- Simulation Loop ---
def simulation_loop():
    """ Main simulation loop managed by eventlet background task. """
    global simulation_running, round_number, simulation_loop_task
    print("Simulation loop started.")
    loop_count = 0
    emit_interval_steps = 2
    last_emit_time = time.monotonic()
    min_emit_interval_time = 0.04 # ~25 FPS target

    while simulation_running:
        loop_start_time = time.monotonic()
        try:
            continue_round = simulation_step()

            if not simulation_running: break

            if not continue_round: # Round ended
                 new_env_next = current_config.get("RANDOMIZE_ENV_PER_ROUND", False)
                 if setup_simulation(full_reset=False, new_environment=new_env_next):
                     loop_count = 0; last_emit_time = time.monotonic()
                     emit_state(); print(f"Starting Round {round_number}...")
                 else:
                     print("Error: Failed next round setup. Stopping."); simulation_running = False
                     socketio.emit('simulation_stopped', {'message': 'Error setting up next round.'}); break
            else: # Round continues
                 loop_count += 1; current_time = time.monotonic()
                 if loop_count % emit_interval_steps == 0 or (current_time - last_emit_time) > min_emit_interval_time:
                      emit_state(); last_emit_time = current_time

            elapsed_time = time.monotonic() - loop_start_time
            target_delay = current_config['SIMULATION_SPEED_MS'] / 1000.0
            delay = max(0.001, target_delay - elapsed_time)
            eventlet.sleep(delay) # Non-blocking sleep

        except Exception as e:
            print(f"CRITICAL Error in simulation loop: {e}"); traceback.print_exc()
            simulation_running = False
            socketio.emit('simulation_stopped', {'message': f'Runtime Error: {e}'}); break

    print("Simulation loop finished.")
    emit_state() # Emit final state
    simulation_loop_task = None


# ================================================================
# --- Flask Routes & SocketIO Events ---
# ================================================================
@app.route('/')
def index():
    try: return render_template('index.html')
    except Exception as e: print(f"Error rendering template: {e}"); traceback.print_exc(); return "Error loading page.", 500

# --- Add Route for Web Visualizer (Example) ---
@app.route('/visuals')
def visuals_page():
    # This would render an HTML page containing the web visualization client (e.g., using Plotly.js or Three.js)
    # For now, just return a placeholder
    return """
    <!DOCTYPE html><html><head><title>Web Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <style>body { font-family: sans-serif; background-color: #222; color: #eee; } #data { white-space: pre-wrap; font-family: monospace; }</style>
    </head><body><h1>Web Visualizer Placeholder</h1>
    <p>Connects to SocketIO namespace '/visuals'. Data will appear below.</p>
    <div id="status">Connecting...</div><div id="data"></div>
    <script>
        const statusEl = document.getElementById('status');
        const dataEl = document.getElementById('data');
        const socket = io('/visuals'); // Connect to the specific namespace
        socket.on('connect', () => { statusEl.textContent = 'Connected to /visuals'; });
        socket.on('disconnect', () => { statusEl.textContent = 'Disconnected from /visuals'; });
        socket.on('visual_update', (data) => {
            // In a real implementation, use this data to update Plotly/Three.js/etc.
            dataEl.textContent = JSON.stringify(data, null, 2);
        });
    </script></body></html>
    """

# --- SocketIO Namespace for Web Visualizer ---
class VisualsNamespace(Namespace):
    def on_connect(self):
        print(f"Web Visualizer client connected: {request.sid}")
        # Optionally send initial setup data if needed
        # emit('initial_visual_config', {'num_bots': current_config.get('NUM_LEARNING_BOTS', 0)})

    def on_disconnect(self):
        print(f"Web Visualizer client disconnected: {request.sid}")

# Register the namespace
socketio.on_namespace(VisualsNamespace('/visuals'))


# --- Main SocketIO Events ---
@socketio.on('connect')
def handle_connect():
    sid = request.sid; print(f"Client connected: {sid}")
    try:
        if environment is None or not bots:
             print("First connection or missing state, ensuring initial setup...")
             if not setup_simulation(full_reset=True, new_environment=True):
                  emit('status_update', {'message': 'Error: Server setup failed.'}, room=sid); return
        state = get_game_state()
        state['isRunning'] = simulation_running
        emit('initial_state', state, room=sid)
        print(f"Initial state sent to {sid} (Running: {simulation_running})")
    except Exception as e: print(f"Error sending initial data to {sid}: {e}"); traceback.print_exc()

@socketio.on('disconnect')
def handle_disconnect():
    sid = request.sid; print(f"Client disconnected: {sid}")
    if sid in players:
        player_data = players.pop(sid)
        original_bot_id = player_data['original_bot_id']
        print(f"Player {sid} released control of bot {original_bot_id}")
        if original_bot_id in bots:
            bots[original_bot_id]['is_player_controlled'] = False
            bots[original_bot_id]['target_coordinate'] = None
            bots[original_bot_id]['mode'] = "AI Control"
            socketio.emit('player_left', {'player_id': original_bot_id})
            emit_state()
    if sid in player_direct_actions: del player_direct_actions[sid]

# --- get_game_state helper ---
def get_game_state():
    """ Creates a JSON-serializable representation of the game state """
    serializable_bots = {}
    for bot_id, bot_state in bots.items():
        s_bot = {
            'id': bot_state['id'], 'type': bot_state['type'], 'pos': bot_state['pos'],
            'freezeTimer': bot_state['freezeTimer'], 'mode': bot_state['mode'],
            'goals_round': bot_state.get('goalsReachedThisRound', 0),
            'is_player': bot_state.get('is_player_controlled', False),
            'target_coord': bot_state.get('target_coordinate')
        }
        if bot_state['type'] == 'Learning':
            s_bot['anomaly'] = round(bot_state.get('last_anomaly_proxy', 0.0), 5)
        serializable_bots[bot_id] = s_bot

    return {
        'environment': environment.get_state() if environment else None,
        'bots': serializable_bots, 'round': round_number, 'stats': stats,
        'config': current_config # Send full config
    }

# --- emit_state helper ---
def emit_state():
    """ Safely gets and emits the current game state """
    try:
        state = get_game_state()
        state['isRunning'] = simulation_running
        socketio.emit('update_state', state)
    except Exception as e:
        print(f"Error emitting state: {e}"); traceback.print_exc()


# --- Player/Control SocketIO handlers (No changes needed from previous version) ---
@socketio.on('join_game')
def handle_join_game(data=None):
    sid = request.sid
    if sid in players: emit('join_ack', {'success': False, 'message': 'Already controlling a bot.'}, room=sid); return
    if not environment or not bots: emit('join_ack', {'success': False, 'message': 'Simulation not ready.'}, room=sid); return

    target_bot_id = data.get('target_bot_id') if data else None
    available_bot_id = None

    if target_bot_id:
         if target_bot_id in bots and bots[target_bot_id]['type'] == 'Learning' and not bots[target_bot_id].get('is_player_controlled', False):
             available_bot_id = target_bot_id
         else:
             message = f"Bot {target_bot_id} is not available or not a learning bot."
             emit('join_ack', {'success': False, 'message': message}, room=sid); return
    else:
         available_bot_id = next((bid for bid, b in bots.items() if b['type'] == 'Learning' and not b.get('is_player_controlled', False)), None)

    if available_bot_id:
        original_id = bots[available_bot_id]['original_bot_id']
        print(f"Player {sid} taking control of Learning Bot {available_bot_id} (Original: {original_id})")
        bots[available_bot_id]['is_player_controlled'] = True
        bots[available_bot_id]['target_coordinate'] = None
        bots[available_bot_id]['mode'] = "Player Control"
        players[sid] = {'player_bot_id': available_bot_id, 'original_bot_id': original_id}
        emit('join_ack', {'success': True, 'player_id': available_bot_id, 'original_bot_id': original_id}, room=sid)
        socketio.emit('player_joined', {'player_id': available_bot_id})
        emit_state()
    else:
        message = "No available Learning Bots to control."
        emit('join_ack', {'success': False, 'message': message}, room=sid)
        print(f"Player {sid} failed to join: {message}")

@socketio.on('rejoin_game')
def handle_rejoin_game(data):
    sid = request.sid
    if sid in players: emit('rejoin_ack', {'success': False, 'message': 'Already controlling.'}, room=sid); return
    original_bot_id = data.get('originalBotId')
    if not original_bot_id: emit('rejoin_ack', {'success': False, 'message': 'No original bot ID provided.'}, room=sid); return

    print(f"Player {sid} attempting rejoin for original bot: {original_bot_id}")
    if original_bot_id in bots and bots[original_bot_id]['type'] == 'Learning':
        already_controlled = any(other_sid != sid and p_data['original_bot_id'] == original_bot_id for other_sid, p_data in players.items())
        if not already_controlled:
            bots[original_bot_id]['is_player_controlled'] = True
            bots[original_bot_id]['target_coordinate'] = None
            bots[original_bot_id]['mode'] = "Player Control (Rejoin)"
            players[sid] = {'player_bot_id': original_bot_id, 'original_bot_id': original_bot_id}
            emit('rejoin_ack', {'success': True, 'player_id': original_bot_id, 'original_bot_id': original_bot_id}, room=sid)
            socketio.emit('player_joined', {'player_id': original_bot_id})
            emit_state()
            print(f"Player {sid} rejoined control of {original_bot_id}")
        else:
            emit('rejoin_ack', {'success': False, 'message': f'Bot {original_bot_id} already controlled by another player.'}, room=sid)
    else:
        emit('rejoin_ack', {'success': False, 'message': f'Original bot {original_bot_id} not available or not a learning bot.'}, room=sid)

@socketio.on('leave_game')
def handle_leave_game(data=None):
    sid = request.sid
    if sid in players:
        player_data = players.pop(sid)
        original_bot_id = player_data['original_bot_id']
        print(f"Player {sid} leaving control of bot {original_bot_id}")
        if original_bot_id in bots:
            bots[original_bot_id]['is_player_controlled'] = False
            bots[original_bot_id]['target_coordinate'] = None
            bots[original_bot_id]['mode'] = "AI Control"
            socketio.emit('player_left', {'player_id': original_bot_id})
            emit_state()
        emit('leave_ack', {'success': True}, room=sid)
        if sid in player_direct_actions: del player_direct_actions[sid]
    else: emit('leave_ack', {'success': False, 'message': 'Not controlling a bot.'}, room=sid)

@socketio.on('player_action')
def handle_player_action(data):
    sid = request.sid
    if sid in players:
        player_bot_id = players[sid]['player_bot_id']
        if player_bot_id in bots and bots[player_bot_id].get('is_player_controlled', False):
            action = data.get('action')
            try:
                action_int = int(action)
                if 0 <= action_int < current_config['NUM_ACTIONS']:
                    player_direct_actions[sid] = action_int
                else: print(f"Warning: Invalid action value {action} from {sid}")
            except (ValueError, TypeError): print(f"Warning: Non-integer action '{action}' from {sid}")

@socketio.on('update_player_target')
def handle_update_player_target(data):
    sid = request.sid
    if sid in players:
        player_bot_id = players[sid]['player_bot_id']
        if player_bot_id in bots and bots[player_bot_id].get('is_player_controlled', False):
            target = data.get('target')
            if target is None: bots[player_bot_id]['target_coordinate'] = None
            elif isinstance(target, dict) and 'x' in target and 'y' in target:
                try:
                    tx, ty = int(target['x']), int(target['y'])
                    grid_size = environment.size if environment else current_config['GRID_SIZE']
                    if 0 <= tx < grid_size and 0 <= ty < grid_size: bots[player_bot_id]['target_coordinate'] = {'x': tx, 'y': ty}
                    else: bots[player_bot_id]['target_coordinate'] = None
                except (ValueError, TypeError): bots[player_bot_id]['target_coordinate'] = None
            else: bots[player_bot_id]['target_coordinate'] = None

@socketio.on('start_simulation')
def handle_start_simulation(data=None):
    global simulation_running, simulation_loop_task
    if simulation_running: emit('status_update', {'message': 'Simulation already running.'}, room=request.sid); return
    print("Start simulation request received.")
    if environment is None or not bots:
         print("Initial setup required before starting.")
         if not setup_simulation(full_reset=False, new_environment=True):
              socketio.emit('simulation_stopped', {'message': 'Initialization failed on start.'}); return
    simulation_running = True
    if simulation_loop_task is None or (hasattr(simulation_loop_task, 'dead') and simulation_loop_task.dead):
         print("Starting background simulation loop task.")
         simulation_loop_task = socketio.start_background_task(simulation_loop)
    socketio.emit('simulation_started'); emit_state()

@socketio.on('stop_simulation')
def handle_stop_simulation(data=None):
    global simulation_running
    if not simulation_running: emit('status_update', {'message': 'Simulation already stopped.'}, room=request.sid); return
    print("Stop simulation request received.")
    simulation_running = False
    socketio.emit('simulation_stopped', {'message': 'Simulation stopped.'})

@socketio.on('reset_round')
def handle_reset_round(data=None):
    global simulation_running
    was_running = simulation_running; print("Reset round request received.")
    if simulation_running: handle_stop_simulation(); eventlet.sleep(0.1)
    new_env = current_config.get("RANDOMIZE_ENV_PER_ROUND", False)
    if setup_simulation(full_reset=False, new_environment=new_env):
        emit_state(); status_msg = 'New Round Ready.' + (' Press Start to run.' if not was_running else '')
        socketio.emit('status_update', {'message': status_msg})
    else: socketio.emit('status_update', {'message': 'Error resetting round.'})
    socketio.emit('simulation_stopped', {'message': 'New Round Ready.'})

@socketio.on('reset_full')
def handle_reset_full(data=None):
    global simulation_running
    was_running = simulation_running; print("Full reset request received.")
    if simulation_running: handle_stop_simulation(); eventlet.sleep(0.1)
    if setup_simulation(full_reset=True, new_environment=True):
        emit_state(); status_msg = 'Full Reset Complete.' + (' Press Start to run.' if not was_running else '')
        socketio.emit('status_update', {'message': status_msg})
    else: socketio.emit('status_update', {'message': 'Error during full reset.'})
    socketio.emit('simulation_stopped', {'message': 'Full Reset Complete.'})


@socketio.on('update_config')
def handle_update_config(data):
    global current_config, av_manager
    if simulation_running: emit('config_update_ack', {'success': False, 'message': 'Stop simulation before changing parameters.'}, room=request.sid); return

    try:
        new_config_data = data.get('config', {})
        needs_full_reset = False; needs_round_reset = False
        changed_keys = []; temp_config = copy.deepcopy(current_config)
        print("Received config update request:", new_config_data)

        # Define which keys trigger which reset type (Added VISUALIZATION_MODE)
        reset_all_keys = ['GRID_SIZE', 'NUM_HC_BOTS', 'NUM_LEARNING_BOTS', 'NUM_GOALS', 'LEARNING_BOT_DIM', 'LEARNING_BOT_MEM_DEPTH', 'LEARNING_BOT_LR', 'LEARNING_BOT_WEIGHT_DECAY', 'LEARNING_BOT_MOMENTUM', 'LEARNING_BOT_MAX_GRAD_NORM', 'ENABLE_AV', 'ENABLE_AV_OUTPUT', 'VISUALIZATION_MODE']
        reset_round_keys = ['MAX_STEPS_PER_ROUND', 'VISIBILITY_RANGE', 'OBSTACLES_FACTOR_MIN', 'OBSTACLES_FACTOR_MAX', 'MIN_GOAL_START_DISTANCE_FACTOR', 'MIN_BOT_START_DISTANCE_FACTOR', 'MIN_BOT_GOAL_DISTANCE_FACTOR']
        immediate_update_keys = ['SIMULATION_SPEED_MS', 'FREEZE_DURATION', 'LEARNING_BOT_BASE_EXPLORATION_RATE', 'LEARNING_BOT_RULE_EXPLORE_PERCENT', 'PLAYER_CONTROL_PERCENT', 'RANDOMIZE_ENV_PER_ROUND']

        for key, value in new_config_data.items():
            if key in DEFAULT_CONFIG:
                try:
                    default_type = type(DEFAULT_CONFIG[key]); current_value = temp_config.get(key)
                    if value is None: continue
                    # Type Conversion and Validation
                    if default_type is bool: converted_value = str(value).lower() in ['true', '1', 'yes', 'on']
                    elif default_type is int: converted_value = int(round(float(value)))
                    elif default_type is float: converted_value = float(value)
                    else: converted_value = default_type(value) # String or other (like VISUALIZATION_MODE)

                    # Apply constraints (Add VISUALIZATION_MODE validation)
                    if key == "VISUALIZATION_MODE" and converted_value not in ['vispy', 'matplotlib', 'web', 'none']:
                        print(f"Warning: Invalid VISUALIZATION_MODE '{converted_value}'. Using 'none'.")
                        converted_value = 'none'
                    # ... (keep other constraints) ...
                    if key == "GRID_SIZE": converted_value = max(10, min(200, converted_value))
                    if key == "NUM_HC_BOTS": converted_value = max(0, min(100, converted_value))
                    if key == "NUM_LEARNING_BOTS": converted_value = max(0, min(100, converted_value))
                    if key == "NUM_GOALS": converted_value = max(0, min(500, converted_value))
                    if key == "LEARNING_BOT_DIM": converted_value = max(32, min(4096, (converted_value // 16) * 16 if converted_value > 32 else 32))
                    if key == "LEARNING_BOT_MEM_DEPTH": converted_value = max(1, min(12, converted_value))
                    if key == "SIMULATION_SPEED_MS": converted_value = max(1, min(2000, converted_value))
                    if key == "PLAYER_CONTROL_PERCENT": converted_value = max(0.0, min(100.0, converted_value))
                    if key == "LEARNING_BOT_BASE_EXPLORATION_RATE": converted_value = max(0.0, min(100.0, converted_value))
                    if key == "LEARNING_BOT_RULE_EXPLORE_PERCENT": converted_value = max(0.0, min(100.0, converted_value))


                    is_different = abs(converted_value - current_value) > 1e-9 if isinstance(converted_value, float) else current_value != converted_value
                    if is_different:
                        print(f"Applying config change: {key}: {current_value} -> {converted_value}")
                        temp_config[key] = converted_value; changed_keys.append(key)
                        if key in reset_all_keys: needs_full_reset = True
                        elif key in reset_round_keys: needs_round_reset = True
                except (ValueError, TypeError) as e: print(f"Warning: Invalid type/value for '{key}': '{value}'. Skipping. Err: {e}"); continue

        if changed_keys:
             current_config = temp_config; print(f"Config updated. Changed: {changed_keys}")
             if needs_full_reset: needs_round_reset = True

             # Update NN manager if relevant params changed
             nn_params = ['LEARNING_BOT_DIM', 'LEARNING_BOT_MEM_DEPTH', 'LEARNING_BOT_LR', 'LEARNING_BOT_WEIGHT_DECAY', 'LEARNING_BOT_MOMENTUM', 'LEARNING_BOT_MAX_GRAD_NORM']
             if any(k in nn_params for k in changed_keys):
                 nnm_recreated = update_neural_memory_manager_instance()
                 if not neural_memory_manager: emit('config_update_ack', {'success': False, 'message': 'Error: Failed NN manager update.'}, room=request.sid); return
                 if nnm_recreated: needs_full_reset = True; needs_round_reset = True

             # Update AV manager based on relevant params
             av_params = ['ENABLE_AV', 'ENABLE_AV_OUTPUT', 'VISUALIZATION_MODE', 'NUM_LEARNING_BOTS', 'LEARNING_BOT_DIM']
             if any(k in av_params for k in changed_keys):
                  av_state_changed = update_av_manager_instance()
                  # If AV state changed (created/stopped/recreated), force full reset
                  if av_state_changed: needs_full_reset = True; needs_round_reset = True

             emit('config_update_ack', {'success': True, 'needs_full_reset': needs_full_reset, 'needs_round_reset': needs_round_reset, 'updated_config': current_config}, room=request.sid)
             socketio.emit('config_update', current_config) # Broadcast new config
        else:
             print("No effective config changes detected.")
             emit('config_update_ack', {'success': True, 'needs_full_reset': False, 'needs_round_reset': False, 'updated_config': current_config}, room=request.sid)

    except Exception as e: print(f"Error updating config: {e}"); traceback.print_exc(); emit('config_update_ack', {'success': False, 'message': f'Server error: {e}'}, room=request.sid)


# ================================================================
# --- Server Start ---
# ================================================================
if __name__ == '__main__':
    # IMPORTANT: Set start method for multiprocessing BEFORE any other mp usage
    # Especially important on MacOS and Windows for GUI/CUDA compatibility
    # 'spawn' is generally safest but might be slower. 'forkserver' is another option.
    # Default 'fork' on Linux/Mac can cause issues with CUDA and some GUI libs.
    if sys.platform == "darwin" or sys.platform == "win32":
        print(f"Platform is {sys.platform}, setting multiprocessing start method to 'spawn'.")
        mp.set_start_method('spawn', force=True)
    elif mp.get_start_method(allow_none=True) is None or mp.get_start_method(allow_none=True) == 'fork':
         # Keep fork on Linux unless CUDA issues arise, then switch to spawn/forkserver
         print("Using default 'fork' multiprocessing start method (Linux).")
         # Consider adding a check/warning if CUDA is used with 'fork'

    print("Initializing simulation state...")
    if not NEURAL_LIB_AVAILABLE: print("CRITICAL: Neural Memory Library failed to load. Cannot start."); sys.exit(1)
    if not update_neural_memory_manager_instance(): print("CRITICAL: Neural Memory Manager failed to initialize. Check PyTorch/CUDA setup. Exiting."); sys.exit(1)

    # Initial AV setup is handled within setup_simulation based on config

    if not setup_simulation(full_reset=True, new_environment=True):
        print("CRITICAL: Initial simulation setup failed. Check environment parameters. Exiting.")
        if av_manager: stop_av_system(av_manager)
        sys.exit(1)
    else: print("Initial setup successful.")

    port = int(os.environ.get('PORT', 5001)); host = '0.0.0.0'
    print(f"Attempting to start server on http://{host}:{port}")
    print(f"Web visualizer placeholder available at http://{host}:{port}/visuals")
    try:
        print("Starting Flask-SocketIO server with eventlet...")
        # socketio.run(app, host=host, port=port, debug=False, use_reloader=False)
        # Use eventlet.wsgi.server directly for potentially better control/compatibility
        import eventlet.wsgi
        eventlet.wsgi.server(eventlet.listen((host, port)), app)

    except OSError as e:
         if "Address already in use" in str(e): print(f"Error: Port {port} is already in use.")
         else: print(f"Error: Failed to start server OS error: {e}"); traceback.print_exc()
    except Exception as e: print(f"Error: Unexpected error during server startup: {e}"); traceback.print_exc()
    finally:
        print("Server shutting down...");
        if simulation_running:
            simulation_running = False
            if simulation_loop_task:
                try: simulation_loop_task.kill() # Attempt to kill greenlet
                except: pass
        if av_manager:
            stop_av_system(av_manager)
        print("Server stopped.")

```
--- END OF MODIFIED FILE `server.py` ---

--- START OF MODIFIED FILE `index.html` ---

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Ensure proper scaling and disable zoom for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multi-Bot Titans Sim v5.15 - AV Process Fix</title> <!-- Version Bump -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        /* --- CSS Styles (Enhanced for Mobile and Clarity - v5.15 AV Process Fix) --- */
        :root {
             --bg-color: #f0f2f5; /* Slightly softer background */
             --container-bg: #ffffff;
             --border-color: #d9d9d9; /* Softer border */
             --text-color: #333;
             --primary-color: #1890ff; /* Ant Design Blue */
             --primary-hover: #40a9ff;
             --secondary-color: #faad14; /* Ant Design Orange */
             --secondary-hover: #ffc53d;
             --danger-color: #f5222d; /* Ant Design Red */
             --danger-hover: #ff4d4f;
             --success-color: #52c41a; /* Ant Design Green */
             --success-hover: #73d13d;
             --info-color: #13c2c2; /* Ant Design Cyan */
             --info-hover: #36cfc9;
             --warn-color: #fa8c16; /* Darker Orange for Warnings */
             --frozen-color: #40a9ff; /* Use a variant of primary for frozen */
             --param-label-color: #0050b3; /* Darker blue for labels */
             --player-color: var(--success-color);
             --player-controlled-color: var(--success-color); /* Same as player for consistency */
             --hardcoded-color: var(--primary-color);
             --learning-color: var(--danger-color);
             --learning-available-color: #ff7a45; /* Orange-ish for available learning bots */
             --mobile-button-bg: #f0f0f0;
             --mobile-button-border: #ccc;
             --mobile-button-active-bg: #e0e0e0;
             --target-indicator-bg: rgba(255, 255, 0, 0.7); /* Yellowish for target indicator */
             --target-crosshair-color: rgba(255, 0, 0, 0.7); /* Red crosshair */
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow-x: hidden; } /* Prevent horizontal scroll */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; display: flex; flex-direction: column; align-items: center; padding: 10px; box-sizing: border-box; line-height: 1.5; background-color: var(--bg-color); color: var(--text-color); -webkit-tap-highlight-color: transparent; /* Disable tap highlight */ }
        canvas { border: 1px solid var(--border-color); margin-bottom: 10px; display: block; max-width: 100%; height: auto; touch-action: manipulation; /* Allows pinch zoom, prevents double-tap zoom */ background-color: var(--container-bg); cursor: crosshair; image-rendering: pixelated; /* Keep pixels sharp */ }
        .main-container { display: flex; flex-direction: row; flex-wrap: wrap; align-items: flex-start; width: 100%; max-width: 1700px; justify-content: center; gap: 25px; padding-bottom: 150px; /* Space for mobile controls */ }
        .grid-container { flex-basis: 600px; flex-grow: 1; max-width: 800px; min-width: 300px; /* Smaller min-width */ display: flex; flex-direction: column; justify-content: flex-start; align-items: center; }
        .controls-and-info { display: flex; flex-direction: column; flex-basis: 480px; flex-grow: 1; min-width: 320px; max-width: 700px; background-color: var(--container-bg); padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .simulation-controls, .param-controls, .player-controls { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; align-items: center; }
        button { padding: 8px 14px; cursor: pointer; border: none; border-radius: 5px; font-size: 0.9em; font-weight: 500; transition: background-color 0.2s ease, box-shadow 0.2s ease; }
        button:hover:not(:disabled) { box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button:active:not(:disabled) { transform: translateY(1px); box-shadow: none; }
        button:disabled { background-color: #bdc3c7 !important; cursor: not-allowed; opacity: 0.6; box-shadow: none; }

        #startButton { background-color: var(--success-color); color: white; }
        #startButton:hover:not(:disabled) { background-color: var(--success-hover); }
        #stopButton { background-color: var(--danger-color); color: white; }
        #stopButton:hover:not(:disabled) { background-color: var(--danger-hover); }
        #resetRoundButton, #resetFullButton { background-color: var(--secondary-color); color: white; }
        #resetRoundButton:hover:not(:disabled), #resetFullButton:hover:not(:disabled) { background-color: var(--secondary-hover); }
        #applyParamsButton { background-color: #722ed1; color: white; } /* Ant Purple */
        #applyParamsButton:hover:not(:disabled) { background-color: #9254de; }
        #saveParamsButton, #loadParamsButton, #resetParamsButton { background-color: var(--info-color); font-size: 0.85em; padding: 6px 10px; color: white;}
        #saveParamsButton:hover:not(:disabled), #loadParamsButton:hover:not(:disabled), #resetParamsButton:hover:not(:disabled) { background-color: var(--info-hover); }
        #joinButton { background-color: var(--primary-color); color: white; margin-left: auto; } /* Shown if join possible */
        #leaveButton { background-color: var(--warn-color); color: white; margin-left: auto; display: none; } /* Initially hidden */
        #leaveButton:hover:not(:disabled) { background-color: #ffc53d; }


        .parameters { border: 1px solid #eee; padding: 15px; margin-bottom: 15px; background-color: #fdfdfd; border-radius: 5px; }
        .parameters h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.1em; border-bottom: 1px solid #eee; padding-bottom: 8px; color: #444; }
        .parameters div.param-item { margin-bottom: 10px; display: flex; flex-wrap: wrap; align-items: center; gap: 5px 10px; font-size: 0.88em; }
        .parameters label { display: inline-block; min-width: 160px; font-weight: 500; flex-shrink: 0; color: #555; }
        .parameters input[type=number], .parameters input[type=text], .parameters input[type=checkbox], .parameters select { padding: 5px 7px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1em; background-color: #fff; } /* Added select */
        .parameters input[type=number], .parameters input[type=text], .parameters select { width: 100px; } /* Slightly wider, consistent width */
        .parameters input[type=range] { flex-grow: 1; cursor: pointer; } /* Range slider */
        .parameters .range-value { font-weight: bold; min-width: 40px; text-align: right; } /* Display value for range */
        .parameters input[type=checkbox] { width: auto; margin-left: 5px; transform: scale(1.1); }
        .parameters .tooltip { display: inline-block; background-color: #bfbfbf; border-radius: 50%; width: 16px; height: 16px; text-align: center; line-height: 16px; font-size: 11px; color: white; font-weight: bold; vertical-align: middle; cursor: help; position: relative; margin-left: 3px; }
        .parameters .reset-hint { font-style: italic; font-size: 0.85em; color: var(--warn-color); margin-left: 6px; display: none; white-space: nowrap; font-weight: 500; }
        .parameters div.param-item.changed label { color: var(--warn-color); font-weight: bold;}
        .parameters div.param-item.needs-reset .reset-hint { display: inline !important; }
        .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: rgba(0,0,0,0.8); color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 10; bottom: 130%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 0.85em; font-weight: normal; line-height: 1.3; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .tooltip:hover .tooltiptext, .tooltip:focus .tooltiptext, .tooltip:active .tooltiptext { visibility: visible; opacity: 1; }

        .info { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .bot-type-info { border: 1px solid #e8e8e8; padding: 10px; font-size: 0.88em; background-color: #fafafa; border-radius: 5px; }
        .bot-type-info b { display: block; margin-bottom: 4px; font-size: 1.05em; }
        .stats { margin-top: 15px; font-weight: bold; padding: 12px; background-color: #e6f7ff; border: 1px solid #bae7ff; border-radius: 5px; font-size: 0.95em; line-height: 1.5; }
        .frozen-status { color: var(--frozen-color); font-weight: bold; border: 1px dashed var(--frozen-color); padding: 1px 4px; border-radius: 4px; display: inline-block; font-size: 0.8em; margin-left: 4px; background-color: #e6f7ff; }
        hr { width: 100%; margin: 20px 0; border: 0; border-top: 1px solid #e8e8e8; }

        .library-param-label { font-weight: bold; color: var(--param-label-color); }
        .param-group { border: 1px dashed #e0e0e0; padding: 12px; margin-bottom: 12px; border-radius: 4px; background-color: #fdfdfd;}
        .param-group h4 { margin-top: 0; margin-bottom: 10px; font-size: 1em; color: #666; }
        #status, #round-info, #player-info { margin-top: 8px; font-weight: bold; }
        #status { font-size: 1.05em; color: #333; min-height: 1.4em; }
        #round-info { font-size: 0.95em; color: #555;}
        #player-info { font-size: 0.9em; color: var(--player-color); margin-bottom: 8px; }
        #connection-status { position: fixed; top: 5px; right: 8px; font-size: 0.8em; padding: 3px 6px; border-radius: 4px; background-color: var(--danger-color); color: white; font-weight: bold; z-index: 1000; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        #connection-status.connected { background-color: var(--success-color); }

        /* Bot Color Indicators */
        .hc-color { color: var(--hardcoded-color); font-weight: bold;}
        .ln-color { color: var(--learning-color); font-weight: bold;}
        .pl-color { color: var(--player-color); font-weight: bold;}
        .player-controlled-marker {
            font-weight: bold;
            color: var(--player-controlled-color);
            margin-left: 5px;
            font-size: 0.9em;
        }
        .learning-available-marker { /* Style for the outline/indicator */
            outline: 2px dashed var(--learning-available-color);
            outline-offset: 2px;
            cursor: pointer; /* Indicate clickable */
        }

        /* Target Indicator */
        #target-indicator {
            position: fixed;
            top: 5px;
            left: 8px;
            font-size: 0.85em;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: var(--target-indicator-bg);
            color: #333;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: none; /* Hidden by default */
        }


        /* --- Mobile Controls --- */
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(230, 230, 230, 0.9); /* Semi-transparent background */
            padding: 10px 5px;
            box-sizing: border-box;
            display: none; /* Initially hidden, shown via JS */
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            z-index: 900;
            border-top: 1px solid var(--border-color);
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            touch-action: manipulation; /* Important for preventing unwanted gestures */
            -webkit-user-select: none; /* Disable text selection */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none; /* Disabled by default */
            opacity: 0.7; /* Dimmed when disabled */
        }
        #mobile-controls.enabled {
            pointer-events: auto; /* Enable interaction */
            opacity: 1.0;
        }


        #mobile-controls button {
            font-size: 18px; /* Larger font for touch */
            padding: 12px 10px; /* Larger padding */
            min-width: 55px; /* Ensure decent tap area */
            text-align: center;
            background-color: var(--mobile-button-bg);
            border: 1px solid var(--mobile-button-border);
            border-radius: 8px;
            font-weight: bold;
            color: var(--text-color);
        }
        #mobile-controls.enabled button:active { /* Feedback on tap only when enabled */
             background-color: var(--mobile-button-active-bg);
             transform: scale(0.95);
        }

        /* Show mobile controls only on smaller screens */
        @media (max-width: 768px) {
            #mobile-controls { display: flex; }
            .main-container { padding-bottom: 80px; } /* Adjust main padding */
            .grid-container { min-width: unset; width: 100%; max-width: 100%; flex-basis: auto; } /* Full width canvas */
            .controls-and-info { min-width: unset; width: 100%; max-width: 100%; flex-basis: auto; margin-top:15px; }
             .parameters label { min-width: 130px; } /* Adjust label width on mobile */
             .desktop-only { display: none; }
        }
        @media (min-width: 769px) {
            #mobile-controls { display: none; } /* Hide on larger screens */
        }

    </style>
</head>
<body>
    <h1>Multi-Bot Titans Sim (v5.15 - AV Process Fix)</h1>
    <p style="max-width: 900px; text-align: center; margin-bottom: 15px; font-size: 0.95em;">
        Bots navigate, claim goals, punch opponents. Tap/Click grid to set target for player bot. Tap self to cancel.
        <span class="ln-color">Learning Bots (Red)</span> use backend PyTorch Neural Memory.
        <span class="hc-color">Hardcoded Bots (Blue)</span> use rules.
        <span class="pl-color">Players (Green)</span> control a Learning Bot. Click <span style="color: var(--learning-available-color); font-weight:bold;">Available Learning Bot</span> or "Join Game" button.
    </p>
    <p style="font-size:0.85em; color: var(--danger-color);"><i>Backend (`server.py`) must be running. High bot/grid counts need strong GPU (Check server console for CUDA status).
    <b>AV features require libraries installed (see server console) and enabling options below. Visualization runs in a separate process. Check server console for library status.</b></i></p>
    <div id="connection-status" title="Connection Status">Connecting...</div>
    <div id="target-indicator">Target: None</div>

    <div class="main-container">
        <div class="grid-container">
            <canvas id="gridCanvas" width="600" height="600"></canvas>
             <div id="player-info">Player Bot ID: None</div>
             <p style="font-size: 0.85em; margin-top: 5px;" class="desktop-only">Controls: Click/Drag on grid to set target. Click self to cancel. Click available Learning Bot or Join button.</p>
        </div>

        <div class="controls-and-info">
             <div class="simulation-controls">
                <button id="startButton" title="Start Simulation" disabled>Start</button>
                <button id="stopButton" disabled title="Stop Simulation">Stop</button>
                <button id="resetRoundButton" title="Start a New Round (May use new env)" disabled>New Round</button>
                <button id="resetFullButton" title="Reset Environment and Learning State" disabled>Reset All</button>
                 <button id="joinButton" title="Join as Player (Controls first available Learning Bot)" disabled>Join Game</button>
                 <button id="leaveButton" title="Relinquish Control of Bot" disabled>Leave Bot</button>
             </div>
                 <div id="status" style="margin-bottom: 5px;">Status: Connecting...</div>
                 <div id="round-info" style="margin-bottom: 15px;">Round: 0</div>
            <hr>
            <div class="parameters">
                 <!-- Parameter structure matches backend CONFIG keys -->
                 <h3>Simulation Parameters</h3>
                 <div class="param-group">
                      <h4>General</h4>
                     <div data-param="SIMULATION_SPEED_MS" class="param-item">
                         <label for="param-SIMULATION_SPEED_MS">Sim Speed (ms delay):</label>
                         <input type="number" id="param-SIMULATION_SPEED_MS" name="SIMULATION_SPEED_MS" min="1" max="1000" step="10">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Target delay between server steps. Lower is faster. (Requires Apply)</span></span>
                         <span class="reset-hint"></span>
                     </div>
                     <div data-param="FREEZE_DURATION" class="param-item">
                         <label for="param-FREEZE_DURATION">Freeze Duration (steps):</label>
                         <input type="number" id="param-FREEZE_DURATION" name="FREEZE_DURATION" min="1" max="100">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Steps bots stay frozen after punch. (Requires Apply)</span></span>
                          <span class="reset-hint"></span>
                     </div>
                     <!-- AV Controls Updated -->
                     <div data-param="ENABLE_AV" class="param-item needs-reset">
                         <label for="param-ENABLE_AV">Enable AV Processing:</label>
                         <input type="checkbox" id="param-ENABLE_AV" name="ENABLE_AV">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Enable backend processing of bot data for audio/visuals. Requires AV libs installed (see console). Requires Reset All.</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                      <div data-param="ENABLE_AV_OUTPUT" class="param-item needs-reset">
                         <label for="param-ENABLE_AV_OUTPUT">Enable AV Output (Audio/Window):</label>
                         <input type="checkbox" id="param-ENABLE_AV_OUTPUT" name="ENABLE_AV_OUTPUT">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">If AV Processing is enabled, this enables SoundDevice audio and opens the visualization window (VisPy/Matplotlib) or enables web data stream. Requires Reset All.</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="VISUALIZATION_MODE" class="param-item needs-reset">
                         <label for="param-VISUALIZATION_MODE">Visualization Mode:</label>
                         <select id="param-VISUALIZATION_MODE" name="VISUALIZATION_MODE">
                             <option value="vispy">VisPy (3D Window)</option>
                             <option value="matplotlib">Matplotlib (3D Window)</option>
                             <option value="web">Web (Data Stream)</option>
                             <option value="none">None</option>
                         </select>
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Selects the visualization backend if AV Output is enabled. Requires corresponding library installed (see console). 'Web' streams data to /visuals endpoint. Requires Reset All.</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                 </div>

                 <div class="param-group">
                     <h4>Environment (Require Reset)</h4>
                     <div data-param="GRID_SIZE" class="param-item needs-reset">
                         <label for="param-GRID_SIZE">Grid Size:</label>
                         <input type="number" id="param-GRID_SIZE" name="GRID_SIZE" min="10" max="200">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Width/Height of the grid. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="NUM_GOALS" class="param-item needs-reset">
                         <label for="param-NUM_GOALS">Num Goals:</label>
                         <input type="number" id="param-NUM_GOALS" name="NUM_GOALS" min="0" max="500">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of goals per round. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="NUM_HC_BOTS" class="param-item needs-reset">
                         <label for="param-NUM_HC_BOTS">Num Hardcoded Bots:</label>
                         <input type="number" id="param-NUM_HC_BOTS" name="NUM_HC_BOTS" min="0" max="100">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of blue (rule-based) bots. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="NUM_LEARNING_BOTS" class="param-item needs-reset">
                         <label for="param-NUM_LEARNING_BOTS">Num Learning Bots:</label>
                         <input type="number" id="param-NUM_LEARNING_BOTS" name="NUM_LEARNING_BOTS" min="0" max="100">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of red (Titans learning) bots. Player takes over one of these. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                      <div data-param="MAX_STEPS_PER_ROUND" class="param-item needs-reset">
                         <label for="param-MAX_STEPS_PER_ROUND">Max Steps/Round:</label>
                         <input type="number" id="param-MAX_STEPS_PER_ROUND" name="MAX_STEPS_PER_ROUND" min="100" max="10000">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">Max steps per bot before round ends. (Req. New Round)</span></span>
                          <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="VISIBILITY_RANGE" class="param-item needs-reset">
                         <label for="param-VISIBILITY_RANGE">Sense Visibility Range:</label>
                         <input type="number" id="param-VISIBILITY_RANGE" name="VISIBILITY_RANGE" min="2" max="50">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">How far bots 'see' (Manhattan dist). Affects input stream size/content. (Req. New Round)</span></span>
                          <span class="reset-hint">(Reset Req.)</span>
                     </div>
                      <div data-param="RANDOMIZE_ENV_PER_ROUND" class="param-item">
                         <label for="param-RANDOMIZE_ENV_PER_ROUND">New Env Each Round:</label>
                         <input type="checkbox" id="param-RANDOMIZE_ENV_PER_ROUND" name="RANDOMIZE_ENV_PER_ROUND">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">If checked, 'New Round' generates a new obstacle/goal layout. If unchecked, it resets goals on the same layout. (Requires Apply)</span></span>
                         <span class="reset-hint"></span>
                     </div>
                 </div>

                 <div class="param-group">
                     <h4>Learning Bot (Titans Lib - Require Reset All)</h4>
                      <div data-param="LEARNING_BOT_DIM" class="param-item needs-reset">
                         <label class="library-param-label" for="param-LEARNING_BOT_DIM">Memory Dimension:</label>
                         <input type="number" id="param-LEARNING_BOT_DIM" name="LEARNING_BOT_DIM" min="32" max="4096" step="16">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Internal dimension (dim) of NeuralMemory and feature vector. Larger = more capacity but more VRAM. Must be >= features (~15). (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                      </div>
                      <div data-param="LEARNING_BOT_MEM_DEPTH" class="param-item needs-reset">
                         <label class="library-param-label" for="param-LEARNING_BOT_MEM_DEPTH">Memory MLP Depth:</label>
                         <input type="number" id="param-LEARNING_BOT_MEM_DEPTH" name="LEARNING_BOT_MEM_DEPTH" min="1" max="12">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Layers in MemoryMLP. Deeper learns complex patterns but slower. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                      </div>
                       <div data-param="LEARNING_BOT_LR" class="param-item needs-reset">
                         <label class="library-param-label" for="param-LEARNING_BOT_LR">Memory Learn Rate (LR):</label>
                         <input type="number" id="param-LEARNING_BOT_LR" name="LEARNING_BOT_LR" min="0.00001" max="0.1" step="0.00001" value="0.001">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">AdamW Learning rate (lr) for memory updates. Controls adaptation speed. (Req. Reset All)</span></span>
                          <span class="reset-hint">(Reset Req.)</span>
                      </div>
                       <div data-param="LEARNING_BOT_WEIGHT_DECAY" class="param-item needs-reset">
                         <label class="library-param-label" for="param-LEARNING_BOT_WEIGHT_DECAY">Memory Weight Decay:</label>
                         <input type="number" id="param-LEARNING_BOT_WEIGHT_DECAY" name="LEARNING_BOT_WEIGHT_DECAY" min="0.0" max="0.1" step="0.001" value="0.01">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">AdamW Weight decay (forgetting) for memory weights. (Req. Reset All)</span></span>
                          <span class="reset-hint">(Reset Req.)</span>
                      </div>
                       <div data-param="LEARNING_BOT_MOMENTUM" class="param-item needs-reset">
                         <label class="library-param-label" for="param-LEARNING_BOT_MOMENTUM">Memory Momentum (1):</label>
                         <input type="number" id="param-LEARNING_BOT_MOMENTUM" name="LEARNING_BOT_MOMENTUM" min="0.5" max="0.999" step="0.001" value="0.9">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">AdamW beta1 (momentum) for memory updates. (Req. Reset All)</span></span>
                          <span class="reset-hint">(Reset Req.)</span>
                      </div>
                      <div data-param="LEARNING_BOT_MAX_GRAD_NORM" class="param-item needs-reset">
                         <label class="library-param-label" for="param-LEARNING_BOT_MAX_GRAD_NORM">Memory Max Grad Norm:</label>
                         <input type="number" id="param-LEARNING_BOT_MAX_GRAD_NORM" name="LEARNING_BOT_MAX_GRAD_NORM" min="0.1" max="10.0" step="0.1" value="1.0">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Max norm for gradient clipping during updates. Prevents instability. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                      </div>
                 </div>
                  <div class="param-group">
                     <h4>Learning Bot Behavior (Apply Req.)</h4>
                     <div data-param="LEARNING_BOT_BASE_EXPLORATION_RATE" class="param-item">
                         <label for="param-LEARNING_BOT_BASE_EXPLORATION_RATE">Base Explore Rate (%):</label>
                         <input type="number" id="param-LEARNING_BOT_BASE_EXPLORATION_RATE" name="LEARNING_BOT_BASE_EXPLORATION_RATE" min="0" max="100" step="1" value="15">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Base chance (%) Learning Bot explores instead of exploiting memory. Rate increases with anomaly. (Requires Apply)</span></span>
                           <span class="reset-hint"></span>
                     </div>
                      <div data-param="LEARNING_BOT_RULE_EXPLORE_PERCENT" class="param-item">
                         <label for="param-LEARNING_BOT_RULE_EXPLORE_PERCENT">Rule Exploration (%):</label>
                         <input type="number" id="param-LEARNING_BOT_RULE_EXPLORE_PERCENT" name="LEARNING_BOT_RULE_EXPLORE_PERCENT" min="0" max="100" step="1" value="60">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Of the exploration actions, percentage (%) that use rule-based logic vs random. (Requires Apply)</span></span>
                           <span class="reset-hint"></span>
                     </div>
                     <div data-param="PLAYER_CONTROL_PERCENT" class="param-item">
                        <label for="param-PLAYER_CONTROL_PERCENT">Player Control Influence (%):</label>
                        <input type="range" id="param-PLAYER_CONTROL_PERCENT" name="PLAYER_CONTROL_PERCENT" min="0" max="100" step="1" value="100">
                        <span class="range-value" id="value-PLAYER_CONTROL_PERCENT">100%</span>
                        <span class="tooltip" tabindex="0">?<span class="tooltiptext">How much player input overrides AI prediction (0% = full AI, 100% = full Player). Blends probabilistically. (Requires Apply)</span></span>
                        <span class="reset-hint"></span>
                    </div>
                 </div>

                 <hr>
                 <div class="param-controls">
                    <button id="applyParamsButton" title="Send Changed Parameters to Server" disabled>Apply Changes</button>
                    <button id="saveParamsButton" title="Save Current UI Parameters to Browser Storage">Save Params</button>
                    <button id="loadParamsButton" title="Load Parameters from Browser Storage">Load Params</button>
                    <button id="resetParamsButton" title="Reset UI Parameters to Default Values">Reset UI to Default</button>
                 </div>
            </div>

             <div class="stats">
                Goals Claimed (Total):<br>
                <span class="hc-color">Hardcoded:</span> <span id="hc-total-goals">0</span> |
                <span class="ln-color">Learning</span>/<span class="pl-color">Player:</span> <span id="learning-total-goals">0</span><br>
                Avg Bot Anomaly (Learning): <span id="learning-avg-anomaly">N/A</span>
            </div>

            <div class="info">
                <div id="bots-info-container" style="max-height: 250px; overflow-y: auto; border: 1px solid #f0f0f0; padding: 5px; background: #fff;">
                    <!-- Bot specific info populated here -->
                     <div class="bot-type-info"><b>Bots Information Loading...</b></div>
                </div>
            </div>

        </div>
    </div>

    <!-- Mobile Controls Section -->
    <div id="mobile-controls"> <!-- Initially disabled via style, enabled via JS -->
        <button id="btn-up"></button> <!-- Up -->
        <button id="btn-left"></button> <!-- Left -->
        <button id="btn-right"></button> <!-- Right -->
        <button id="btn-down"></button> <!-- Down -->
        <button id="btn-punch">Punch</button> <!-- Punch (Space) -->
        <button id="btn-claim">Claim</button> <!-- Claim (Enter) -->
    </div>

    <script>
        // ================================================================
        // --- Client-Side JavaScript (v5.15 - AV Process Fix) ---
        // ================================================================
        let socket;
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const roundInfoEl = document.getElementById('round-info');
        const playerInfoEl = document.getElementById('player-info');
        const connectionStatusEl = document.getElementById('connection-status');
        const gridContainerEl = document.querySelector('.grid-container');
        const botsInfoContainerEl = document.getElementById('bots-info-container');
        const mobileControlsEl = document.getElementById('mobile-controls');
        const targetIndicatorEl = document.getElementById('target-indicator');

        // --- Parameter Elements Cache ---
        const paramInputs = {};
        const paramItems = {};
        const rangeValueDisplays = {}; // For range sliders
        document.querySelectorAll('.parameters .param-item').forEach(paramItemDiv => {
            const key = paramItemDiv.dataset.param;
            const input = paramItemDiv.querySelector('input, select'); // Include select
            if (key && input && paramItemDiv) {
                paramInputs[key] = input;
                paramItems[key] = paramItemDiv;
                input.addEventListener('input', () => handleParamInputChange(key));
                input.addEventListener('change', () => handleParamInputChange(key));
                if (input.type === 'range') {
                    const valueDisplay = paramItemDiv.querySelector('.range-value');
                    if (valueDisplay) {
                        rangeValueDisplays[key] = valueDisplay;
                        valueDisplay.textContent = `${input.value}%`; // Initial display
                        input.addEventListener('input', () => { valueDisplay.textContent = `${input.value}%`; });
                    }
                }
            } else { console.warn("Param item found without key or input/select:", paramItemDiv); }
        });
        function handleParamInputChange(key) {
            markParamChanged(key);
             if (rangeValueDisplays[key] && paramInputs[key].type === 'range') {
                 rangeValueDisplays[key].textContent = `${paramInputs[key].value}%`;
             }
        }

        // --- Buttons ---
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const resetRoundButton = document.getElementById('resetRoundButton');
        const resetFullButton = document.getElementById('resetFullButton');
        const applyParamsButton = document.getElementById('applyParamsButton');
        const saveParamsButton = document.getElementById('saveParamsButton');
        const loadParamsButton = document.getElementById('loadParamsButton');
        const resetParamsButton = document.getElementById('resetParamsButton');
        const joinButton = document.getElementById('joinButton');
        const leaveButton = document.getElementById('leaveButton');
        const mobileUp = document.getElementById('btn-up');
        const mobileLeft = document.getElementById('btn-left');
        const mobileRight = document.getElementById('btn-right');
        const mobileDown = document.getElementById('btn-down');
        const mobilePunch = document.getElementById('btn-punch');
        const mobileClaim = document.getElementById('btn-claim');

        // --- Client State ---
        let serverConfig = {}; // Config as known by the server (or defaults)
        let uiDefaults = {};   // Defaults loaded on first connect
        let clientState = {
            environment: null, bots: {}, round: 0,
            stats: { hc_total_goals: 0, learning_total_goals: 0 },
            isRunning: false,
            needsFullReset: false,
            needsRoundReset: false,
            playerBotId: null,
            playerOriginalBotId: null,
            playerTarget: null
        };
        let visualizer = null;
        const LOCAL_STORAGE_KEY_UI = 'multiBotSimParams_v5.15_AVProcessFix'; // Updated key
        const LOCAL_STORAGE_KEY_PLAYER = 'multiBotPlayerControl_v5.15'; // Key for player session

        let isDragging = false;
        let lastSentTargetTime = 0;
        const TARGET_UPDATE_INTERVAL_MS = 100;

        // --- Visualizer Class (No changes needed from previous version) ---
        class Visualizer {
            constructor(canvasCtx, gridContainer) {
                this.ctx = canvasCtx; this.canvas = canvasCtx.canvas; this.gridContainer = gridContainer;
                this.gridSize = 0; this.cellSize = 0; this.currentGoals = []; this.currentObstacles = new Set();
                this.claimedGoalsIDs = new Set(); this.lastContainerWidth = 0; this.ctx.imageSmoothingEnabled = false;
            }
            updateGridDimensions(newGridSize) {
                if (!this.gridContainer || newGridSize === undefined || newGridSize <= 0) return;
                const gridSizeNum = Number(newGridSize); if (isNaN(gridSizeNum) || gridSizeNum <= 0) return;
                const availableWidth = Math.max(300, this.gridContainer.offsetWidth - 2);
                const newCellSize = Math.max(4, Math.floor(availableWidth / gridSizeNum));
                if (gridSizeNum !== this.gridSize || newCellSize !== this.cellSize || this.gridContainer.offsetWidth !== this.lastContainerWidth) {
                    this.gridSize = gridSizeNum; this.cellSize = newCellSize; this.canvas.width = this.gridSize * this.cellSize; this.canvas.height = this.gridSize * this.cellSize; this.lastContainerWidth = this.gridContainer.offsetWidth; console.log(`Canvas resized: ${this.canvas.width}x${this.canvas.height}, CellSize: ${this.cellSize}`);
                }
            }
            updateData(environmentState) {
                if (!environmentState) return; this.updateGridDimensions(environmentState.size); this.currentGoals = environmentState.goals || []; this.currentObstacles = new Set((environmentState.obstacles || []).map(obs => `${obs[0]},${obs[1]}`)); this.claimedGoalsIDs = new Set(environmentState.claimedGoals || []);
            }
            drawGrid() {
                if (!this.ctx || !this.gridSize || !this.cellSize) return; const canvasWidth = this.canvas.width; const canvasHeight = this.canvas.height; this.ctx.clearRect(0, 0, canvasWidth, canvasHeight); this.ctx.fillStyle = '#ffffff'; this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                if (this.cellSize > 5) { this.ctx.strokeStyle = '#f0f0f0'; this.ctx.lineWidth = 1; for (let i = 0; i <= this.gridSize; i++) { const pos = Math.round(i * this.cellSize) + 0.5; this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, canvasHeight); this.ctx.stroke(); this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(canvasWidth, pos); this.ctx.stroke(); }
                } else { this.ctx.strokeStyle = '#e0e0e0'; this.ctx.lineWidth = 0.5; this.ctx.strokeRect(0.5, 0.5, canvasWidth - 1, canvasHeight - 1); }
                this.ctx.fillStyle = '#595959'; this.currentObstacles.forEach(obsString => { try { const [x, y] = obsString.split(',').map(Number); if(x>=0 && x<this.gridSize && y>=0 && y<this.gridSize) { this.ctx.fillRect(Math.floor(x * this.cellSize), Math.floor(y * this.cellSize), Math.ceil(this.cellSize), Math.ceil(this.cellSize)); } } catch(e){ /* ignore */ } });
                this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; const goalRadius = Math.max(1.5, this.cellSize * 0.35); const goalFontSize = Math.max(7, Math.floor(this.cellSize * 0.5));
                this.currentGoals.forEach((goal) => { if(!goal || goal.x === undefined) return; const drawX = Math.floor(goal.x * this.cellSize); const drawY = Math.floor(goal.y * this.cellSize); const centerX = drawX + this.cellSize / 2; const centerY = drawY + this.cellSize / 2;
                    if(goal.x>=0 && goal.x<this.gridSize && goal.y>=0 && goal.y<this.gridSize) { if (this.claimedGoalsIDs.has(goal.id)) { this.ctx.fillStyle = '#d9d9d9'; this.ctx.fillRect(drawX, drawY, Math.ceil(this.cellSize), Math.ceil(this.cellSize)); if (this.cellSize > 8) { this.ctx.fillStyle = '#8c8c8c'; this.ctx.font = `bold ${goalFontSize}px sans-serif`; this.ctx.fillText("X", centerX, centerY); } } else { this.ctx.fillStyle = 'gold'; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, goalRadius, 0, Math.PI * 2); this.ctx.fill(); if (this.cellSize > 4) { this.ctx.strokeStyle = '#d48806'; this.ctx.lineWidth = 0.5; this.ctx.stroke(); } if (this.cellSize > 10) { this.ctx.fillStyle = '#434343'; this.ctx.font = `bold ${goalFontSize*0.8}px sans-serif`; this.ctx.fillText("G", centerX, centerY + 1); } } } });
                this.ctx.lineWidth = 1;
            }
             drawBot(bot) {
                 if (!bot || !bot.pos || bot.pos.x === undefined) return;
                 const drawX = bot.pos.x * this.cellSize; const drawY = bot.pos.y * this.cellSize;
                 const centerX = drawX + this.cellSize / 2; const centerY = drawY + this.cellSize / 2;
                 const radius = Math.max(2, this.cellSize * 0.4);
                 let color = '#888'; let isAvailableToJoin = false;

                 if (bot.type === 'Hardcoded') { color = getComputedStyle(document.documentElement).getPropertyValue('--hardcoded-color').trim() || '#1890ff'; }
                 else if (bot.type === 'Learning') {
                     if (bot.is_player) { color = getComputedStyle(document.documentElement).getPropertyValue('--player-controlled-color').trim() || '#52c41a'; }
                     else {
                         color = getComputedStyle(document.documentElement).getPropertyValue('--learning-color').trim() || '#f5222d';
                         if (clientState.playerBotId === null) { isAvailableToJoin = true; } // Mark as available only if no player is currently joined
                     }
                 }

                 this.ctx.fillStyle = color; this.ctx.globalAlpha = 0.95; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); this.ctx.fill();

                 if (bot.is_player) {
                     this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--player-controlled-color').trim();
                     this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.15));
                     this.ctx.setLineDash([Math.max(1, this.cellSize * 0.1), Math.max(1, this.cellSize * 0.1)]);
                     this.ctx.stroke(); this.ctx.setLineDash([]);
                 }
                 else if (isAvailableToJoin) {
                     this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--learning-available-color').trim();
                     this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.1));
                     this.ctx.setLineDash([Math.max(2, this.cellSize * 0.15), Math.max(1, this.cellSize * 0.1)]);
                     this.ctx.strokeRect(drawX + this.ctx.lineWidth / 2, drawY + this.ctx.lineWidth / 2, this.cellSize - this.ctx.lineWidth, this.cellSize - this.ctx.lineWidth);
                     this.ctx.setLineDash([]);
                 }

                 if (bot.freezeTimer > 0) {
                     this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--frozen-color').trim();
                     this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.1));
                     this.ctx.globalAlpha = 0.8; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, radius * 1.15, 0, 2 * Math.PI); this.ctx.stroke();
                 }

                 this.ctx.globalAlpha = 1.0;

                 if (this.cellSize > 14) {
                     this.ctx.fillStyle = 'white'; this.ctx.font = `bold ${Math.max(6, Math.floor(this.cellSize * 0.35))}px sans-serif`;
                     const idNum = bot.id.match(/\d+/); const label = bot.id[0] + (idNum ? idNum[0] : '');
                     this.ctx.fillText(label, centerX, centerY + 1);
                 }
                 this.ctx.lineWidth = 1;
             }
             drawTarget(targetCoord) {
                 if (!targetCoord || !this.cellSize || targetCoord.x === null || targetCoord.y === null) return; const centerX = targetCoord.x * this.cellSize + this.cellSize / 2; const centerY = targetCoord.y * this.cellSize + this.cellSize / 2; const crossSize = this.cellSize * 0.4;
                 this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--target-crosshair-color').trim(); this.ctx.lineWidth = Math.max(1, this.cellSize * 0.08); this.ctx.globalAlpha = 0.8; this.ctx.beginPath(); this.ctx.moveTo(centerX - crossSize, centerY); this.ctx.lineTo(centerX + crossSize, centerY); this.ctx.moveTo(centerX, centerY - crossSize); this.ctx.lineTo(centerX, centerY + crossSize); this.ctx.stroke(); this.ctx.globalAlpha = 1.0; this.ctx.lineWidth = 1;
             }
            update(state) {
                if (!state) return; this.updateData(state.environment); this.drawGrid(); Object.values(state.bots || {}).forEach(bot => this.drawBot(bot)); if (clientState.playerBotId && clientState.playerTarget) { this.drawTarget(clientState.playerTarget); }
            }
            getBotAtCoord(gridX, gridY) {
                for (const botId in clientState.bots) {
                    const bot = clientState.bots[botId];
                    if (bot.pos && bot.pos.x === gridX && bot.pos.y === gridY) {
                        return bot;
                    }
                }
                return null;
            }
        }

        // --- SocketIO Setup (No changes needed from previous version) ---
        function setupSocket() {
            try {
                const socketUrl = window.location.origin; console.log(`Connecting Socket.IO to: ${socketUrl}`);
                socket = io(socketUrl, { reconnectionAttempts: 5, transports: ['websocket'] });
                socket.on('connect', () => { console.log("Socket connected."); connectionStatusEl.textContent = 'Connected'; connectionStatusEl.classList.add('connected'); statusEl.textContent = "Status: Connected. Waiting for state..."; const savedPlayer = localStorage.getItem(LOCAL_STORAGE_KEY_PLAYER); if (savedPlayer) { try { const playerData = JSON.parse(savedPlayer); if (playerData && playerData.originalBotId) { console.log(`Attempting rejoin for original bot: ${playerData.originalBotId}`); socket.emit('rejoin_game', { originalBotId: playerData.originalBotId }); } else { localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } } catch (e) { console.error("Error parsing saved player data:", e); localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } } });
                socket.on('disconnect', (reason) => { connectionStatusEl.textContent = 'Disconnected'; connectionStatusEl.classList.remove('connected'); console.log("Disconnected:", reason); statusEl.textContent = `Status: Disconnected (${reason}).`; clientState.isRunning = false; clientState.playerTarget = null; updateTargetIndicator(); updateButtonStates(); updateMobileControls(); disableAllControls(); });
                socket.on('connect_error', (err) => { connectionStatusEl.textContent = 'Connection Error'; connectionStatusEl.classList.remove('connected'); console.error('Connection Error:', err.message); statusEl.textContent = "Status: Connection Error."; clientState.isRunning = false; clientState.playerTarget = null; updateTargetIndicator(); disableAllControls(); });
                socket.on('initial_state', (state) => { console.log("Received Initial state", state); if (!visualizer) visualizer = new Visualizer(ctx, gridContainerEl); serverConfig = copyConfig(state.config || {}); uiDefaults = copyConfig(state.config || {}); updateUIFromConfig(serverConfig); updateClientState(state); markParamsApplied(); clientState.isRunning = state.isRunning !== undefined ? state.isRunning : false; visualizer.update(clientState); updateInfoPanel(); updateButtonStates(); updateMobileControls(); statusEl.textContent = `Status: ${clientState.isRunning ? 'Running...' : 'Ready'}`; checkForNeededResets(); });
                socket.on('update_state', (state) => { updateClientState(state); if (visualizer) visualizer.update(clientState); updateInfoPanel(); });
                socket.on('config_update', (config) => { console.log("Server config update received"); serverConfig = copyConfig(config || {}); uiDefaults = copyConfig(serverConfig); updateUIFromConfig(serverConfig); markParamsApplied(); clearResetHints(); statusEl.textContent = "Status: Config Updated by Server."; updateButtonStates(); updateMobileControls(); });
                socket.on('status_update', (data) => { statusEl.textContent = `Status: ${data.message}`; });
                socket.on('simulation_started', () => { console.log("Sim started event received."); clientState.isRunning = true; statusEl.textContent = "Status: Running..."; updateButtonStates(); updateMobileControls(); clearResetHints(); });
                socket.on('simulation_stopped', (data) => { console.log("Sim stopped event received."); clientState.isRunning = false; statusEl.textContent = `Status: ${data.message || 'Stopped.'}`; clientState.playerTarget = null; updateTargetIndicator(); updateButtonStates(); updateMobileControls(); checkForNeededResets(); });
                socket.on('config_update_ack', (data) => { console.log("Config update ack received:", data); if (data.success) { serverConfig = copyConfig(data.updated_config || serverConfig); updateUIFromConfig(serverConfig); clientState.needsFullReset = data.needs_full_reset; clientState.needsRoundReset = data.needs_round_reset; markParamsApplied(); updateButtonStates(); updateMobileControls(); let msg = "Parameters Applied."; if(clientState.needsFullReset) msg += " 'Reset All' required."; else if(clientState.needsRoundReset) msg += " 'New Round' or 'Reset All' required."; statusEl.textContent = `Status: ${msg}`; } else { alert(`Failed to apply parameters: ${data.message || 'Unknown error'}`); statusEl.textContent = `Status: Parameter Apply Failed.`; } });
                socket.on('join_ack', (data) => { if(data.success) { clientState.playerBotId = data.player_id; clientState.playerOriginalBotId = data.original_bot_id; playerInfoEl.textContent = `CONTROLLING BOT: ${clientState.playerBotId}`; localStorage.setItem(LOCAL_STORAGE_KEY_PLAYER, JSON.stringify({ originalBotId: data.original_bot_id })); statusEl.textContent = `Status: Joined, controlling ${clientState.playerBotId}.`; clientState.playerTarget = null; updateTargetIndicator(); } else { alert(`Failed to join: ${data.message}`); playerInfoEl.textContent = `Player Bot ID: None`; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } updateButtonStates(); updateMobileControls(); });
                socket.on('rejoin_ack', (data) => { if(data.success) { clientState.playerBotId = data.player_id; clientState.playerOriginalBotId = data.original_bot_id; playerInfoEl.textContent = `CONTROLLING BOT: ${clientState.playerBotId}`; localStorage.setItem(LOCAL_STORAGE_KEY_PLAYER, JSON.stringify({ originalBotId: data.original_bot_id })); statusEl.textContent = `Status: Rejoined, controlling ${clientState.playerBotId}.`; clientState.playerTarget = null; updateTargetIndicator(); } else { console.warn(`Rejoin failed: ${data.message}`); playerInfoEl.textContent = `Player Bot ID: None`; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } updateButtonStates(); updateMobileControls(); });
                socket.on('leave_ack', (data) => { if(data.success) { clientState.playerBotId = null; clientState.playerOriginalBotId = null; playerInfoEl.textContent = 'Player Bot ID: None'; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); clientState.playerTarget = null; updateTargetIndicator(); statusEl.textContent = `Status: Left bot control.`; } else { alert(`Failed to leave: ${data.message}`); } updateButtonStates(); updateMobileControls(); });
                socket.on('player_joined', (data) => { console.log("Another player joined game:", data.player_id); updateInfoPanel(); updateButtonStates(); updateMobileControls(); });
                socket.on('player_left', (data) => { console.log("Another player left bot:", data.player_id); if (clientState.playerBotId === data.player_id) { clientState.playerBotId = null; clientState.playerOriginalBotId = null; playerInfoEl.textContent = 'Player Bot ID: None'; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); clientState.playerTarget = null; updateTargetIndicator(); } updateButtonStates(); updateMobileControls(); updateInfoPanel(); });
                console.log("Socket listeners setup complete.");
            } catch (e) { console.error("Socket.IO init failed:", e); connectionStatusEl.textContent = 'JS Error'; statusEl.textContent = "Status: Error initializing connection."; alert("Could not initialize connection."); }
        }

        // Client-Side Logic (No changes needed from previous version)
        function updateClientState(newState) {
             if(!newState) return;
             if (newState.environment) clientState.environment = newState.environment;
             if (newState.bots) {
                 clientState.bots = newState.bots;
                 if (clientState.playerBotId && clientState.bots[clientState.playerBotId]) {
                     clientState.playerTarget = clientState.bots[clientState.playerBotId].target_coord || null;
                 } else {
                     if (clientState.playerBotId) {
                         console.log("Player bot state lost or control revoked by server.");
                         clientState.playerBotId = null;
                         clientState.playerOriginalBotId = null;
                         localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER);
                         playerInfoEl.textContent = 'Player Bot ID: None';
                     }
                     clientState.playerTarget = null;
                 }
                 updateTargetIndicator();
             }
             if (newState.round !== undefined) clientState.round = newState.round;
             if (newState.stats) clientState.stats = newState.stats;
             if (newState.isRunning !== undefined) clientState.isRunning = newState.isRunning;
             if (newState.config) { serverConfig = copyConfig(newState.config); }
             updateButtonStates();
             updateMobileControls();
        }
        function updateInfoPanel() {
             roundInfoEl.textContent = `Round: ${clientState.round}`;
             document.getElementById('hc-total-goals').textContent = clientState.stats.hc_total_goals || 0;
             document.getElementById('learning-total-goals').textContent = clientState.stats.learning_total_goals || 0;
             let botCounts = { Hardcoded: 0, Learning: 0 }; let botInfoHTML = ''; let totalAnomaly = 0; let learningBotCount = 0;
             const sortedBotIds = Object.keys(clientState.bots || {}).sort((a, b) => { const typeA = clientState.bots[a]?.type || ''; const typeB = clientState.bots[b]?.type || ''; const isPlayerA = clientState.bots[a]?.is_player || false; const isPlayerB = clientState.bots[b]?.is_player || false; if(isPlayerA && !isPlayerB) return -1; if(!isPlayerA && isPlayerB) return 1; const typeOrder = { 'Learning': 1, 'Hardcoded': 2 }; if(typeOrder[typeA] !== typeOrder[typeB]) return (typeOrder[typeA] || 99) - (typeOrder[typeB] || 99); const numA = parseInt(a.match(/\d+/)?.[0] || '0'); const numB = parseInt(b.match(/\d+/)?.[0] || '0'); return numA - numB; });
             sortedBotIds.forEach(botId => { const bot = clientState.bots[botId]; if (!bot) return; const type = bot.type || 'Unknown'; let typeClass = ''; const isPlayerControlled = bot.is_player || false; if (type === 'Hardcoded') typeClass = 'hc-color'; else if (type === 'Learning') typeClass = isPlayerControlled ? 'pl-color' : 'ln-color'; if(type in botCounts) botCounts[type]++; const frozenStatus = bot.freezeTimer > 0 ? `<span class="frozen-status">Frozen (${bot.freezeTimer})</span>` : 'Active'; let anomalyText = ''; if (type === 'Learning' && bot.anomaly !== undefined && bot.anomaly !== null) { totalAnomaly += bot.anomaly; learningBotCount++; anomalyText = ` | Anomaly: ${bot.anomaly.toFixed(4)}`; } const playerMarker = isPlayerControlled ? '<span class="player-controlled-marker">(Player)</span>' : ''; botInfoHTML += `<div class="bot-type-info"><b><span class="${typeClass}">${type} ${bot.id}</span></b>${playerMarker} Pos: (${bot.pos?.x ?? '?', bot.pos?.y ?? '?'}) | Mode: ${bot.mode || 'N/A'} | Status: ${frozenStatus} | Goals: ${bot.goals_round || 0} ${anomalyText}</div>`; });
             const avgAnomaly = learningBotCount > 0 ? (totalAnomaly / learningBotCount).toFixed(4) : 'N/A';
             document.getElementById('learning-avg-anomaly').textContent = avgAnomaly; botsInfoContainerEl.innerHTML = botInfoHTML || '<div class="bot-type-info"><b>No bots found.</b></div>';
        }
        function updateButtonStates() {
             const connected = socket && socket.connected; const hasChanges = !!document.querySelector('.param-item.changed'); const canJoin = connected && Object.values(clientState.bots || {}).some(b => b.type === 'Learning' && !b.is_player); const isPlayer = clientState.playerBotId !== null;
             startButton.disabled = !connected || clientState.isRunning || clientState.needsFullReset || clientState.needsRoundReset || hasChanges;
             stopButton.disabled = !connected || !clientState.isRunning; resetRoundButton.disabled = !connected || clientState.isRunning; resetFullButton.disabled = !connected || clientState.isRunning; applyParamsButton.disabled = !connected || clientState.isRunning || !hasChanges;
             joinButton.disabled = !connected || isPlayer || !canJoin; joinButton.style.display = 'flex'; leaveButton.disabled = !connected || !isPlayer; leaveButton.style.display = isPlayer ? 'flex' : 'none';
             saveParamsButton.disabled = !connected; loadParamsButton.disabled = !connected || clientState.isRunning; resetParamsButton.disabled = !connected || clientState.isRunning;
             document.querySelectorAll('.param-item').forEach(item => { const key = item.dataset.param; const hintEl = item.querySelector('.reset-hint'); if (!hintEl) return; const rAllK = ['GRID_SIZE', 'NUM_HC_BOTS', 'NUM_LEARNING_BOTS', 'NUM_GOALS', 'LEARNING_BOT_DIM', 'LEARNING_BOT_MEM_DEPTH', 'LEARNING_BOT_LR', 'LEARNING_BOT_WEIGHT_DECAY', 'LEARNING_BOT_MOMENTUM', 'LEARNING_BOT_MAX_GRAD_NORM', 'ENABLE_AV', 'ENABLE_AV_OUTPUT', 'VISUALIZATION_MODE']; const rRndK = ['MAX_STEPS_PER_ROUND', 'VISIBILITY_RANGE', 'OBSTACLES_FACTOR_MIN', 'OBSTACLES_FACTOR_MAX', 'MIN_GOAL_START_DISTANCE_FACTOR', 'MIN_BOT_START_DISTANCE_FACTOR', 'MIN_BOT_GOAL_DISTANCE_FACTOR']; let needsReset = false; let resetText = ''; if (clientState.needsFullReset && rAllK.includes(key)) { needsReset = true; resetText = '(Reset All Req.)'; } else if (clientState.needsRoundReset && (rRndK.includes(key) || rAllK.includes(key))) { needsReset = true; resetText = '(Reset Req.)'; } item.classList.toggle('needs-reset', needsReset); hintEl.style.display = needsReset ? 'inline' : 'none'; hintEl.textContent = resetText; });
        }
        function updateMobileControls() { if (clientState.playerBotId && clientState.isRunning) mobileControlsEl.classList.add('enabled'); else mobileControlsEl.classList.remove('enabled'); }
        function disableAllControls() { startButton.disabled = true; stopButton.disabled = true; resetRoundButton.disabled = true; resetFullButton.disabled = true; applyParamsButton.disabled = true; joinButton.disabled = true; leaveButton.disabled = true; loadParamsButton.disabled = true; resetParamsButton.disabled = true; saveParamsButton.disabled = true; updateMobileControls(); }
        function copyConfig(configObj) { try { return JSON.parse(JSON.stringify(configObj || {})); } catch(e) { console.error("Failed to copy config", e); return {}; } }
        function updateUIFromConfig(configToUse) {
             console.log("Updating UI from config:", configToUse); if (!configToUse) return;
             for(const key in paramInputs) {
                 if (configToUse.hasOwnProperty(key)) {
                     const input = paramInputs[key]; let value = configToUse[key];
                     if (input.type === 'checkbox') { input.checked = Boolean(value); }
                     else if (input.type === 'range') { input.value = Number(value || 0); if (rangeValueDisplays[key]) rangeValueDisplays[key].textContent = `${input.value}%`; }
                     else if (input.tagName === 'SELECT') { input.value = String(value ?? ''); } // Handle select
                     else if (input.step && input.step.includes('.')) { const decimals = (input.step.split('.')[1] || '').length; if (decimals > 0) value = parseFloat(value || 0).toFixed(decimals); }
                     else { value = String(value ?? ''); }
                     if (input.type !== 'checkbox' && input.type !== 'range' && input.tagName !== 'SELECT') input.value = value;
                 } else console.warn(`Config key ${key} not found in received config.`);
             } markParamsApplied(); updateButtonStates(); updateMobileControls();
        }
        function getUIConfig() {
             const config = {}; const baseConfig = Object.keys(serverConfig).length > 0 ? serverConfig : uiDefaults;
             for(const key in paramInputs) {
                 const input = paramInputs[key]; let value; if (input.type === 'checkbox') { value = input.checked; } else { value = input.value; }
                 const defaultValue = baseConfig[key] ?? null; const defaultType = defaultValue !== null ? typeof defaultValue : (input.type === 'number' || input.type === 'range' ? 'number' : (input.tagName === 'SELECT' ? 'string' : 'string'));
                 try {
                     if (input.type !== 'checkbox' && value === '' && defaultValue !== null) { value = defaultValue; input.value = defaultValue; if (input.type === 'range' && rangeValueDisplays[key]) rangeValueDisplays[key].textContent = `${defaultValue}%`; }
                     if (defaultType === 'number' || input.type === 'range') { value = parseFloat(value); if (isNaN(value)) throw new Error("NaN"); if (input.min !== "" && value < parseFloat(input.min)) value = parseFloat(input.min); if (input.max !== "" && value > parseFloat(input.max)) value = parseFloat(input.max); if (input.step && !input.step.includes('.')) { value = Math.round(value); } else if (input.step && input.step.includes('.')) { const decimals = (input.step.split('.')[1] || '').length; if(decimals > 0) value = parseFloat(value.toFixed(decimals)); } }
                     else if (defaultType === 'boolean') { value = input.checked; }
                     else { value = String(value); } // Includes select values
                     config[key] = value;
                 } catch (e) { console.warn(`Error parsing UI value for ${key} ('${input.value}'), using default: ${defaultValue}`, e); config[key] = defaultValue; if (defaultValue !== null) { input.value = defaultValue; if (input.type === 'range' && rangeValueDisplays[key]) rangeValueDisplays[key].textContent = `${defaultValue}%`; } else input.value = ''; }
             } return config;
        }

        function markParamChanged(key) { if(clientState.isRunning) return; const paramItem = paramItems[key]; const input = paramInputs[key]; if (!paramItem || !input || !serverConfig) return; const uiConf = getUIConfig(); const uiValue = uiConf[key]; const serverValue = serverConfig[key]; let isDifferent = false; if (typeof uiValue === 'number' && typeof serverValue === 'number') { isDifferent = Math.abs(uiValue - serverValue) > 1e-9; } else { isDifferent = String(uiValue) !== String(serverValue); } if (isDifferent) { paramItem.classList.add('changed'); } else { paramItem.classList.remove('changed'); } updateButtonStates(); updateMobileControls(); }
        function markParamsApplied() { document.querySelectorAll('.param-item.changed').forEach(el => el.classList.remove('changed')); updateButtonStates(); updateMobileControls(); }
        function clearResetHints() { clientState.needsFullReset = false; clientState.needsRoundReset = false; updateButtonStates(); updateMobileControls(); }
        function checkForNeededResets() { if(clientState.isRunning) return; const uiConfig = getUIConfig(); let needsF = false; let needsR = false; const rAllK = ['GRID_SIZE', 'NUM_HC_BOTS', 'NUM_LEARNING_BOTS', 'NUM_GOALS', 'LEARNING_BOT_DIM', 'LEARNING_BOT_MEM_DEPTH', 'LEARNING_BOT_LR', 'LEARNING_BOT_WEIGHT_DECAY', 'LEARNING_BOT_MOMENTUM', 'LEARNING_BOT_MAX_GRAD_NORM', 'ENABLE_AV', 'ENABLE_AV_OUTPUT', 'VISUALIZATION_MODE']; const rRndK = ['MAX_STEPS_PER_ROUND', 'VISIBILITY_RANGE', 'OBSTACLES_FACTOR_MIN', 'OBSTACLES_FACTOR_MAX', 'MIN_GOAL_START_DISTANCE_FACTOR', 'MIN_BOT_START_DISTANCE_FACTOR', 'MIN_BOT_GOAL_DISTANCE_FACTOR']; let hasAnyChanges = false; for(const key in uiConfig) { if(serverConfig && serverConfig.hasOwnProperty(key)) { const uiVal = uiConfig[key]; const srvVal = serverConfig[key]; let different = false; if (typeof uiVal === 'number' && typeof srvVal === 'number') { different = Math.abs(uiVal - srvVal) > 1e-9; } else { different = String(uiVal) !== String(srvVal); } const item = paramItems[key]; if(different) { hasAnyChanges = true; if(item) item.classList.add('changed'); if (rAllK.includes(key)) needsF = true; else if (rRndK.includes(key)) needsR = true; } else { if(item) item.classList.remove('changed'); } } } clientState.needsFullReset = needsF; clientState.needsRoundReset = needsR || needsF; updateButtonStates(); updateMobileControls(); }
        function saveParamsToLocalStorage() { try { const uiConf = getUIConfig(); localStorage.setItem(LOCAL_STORAGE_KEY_UI, JSON.stringify(uiConf)); console.log('UI Params saved.'); alert('UI Parameters saved!'); } catch (e) { console.error('Failed to save UI params:', e); alert('Error saving UI parameters.'); } }
        function loadParamsFromLocalStorage() { if(clientState.isRunning) { alert("Stop simulation first."); return; } try { const saved = localStorage.getItem(LOCAL_STORAGE_KEY_UI); if (saved) { const parsed = JSON.parse(saved); updateUIFromConfig(parsed); markParamsApplied(); console.log('UI Params loaded.'); statusEl.textContent = "Status: UI Params Loaded. Apply or check resets."; checkForNeededResets(); alert('UI Parameters loaded. Review & Apply/Reset if needed.'); } else alert('No saved UI parameters found.'); } catch (e) { console.error('Failed to load UI params:', e); alert('Error loading UI parameters.'); } }
        function resetParamsToDefault() { if(clientState.isRunning) { alert("Stop simulation first."); return; } console.log("Resetting UI to defaults:", uiDefaults); const baseConfig = Object.keys(uiDefaults).length > 0 ? uiDefaults : copyConfig(DEFAULT_CONFIG); updateUIFromConfig(baseConfig); markParamsApplied(); statusEl.textContent = "Status: UI Reset to Default. Apply/Reset check."; checkForNeededResets(); }

        // --- Target Logic (No changes needed from previous version) ---
        function updateTargetIndicator() { if (clientState.playerTarget && clientState.playerBotId) { targetIndicatorEl.textContent = `Target: (${clientState.playerTarget.x}, ${clientState.playerTarget.y})`; targetIndicatorEl.style.display = 'block'; } else { targetIndicatorEl.textContent = 'Target: None'; targetIndicatorEl.style.display = 'none'; } }
        function sendTargetUpdate(targetCoord) { const now = Date.now(); if (isDragging && lastSentTargetTime && now - lastSentTargetTime < TARGET_UPDATE_INTERVAL_MS) return; if (socket && socket.connected && clientState.playerBotId) { const currentTarget = clientState.playerTarget; const changed = (targetCoord === null && currentTarget !== null) || (targetCoord !== null && currentTarget === null) || (targetCoord !== null && currentTarget !== null && (targetCoord.x !== currentTarget.x || targetCoord.y !== currentTarget.y)); if (changed) { socket.emit('update_player_target', { target: targetCoord }); clientState.playerTarget = targetCoord; updateTargetIndicator(); if (isDragging) lastSentTargetTime = now; } } }

        // --- Player Input (Tap/Click/Drag & Mobile Buttons) (No changes needed from previous version) ---
        function handleCanvasInteraction(event) {
            if (!socket || !socket.connected || !visualizer || !visualizer.cellSize) return; event.preventDefault(); const rect = canvas.getBoundingClientRect(); let clientX, clientY;
            if (event.type.startsWith('touch')) { if (event.type === 'touchend' && event.changedTouches.length > 0) { clientX = event.changedTouches[0].clientX; clientY = event.changedTouches[0].clientY; } else if (event.type === 'touchmove' && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else if (event.type === 'touchstart' && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else { return; }
            } else { clientX = event.clientX; clientY = event.clientY; }
            const canvasX = clientX - rect.left; const canvasY = clientY - rect.top; const targetGridX = Math.floor(canvasX / visualizer.cellSize); const targetGridY = Math.floor(canvasY / visualizer.cellSize);
            if (targetGridX < 0 || targetGridX >= visualizer.gridSize || targetGridY < 0 || targetGridY >= visualizer.gridSize) { if (isDragging) isDragging = false; return; }

            if (clientState.playerBotId) {
                const playerBot = clientState.bots[clientState.playerBotId];
                if (!playerBot) { clientState.playerBotId = null; clientState.playerOriginalBotId = null; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); return; }
                if (targetGridX === playerBot.pos.x && targetGridY === playerBot.pos.y && (event.type === 'mouseup' || event.type === 'touchend')) { sendTargetUpdate(null); } else { sendTargetUpdate({ x: targetGridX, y: targetGridY }); }
            } else {
                if (event.type === 'mouseup' || event.type === 'touchend') {
                    const clickedBot = visualizer.getBotAtCoord(targetGridX, targetGridY);
                    if (clickedBot && clickedBot.type === 'Learning' && !clickedBot.is_player) { console.log(`Attempting join via click: ${clickedBot.id}`); socket.emit('join_game', { target_bot_id: clickedBot.id }); }
                }
            }
        }
        canvas.addEventListener('mousedown', (e) => { isDragging = true; handleCanvasInteraction(e); }); canvas.addEventListener('mousemove', (e) => { if (isDragging) { handleCanvasInteraction(e); } }); canvas.addEventListener('mouseup', (e) => { handleCanvasInteraction(e); isDragging = false; }); canvas.addEventListener('mouseleave', () => { isDragging = false; }); canvas.addEventListener('touchstart', (e) => { isDragging = true; handleCanvasInteraction(e); }, { passive: false }); canvas.addEventListener('touchmove', (e) => { if (isDragging) { handleCanvasInteraction(e); } }, { passive: false }); canvas.addEventListener('touchend', (e) => { handleCanvasInteraction(e); isDragging = false; }, { passive: false }); canvas.addEventListener('touchcancel', () => { isDragging = false; });

        const addMobileButtonListener = (button, actionCode) => { if (button) { const sendAction = (e) => { if(!mobileControlsEl.classList.contains('enabled')) return; e.preventDefault(); sendPlayerAction(actionCode); }; button.addEventListener('touchstart', sendAction, { passive: false }); button.addEventListener('click', sendAction); } };
        function sendPlayerAction(actionCode) { if (clientState.playerBotId && clientState.isRunning && socket && socket.connected) { socket.emit('player_action', { action: actionCode }); } }
        addMobileButtonListener(mobileUp, 0); addMobileButtonListener(mobileLeft, 1); addMobileButtonListener(mobileRight, 2); addMobileButtonListener(mobileDown, 3); addMobileButtonListener(mobilePunch, 4); addMobileButtonListener(mobileClaim, 5);

        // --- Add Button Event Listeners (No changes needed from previous version) ---
        function setupButtonListeners() {
            startButton.addEventListener('click', () => { if (!startButton.disabled) socket.emit('start_simulation'); });
            stopButton.addEventListener('click', () => { if (!stopButton.disabled) socket.emit('stop_simulation'); });
            resetRoundButton.addEventListener('click', () => { if (!resetRoundButton.disabled) socket.emit('reset_round'); });
            resetFullButton.addEventListener('click', () => { if (!resetFullButton.disabled) socket.emit('reset_full'); });
            applyParamsButton.addEventListener('click', () => { if (!applyParamsButton.disabled) { const configToSend = getUIConfig(); socket.emit('update_config', { config: configToSend }); } });
            saveParamsButton.addEventListener('click', () => { if (!saveParamsButton.disabled) saveParamsToLocalStorage(); });
            loadParamsButton.addEventListener('click', () => { if (!loadParamsButton.disabled) loadParamsFromLocalStorage(); });
            resetParamsButton.addEventListener('click', () => { if (!resetParamsButton.disabled) resetParamsToDefault(); });
            joinButton.addEventListener('click', () => { if (!joinButton.disabled) socket.emit('join_game'); });
            leaveButton.addEventListener('click', () => { if (!leaveButton.disabled) socket.emit('leave_game'); });
            console.log("UI Button listeners attached.");
        }

        // --- Initial Load and Resize ---
        window.addEventListener('load', () => { console.log("Client Initializing..."); disableAllControls(); setupSocket(); setupButtonListeners(); });
        let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if (visualizer && clientState.environment) { try { visualizer.updateGridDimensions(clientState.environment.size); visualizer.update(clientState); } catch(e){ console.error("Resize error:", e); } } }, 150); });

    </script>
</body>
</html>
```
--- END OF MODIFIED FILE `index.html` ---

**Summary of Key Changes:**

1.  **`audiovisualization.py`:**
    *   **Multiprocessing for Visuals:** Changed `_vispy_thread_target` to `_vispy_process_target` and now launch it using `multiprocessing.Process`. This isolates the VisPy event loop (`vispy.app.run()`) completely from the main server process and its Eventlet patching, preventing the blocking issue.
    *   **Data Queue:** Uses `multiprocessing.Queue` for safe data transfer between the main server process and the visualization process.
    *   **Data Preparation:** Added `_prepare_data_for_visual_queue` to convert PyTorch tensors (potentially on GPU) to CPU NumPy arrays or basic Python types before putting them into the queue. This is necessary because tensors and GPU data cannot be directly pickled/shared between processes.
    *   **Stop Event:** Uses `multiprocessing.Event` to signal the visualization process to stop gracefully.
    *   **Matplotlib Alternative:** Added a placeholder function `_matplotlib_process_target` and basic structure showing how Matplotlib's `FuncAnimation` could be run in a separate process similarly to VisPy.
    *   **Web Alternative:** Added `_prepare_data_for_web` and logic in `update` to emit data via SocketIO if `visualization_mode` is 'web'. Requires `set_socketio_instance` to be called.
    *   **Mode Selection:** The `AVManager` constructor now takes `visualization_mode` and conditionally starts the appropriate process or sets up for web streaming.
    *   **Error Handling:** Improved error handling around queue operations and process management.
    *   **Platform Check:** Added a basic check for MacOS at the end, as `multiprocessing` with GUI libraries can sometimes require specific backends or have issues on that platform.

2.  **`server.py`:**
    *   **Import `multiprocessing`:** Added the import.
    *   **Multiprocessing Start Method:** Added logic (especially for Mac/Windows) to potentially set the multiprocessing start method to `'spawn'` *before* initializing CUDA or using multiprocessing features. This is crucial for compatibility with CUDA and some GUI libraries in separate processes. (Note: Kept the actual forcing commented out initially for broader compatibility, but the check is there).
    *   **Configuration:** Added `VISUALIZATION_MODE` to `DEFAULT_CONFIG` and the UI update logic (`handle_update_config`).
    *   **AV Setup:** Modified `update_av_manager_instance` and `setup_simulation` to pass the `visualization_mode` and the `socketio` instance (if mode is 'web') to `setup_av_system`.
    *   **Web Visualizer Route/Namespace:** Added a basic Flask route (`/visuals`) and a SocketIO namespace (`/visuals`) as placeholders for a potential web-based visualization client.
    *   **Server Start:** Explicitly uses `eventlet.wsgi.server` which might offer slightly better control than `socketio.run` in some complex scenarios.
    *   **Shutdown:** Ensures the AV manager (and its process) is stopped during server shutdown.

3.  **`index.html`:**
    *   **Visualization Mode Selector:** Added a `<select>` dropdown in the parameters section to allow the user to choose the `VISUALIZATION_MODE` ('vispy', 'matplotlib', 'web', 'none').
    *   **JavaScript Updates:** Updated the JavaScript functions (`updateUIFromConfig`, `getUIConfig`, `checkForNeededResets`, etc.) to handle the new `select` element for the visualization mode.
    *   **Version Bump:** Updated title and local storage keys to reflect changes.

**How it Fixes the Blocking Issue:**

By running VisPy (or Matplotlib) in a completely separate *process* using `multiprocessing`, its event loop (`vispy.app.run()` or `plt.show()`) runs independently of the main server process where Flask, SocketIO, Eventlet, and the simulation loop reside. Communication happens via a dedicated `multiprocessing.Queue`, which is designed for inter-process communication. This prevents the GUI event loop from blocking the simulation.

**To Use the Alternatives:**

1.  **Matplotlib:** Install `matplotlib`. Select "Matplotlib" in the UI. The basic structure is there, but the `process_data_for_matplotlib` function needs to be fully implemented to map bot data to visual properties correctly.
2.  **Web:** Select "Web" in the UI. Open `http://<your-server-ip>:5001/visuals` in a separate browser tab. You would need to build the actual JavaScript client on that page using a library like Plotly.js or Three.js to receive data from the `/visuals` SocketIO namespace and render it. The server now streams the prepared data.
