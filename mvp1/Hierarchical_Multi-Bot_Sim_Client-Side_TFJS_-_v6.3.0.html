<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hierarchical Multi-Bot Sim (Client-Side TFJS) - v6.3.0 Enhanced HNM</title>
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        :root {
             --bg-color: #f0f2f5;
             --container-bg: #ffffff;
             --border-color: #d9d9d9;
             --text-color: #333;
             --primary-color: #1890ff; /* Ant Design Blue */
             --primary-hover: #40a9ff;
             --secondary-color: #faad14; /* Ant Design Orange */
             --secondary-hover: #ffc53d;
             --danger-color: #f5222d; /* Ant Design Red */
             --danger-hover: #ff4d4f;
             --success-color: #52c41a; /* Ant Design Green */
             --success-hover: #73d13d;
             --info-color: #13c2c2; /* Ant Design Cyan */
             --info-hover: #36cfc9;
             --warn-color: #fa8c16;
             --frozen-color: #40a9ff;
             --hallucinating-color: #722ed1; /* Purple for hallucination */
             --param-label-color: #0050b3;
             --player-color: var(--success-color);
             --player-controlled-color: var(--success-color);
             --hardcoded-color: var(--primary-color);
             --learning-color: var(--danger-color);
             --learning-available-color: #ff7a45;
             --mobile-button-bg: #f0f0f0;
             --mobile-button-border: #ccc;
             --mobile-button-active-bg: #e0e0e0;
             --target-indicator-bg: rgba(255, 255, 0, 0.7);
             --target-crosshair-color: rgba(255, 0, 0, 0.7);
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow-x: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; display: flex; flex-direction: column; align-items: center; padding: 10px; box-sizing: border-box; line-height: 1.5; background-color: var(--bg-color); color: var(--text-color); -webkit-tap-highlight-color: transparent; }
        canvas { border: 1px solid var(--border-color); margin-bottom: 10px; display: block; max-width: 100%; height: auto; touch-action: manipulation; background-color: var(--container-bg); cursor: crosshair; image-rendering: pixelated; }
        .main-container { display: flex; flex-direction: row; flex-wrap: wrap; align-items: flex-start; width: 100%; max-width: 1700px; justify-content: center; gap: 25px; padding-bottom: 150px; }
        .grid-container { flex-basis: 600px; flex-grow: 1; max-width: 800px; min-width: 300px; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; }
        .controls-and-info { display: flex; flex-direction: column; flex-basis: 480px; flex-grow: 1; min-width: 320px; max-width: 700px; background-color: var(--container-bg); padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .simulation-controls, .param-controls, .player-controls { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; align-items: center; }
        button { padding: 8px 14px; cursor: pointer; border: none; border-radius: 5px; font-size: 0.9em; font-weight: 500; transition: background-color 0.2s ease, box-shadow 0.2s ease; }
        button:hover:not(:disabled) { box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button:active:not(:disabled) { transform: translateY(1px); box-shadow: none; }
        button:disabled { background-color: #bdc3c7 !important; cursor: not-allowed; opacity: 0.6; box-shadow: none; }
        #startButton { background-color: var(--success-color); color: white; }
        #startButton:hover:not(:disabled) { background-color: var(--success-hover); }
        #stopButton { background-color: var(--danger-color); color: white; }
        #stopButton:hover:not(:disabled) { background-color: var(--danger-hover); }
        #resetRoundButton, #resetFullButton { background-color: var(--secondary-color); color: white; }
        #resetRoundButton:hover:not(:disabled), #resetFullButton:hover:not(:disabled) { background-color: var(--secondary-hover); }
        #applyParamsButton { background-color: #722ed1; color: white; }
        #applyParamsButton:hover:not(:disabled) { background-color: #9254de; }
        #saveParamsButton, #loadParamsButton, #resetParamsButton { background-color: var(--info-color); font-size: 0.85em; padding: 6px 10px; color: white;}
        #saveParamsButton:hover:not(:disabled), #loadParamsButton:hover:not(:disabled), #resetParamsButton:hover:not(:disabled) { background-color: var(--info-hover); }
        #joinButton { background-color: var(--primary-color); color: white; margin-left: auto; }
        #leaveButton { background-color: var(--warn-color); color: white; margin-left: auto; display: none; }
        #leaveButton:hover:not(:disabled) { background-color: #ffc53d; }
        .parameters { border: 1px solid #eee; padding: 15px; margin-bottom: 15px; background-color: #fdfdfd; border-radius: 5px; max-height: 45vh; overflow-y: auto;}
        .parameters h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.1em; border-bottom: 1px solid #eee; padding-bottom: 8px; color: #444; }
        .parameters div.param-item { margin-bottom: 10px; display: flex; flex-wrap: wrap; align-items: center; gap: 5px 10px; font-size: 0.88em; }
        .parameters label { display: inline-block; min-width: 160px; font-weight: 500; flex-shrink: 0; color: #555; }
        .parameters input[type=number], .parameters input[type=text], .parameters input[type=checkbox], .parameters select, .parameters textarea { padding: 5px 7px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1em; background-color: #fff; }
        .parameters input[type=number], .parameters input[type=text], .parameters select { width: 100px; }
        .parameters textarea { width: calc(100% - 170px); min-height: 60px; font-family: monospace; font-size:0.9em; }
        .parameters input[type=range] { flex-grow: 1; cursor: pointer; }
        .parameters .range-value { font-weight: bold; min-width: 40px; text-align: right; }
        .parameters input[type=checkbox] { width: auto; margin-left: 5px; transform: scale(1.1); }
        .parameters .tooltip { display: inline-block; background-color: #bfbfbf; border-radius: 50%; width: 16px; height: 16px; text-align: center; line-height: 16px; font-size: 11px; color: white; font-weight: bold; vertical-align: middle; cursor: help; position: relative; margin-left: 3px; }
        .parameters .reset-hint { font-style: italic; font-size: 0.85em; color: var(--warn-color); margin-left: 6px; display: none; white-space: nowrap; font-weight: 500; }
        .parameters div.param-item.changed label { color: var(--warn-color); font-weight: bold;}
        .parameters div.param-item.needs-reset .reset-hint { display: inline !important; }
        .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: rgba(0,0,0,0.8); color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 10; bottom: 130%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 0.85em; font-weight: normal; line-height: 1.3; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .tooltip:hover .tooltiptext, .tooltip:focus .tooltiptext, .tooltip:active .tooltiptext { visibility: visible; opacity: 1; }
        .info { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .bot-type-info { border: 1px solid #e8e8e8; padding: 10px; font-size: 0.88em; background-color: #fafafa; border-radius: 5px; }
        .bot-type-info b { display: block; margin-bottom: 4px; font-size: 1.05em; }
        .stats { margin-top: 15px; font-weight: bold; padding: 12px; background-color: #e6f7ff; border: 1px solid #bae7ff; border-radius: 5px; font-size: 0.95em; line-height: 1.5; }
        .status-tag { font-weight: bold; border: 1px dashed; padding: 1px 4px; border-radius: 4px; display: inline-block; font-size: 0.8em; margin-left: 4px; }
        .frozen-status { color: var(--frozen-color); border-color: var(--frozen-color); background-color: #e6f7ff; }
        .hallucinating-status { color: var(--hallucinating-color); border-color: var(--hallucinating-color); background-color: #f9f0ff; }
        hr { width: 100%; margin: 20px 0; border: 0; border-top: 1px solid #e8e8e8; }
        .library-param-label { font-weight: bold; color: var(--param-label-color); }
        .param-group { border: 1px dashed #e0e0e0; padding: 12px; margin-bottom: 12px; border-radius: 4px; background-color: #fdfdfd;}
        .param-group h4 { margin-top: 0; margin-bottom: 10px; font-size: 1em; color: #666; }
        #status, #round-info, #player-info { margin-top: 8px; font-weight: bold; }
        #status { font-size: 1.05em; color: #333; min-height: 1.4em; }
        #round-info { font-size: 0.95em; color: #555;}
        #player-info { font-size: 0.9em; color: var(--player-color); margin-bottom: 8px; }
        #connection-status { display: none; } /* Removed, client-side only */
        .hc-color { color: var(--hardcoded-color); font-weight: bold;}
        .ln-color { color: var(--learning-color); font-weight: bold;}
        .pl-color { color: var(--player-color); font-weight: bold;}
        .player-controlled-marker { font-weight: bold; color: var(--player-controlled-color); margin-left: 5px; font-size: 0.9em; }
        .learning-available-marker { outline: 2px dashed var(--learning-available-color); outline-offset: 2px; cursor: pointer; }
        #target-indicator { position: fixed; top: 5px; left: 8px; font-size: 0.85em; padding: 4px 8px; border-radius: 4px; background-color: var(--target-indicator-bg); color: #333; font-weight: bold; z-index: 1000; box-shadow: 0 1px 3px rgba(0,0,0,0.2); display: none; }
        #mobile-controls { position: fixed; bottom: 0; left: 0; width: 100%; background-color: rgba(230, 230, 230, 0.9); padding: 8px 3px; box-sizing: border-box; display: none; flex-direction: row; justify-content: space-around; align-items: center; z-index: 900; border-top: 1px solid var(--border-color); box-shadow: 0 -2px 5px rgba(0,0,0,0.1); touch-action: manipulation; -webkit-user-select: none; user-select: none; pointer-events: none; opacity: 0.7; }
        #mobile-controls.enabled { pointer-events: auto; opacity: 1.0; }
        #mobile-controls button { font-size: 16px; padding: 10px 8px; min-width: 50px; text-align: center; background-color: var(--mobile-button-bg); border: 1px solid var(--mobile-button-border); border-radius: 8px; font-weight: bold; color: var(--text-color); flex-grow: 1; margin: 0 2px; }
        #mobile-controls.enabled button:active { background-color: var(--mobile-button-active-bg); transform: scale(0.95); }
        @media (max-width: 768px) { #mobile-controls { display: flex; } .main-container { padding-bottom: 80px; } .grid-container { min-width: unset; width: 100%; max-width: 100%; flex-basis: auto; } .controls-and-info { min-width: unset; width: 100%; max-width: 100%; flex-basis: auto; margin-top:15px; } .parameters label { min-width: 160px; } .parameters { max-height: 35vh; } .desktop-only { display: none; } }
        @media (min-width: 769px) { #mobile-controls { display: none; } }
        .tfjs-info-panel { background-color: #e6f7ff; padding: 10px; border-radius: 4px; margin:10px; width:320px; display: flex; flex-direction: column; border: 1px solid #bae7ff;}
        .tfjs-info-panel h3 { margin-top: 0; font-size: 1.1em; color: #0050b3; border-bottom: 1px solid #91d5ff; padding-bottom: 5px;}
        .tfjs-info { font-size: 0.85em; line-height: 1.5; color: #003a75;}
        .log-area { width: 95%; max-width: 1200px; height: 150px; border: 1px solid #ccc; overflow-y: scroll; padding: 8px; font-size: 0.75em; margin-top:10px; white-space: pre-wrap; background-color: #fff; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>Hierarchical Multi-Bot Sim (Client-Side TFJS) - v6.3.0 Enhanced HNM</h1>
    <p style="max-width: 900px; text-align: center; margin-bottom: 15px; font-size: 0.95em;">
        Bots navigate, claim goals, punch opponents, or use mental attacks. Tap/Click grid to set target for player bot. Tap self to cancel.
        <span class="ln-color">Learning Bots (Red)</span> use client-side TensorFlow.js Hierarchical Neural Memory.
        <span class="hc-color">Hardcoded Bots (Blue)</span> use rules.
        <span class="pl-color">Players (Green)</span> control a Learning Bot. Click <span style="color: var(--learning-available-color); font-weight:bold;">Available Learning Bot</span> or "Join Game" button.
    </p>
    <p style="font-size:0.85em; color: var(--danger-color);"><i>Simulation runs entirely in your browser using TensorFlow.js. Performance depends on your CPU/GPU. Advanced AV/EEG features from server version are removed.</i></p>
    <div id="target-indicator">Target: None</div>

    <div class="main-container">
        <div class="grid-container">
            <canvas id="gridCanvas" width="600" height="600"></canvas>
             <div id="player-info">Player Bot ID: None</div>
             <p style="font-size: 0.85em; margin-top: 5px;" class="desktop-only">Controls: Click/Drag on grid to set target. Click self to cancel. Click available Learning Bot or Join button.</p>
        </div>

        <div class="controls-and-info">
             <div class="simulation-controls">
                <button id="startButton" title="Start Simulation">Start</button>
                <button id="stopButton" disabled title="Stop Simulation">Stop</button>
                <button id="resetRoundButton" title="Start a New Round (May use new env)">New Round</button>
                <button id="resetFullButton" title="Reset Environment and Learning State">Reset All</button>
                 <button id="joinButton" title="Join as Player (Controls first available Learning Bot)">Join Game</button>
                 <button id="leaveButton" title="Relinquish Control of Bot" disabled>Leave Bot</button>
             </div>
                 <div id="status" style="margin-bottom: 5px;">Status: Initializing...</div>
                 <div id="round-info" style="margin-bottom: 15px;">Round: 0</div>
            <hr>
            <div class="parameters">
                 <h3>Simulation Parameters</h3>
                 <div class="param-group">
                      <h4>General</h4>
                     <div data-param="SIMULATION_SPEED_MS" class="param-item">
                         <label for="param-SIMULATION_SPEED_MS">Sim Speed (ms delay):</label>
                         <input type="number" id="param-SIMULATION_SPEED_MS" name="SIMULATION_SPEED_MS" min="1" max="1000" step="10">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Target delay between client steps. Lower is faster. (Applied on Apply or Reset)</span></span>
                         <span class="reset-hint"></span>
                     </div>
                     <div data-param="FREEZE_DURATION" class="param-item">
                         <label for="param-FREEZE_DURATION">Punch Freeze (steps):</label>
                         <input type="number" id="param-FREEZE_DURATION" name="FREEZE_DURATION" min="1" max="100">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Steps bots stay frozen after punch. (Applied on Apply or Reset)</span></span>
                          <span class="reset-hint"></span>
                     </div>
                     <div data-param="MENTAL_ATTACK_RANGE" class="param-item needs-reset">
                        <label for="param-MENTAL_ATTACK_RANGE">Mental Attack Range:</label>
                        <input type="number" id="param-MENTAL_ATTACK_RANGE" name="MENTAL_ATTACK_RANGE" min="1" max="50">
                        <span class="tooltip" tabindex="0">?<span class="tooltiptext">Range of mental attack. (NewRound Req.)</span></span>
                        <span class="reset-hint">(Reset Req.)</span>
                    </div>
                    <div data-param="MENTAL_ATTACK_DURATION" class="param-item needs-reset">
                        <label for="param-MENTAL_ATTACK_DURATION">Mental Attack Duration:</label>
                        <input type="number" id="param-MENTAL_ATTACK_DURATION" name="MENTAL_ATTACK_DURATION" min="1" max="500">
                        <span class="tooltip" tabindex="0">?<span class="tooltiptext">Duration of mental attack effect. (NewRound Req.)</span></span>
                        <span class="reset-hint">(Reset Req.)</span>
                    </div>
                     <div data-param="NUM_ACTIONS" class="param-item needs-reset">
                        <label for="param-NUM_ACTIONS">Number of Actions:</label>
                        <input type="number" id="param-NUM_ACTIONS" name="NUM_ACTIONS" min="4" max="10" readonly>
                        <span class="tooltip" tabindex="0">?<span class="tooltiptext">Total actions available (Up,Down,L,R,Punch,Claim,MAtt). (ResetAll Req. Readonly in UI).</span></span>
                        <span class="reset-hint">(Reset Req.)</span>
                    </div>
                 </div>

                 <div class="param-group">
                     <h4>Environment (Require Reset)</h4>
                     <div data-param="GRID_SIZE" class="param-item needs-reset">
                         <label for="param-GRID_SIZE">Grid Size:</label>
                         <input type="number" id="param-GRID_SIZE" name="GRID_SIZE" min="10" max="200">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Width/Height of the grid. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="NUM_GOALS" class="param-item needs-reset">
                         <label for="param-NUM_GOALS">Num Goals:</label>
                         <input type="number" id="param-NUM_GOALS" name="NUM_GOALS" min="0" max="500">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of goals per round. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="NUM_HC_BOTS" class="param-item needs-reset">
                         <label for="param-NUM_HC_BOTS">Num Hardcoded Bots:</label>
                         <input type="number" id="param-NUM_HC_BOTS" name="NUM_HC_BOTS" min="0" max="100">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of blue (rule-based) bots. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="NUM_LEARNING_BOTS" class="param-item needs-reset">
                         <label for="param-NUM_LEARNING_BOTS">Num Learning Bots:</label>
                         <input type="number" id="param-NUM_LEARNING_BOTS" name="NUM_LEARNING_BOTS" min="0" max="100">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of red (TFJS learning) bots. Player takes over one of these. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                     </div>
                      <div data-param="MAX_STEPS_PER_ROUND" class="param-item needs-reset">
                         <label for="param-MAX_STEPS_PER_ROUND">Max Steps/Round:</label>
                         <input type="number" id="param-MAX_STEPS_PER_ROUND" name="MAX_STEPS_PER_ROUND" min="100" max="10000">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">Max steps per bot before round ends. (Req. New Round)</span></span>
                          <span class="reset-hint">(Reset Req.)</span>
                     </div>
                     <div data-param="VISIBILITY_RANGE" class="param-item needs-reset">
                         <label for="param-VISIBILITY_RANGE">Sense Visibility Range:</label>
                         <input type="number" id="param-VISIBILITY_RANGE" name="VISIBILITY_RANGE" min="2" max="50">
                          <span class="tooltip" tabindex="0">?<span class="tooltiptext">How far bots 'see' (Manhattan dist). Affects input stream size/content. (Req. New Round)</span></span>
                          <span class="reset-hint">(Reset Req.)</span>
                     </div>
                      <div data-param="RANDOMIZE_ENV_PER_ROUND" class="param-item">
                         <label for="param-RANDOMIZE_ENV_PER_ROUND">New Env Each Round:</label>
                         <input type="checkbox" id="param-RANDOMIZE_ENV_PER_ROUND" name="RANDOMIZE_ENV_PER_ROUND">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">If checked, 'New Round' generates a new obstacle/goal layout. If unchecked, it resets goals on the same layout. (Applied on Apply or Reset)</span></span>
                         <span class="reset-hint"></span>
                     </div>
                 </div>

                 <div class="param-group">
                     <h4>Learning Bot (TFJS Hierarchical Memory - Require Reset All)</h4>
                      <div data-param="SENSORY_INPUT_DIM" class="param-item needs-reset">
                         <label class="library-param-label" for="param-SENSORY_INPUT_DIM">Sensory Input Dim (L0):</label>
                         <input type="number" id="param-SENSORY_INPUT_DIM" name="SENSORY_INPUT_DIM" min="10" max="64">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Dimension of the raw sensory input vector for L0. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                      </div>
                      <div data-param="HIERARCHY_LEVEL_CONFIGS" class="param-item needs-reset">
                         <label class="library-param-label" for="param-HIERARCHY_LEVEL_CONFIGS">Hierarchy Config (JSON):</label>
                         <textarea id="param-HIERARCHY_LEVEL_CONFIGS" name="HIERARCHY_LEVEL_CONFIGS" rows="6"></textarea>
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">JSON array defining HNM levels (name, dim, bu_sources, td_sources, nmm_params, external_input_config). (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                      </div>
                      <div data-param="POLICY_HEAD_INPUT_LEVEL_NAME" class="param-item needs-reset">
                         <label class="library-param-label" for="param-POLICY_HEAD_INPUT_LEVEL_NAME">Policy Head Input Level:</label>
                         <input type="text" id="param-POLICY_HEAD_INPUT_LEVEL_NAME" name="POLICY_HEAD_INPUT_LEVEL_NAME">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Name of the HNM level whose output feeds the policy head. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                      </div>
                      <div data-param="USE_RULES_AS_HNS_INPUT" class="param-item needs-reset">
                         <label class="library-param-label" for="param-USE_RULES_AS_HNS_INPUT">Feed Rules to HNS L0:</label>
                         <input type="checkbox" id="param-USE_RULES_AS_HNS_INPUT" name="USE_RULES_AS_HNS_INPUT">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Provide hardcoded action suggestion as part of L0's external input. (Req. Reset All)</span></span>
                         <span class="reset-hint">(Reset Req.)</span>
                      </div>
                 </div>
                  <div class="param-group">
                     <h4>Learning Bot Behavior (Apply Req.)</h4>
                     <div data-param="LEARNING_BOT_BASE_EXPLORATION_RATE" class="param-item">
                         <label for="param-LEARNING_BOT_BASE_EXPLORATION_RATE">Base Explore Rate (%):</label>
                         <input type="number" id="param-LEARNING_BOT_BASE_EXPLORATION_RATE" name="LEARNING_BOT_BASE_EXPLORATION_RATE" min="0" max="100" step="1">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Base chance (%) Learning Bot explores instead of exploiting memory. Rate increases with anomaly. (Applied on Apply or Reset)</span></span>
                           <span class="reset-hint"></span>
                     </div>
                      <div data-param="LEARNING_BOT_RULE_EXPLORE_PERCENT" class="param-item">
                         <label for="param-LEARNING_BOT_RULE_EXPLORE_PERCENT">Rule Exploration (%):</label>
                         <input type="number" id="param-LEARNING_BOT_RULE_EXPLORE_PERCENT" name="LEARNING_BOT_RULE_EXPLORE_PERCENT" min="0" max="100" step="1">
                         <span class="tooltip" tabindex="0">?<span class="tooltiptext">Of the exploration actions, percentage (%) that use rule-based logic vs random. (Applied on Apply or Reset)</span></span>
                           <span class="reset-hint"></span>
                     </div>
                     <div data-param="PLAYER_CONTROL_PERCENT" class="param-item">
                        <label for="param-PLAYER_CONTROL_PERCENT">Player Control Influence (%):</label>
                        <input type="range" id="param-PLAYER_CONTROL_PERCENT" name="PLAYER_CONTROL_PERCENT" min="0" max="100" step="1">
                        <span class="range-value" id="value-PLAYER_CONTROL_PERCENT">100%</span>
                        <span class="tooltip" tabindex="0">?<span class="tooltiptext">How much player input overrides AI prediction (0% = full AI, 100% = full Player). Blends probabilistically. (Applied on Apply or Reset)</span></span>
                        <span class="reset-hint"></span>
                    </div>
                    <div data-param="MENTAL_ATTACK_USES_RECONSTRUCTION" class="param-item">
                        <label for="param-MENTAL_ATTACK_USES_RECONSTRUCTION">Hallucinate via Reconstruction:</label>
                        <input type="checkbox" id="param-MENTAL_ATTACK_USES_RECONSTRUCTION" name="MENTAL_ATTACK_USES_RECONSTRUCTION">
                        <span class="tooltip" tabindex="0">?<span class="tooltiptext">If true, mental attack uses L0 reconstruction as senses. (Apply)</span></span>
                        <span class="reset-hint"></span>
                    </div>
                 </div>

                 <hr>
                 <div class="param-controls">
                    <button id="applyParamsButton" title="Apply Changed Parameters (may require reset)">Apply Changes</button>
                    <button id="saveParamsButton" title="Save Current UI Parameters to Browser Storage">Save Params</button>
                    <button id="loadParamsButton" title="Load Parameters from Browser Storage">Load Params</button>
                    <button id="resetParamsButton" title="Reset UI Parameters to Default Values">Reset UI to Default</button>
                 </div>
            </div>

             <div class="stats">
                Goals Claimed (Total):<br>
                <span class="hc-color">Hardcoded:</span> <span id="hc-total-goals">0</span> |
                <span class="ln-color">Learning</span>/<span class="pl-color">Player:</span> <span id="learning-total-goals">0</span><br>
                Avg Bot Anomaly (Learning): <span id="learning-avg-anomaly">N/A</span> (Sum of all level anomalies)
            </div>

            <div class="info">
                <div id="bots-info-container" style="max-height: 250px; overflow-y: auto; border: 1px solid #f0f0f0; padding: 5px; background: #fff;">
                     <div class="bot-type-info"><b>Bots Information Loading...</b></div>
                </div>
            </div>
        </div>
        <div class="tfjs-info-panel">
            <h3>TFJS Info</h3>
            <div class="tfjs-info">
                Backend: <span id="tfBackend"></span><br>
                Memory (Bytes): <span id="tfMemoryBytes"></span><br>
                Num Tensors: <span id="tfNumTensors"></span><br>
                Num Data Buffers: <span id="tfNumDataBuffers"></span>
            </div>
        </div>
    </div>
    <div class="log-area" id="logArea"><strong>Log:</strong><br></div>

    <div id="mobile-controls">
        <button id="btn-up">▲</button> <!-- Action 0 -->
        <button id="btn-down">▼</button> <!-- Action 1 -->
        <button id="btn-left">◀</button> <!-- Action 2 -->
        <button id="btn-right">▶</button> <!-- Action 3 -->
        <button id="btn-punch">Punch</button> <!-- Action 4 -->
        <button id="btn-claim">Claim</button> <!-- Action 5 -->
        <button id="btn-mental-attack">MAtt</button> <!-- Action 6 -->
    </div>

<script type="module">
    // =================================================================================
    // --- Client-Side JavaScript (TFJS Hierarchical) v6.3.0 Enhanced HNM ---
    // =================================================================================
    
    const logArea = document.getElementById('logArea');
    function logMessage(message, level = "info") {
        console[level](message); // Keep console logging
        const time = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.textContent = `[${time}] ${message}`;
        if (level === "error") logEntry.style.color = 'red';
        if (level === "warn") logEntry.style.color = 'orange';

        const titleNode = logArea.firstChild; // Keep "Log:" title
        if (titleNode && titleNode.nextSibling) {
            logArea.insertBefore(logEntry, titleNode.nextSibling);
        } else {
            logArea.appendChild(logEntry);
        }
        while (logArea.childElementCount > 201) { 
            logArea.removeChild(logArea.lastChild);
        }
    }

    class MemoryMLP_TFJS {
        constructor(inputDim, depth, expansionOrTargetDim, namePrefix = '', activation = 'elu') {
            this.inputDim = inputDim;
            this.depth = depth;
            this.namePrefix = namePrefix;
            this.model = null;
            this.isDisposed = false;

            if (depth < 1) { this.isIdentity = true; return; }
            this.isIdentity = false;

            const layers = [];
            let currentLayerInputShape = [this.inputDim];

            for (let i = 0; i < depth; i++) {
                const isLast = i === (depth - 1);
                let currentLayerOutputUnits;

                if (depth === 1) { currentLayerOutputUnits = expansionOrTargetDim; } 
                else { currentLayerOutputUnits = isLast ? this.inputDim : Math.floor(this.inputDim * expansionOrTargetDim); }
                
                const denseLayerConfig = {
                    units: currentLayerOutputUnits, kernelInitializer: 'glorotUniform',
                    biasInitializer: 'zeros', name: `${namePrefix}_mlp_dense_${i}`
                };
                if (i === 0) { denseLayerConfig.inputShape = currentLayerInputShape; }
                layers.push(tf.layers.dense(denseLayerConfig));
                currentLayerInputShape = [currentLayerOutputUnits]; 

                if (!isLast) { layers.push(tf.layers.activation({activation: activation, name: `${namePrefix}_mlp_act_${i}`})); }
            }
            this.model = tf.sequential({ name: `${namePrefix}_mlp_sequential`, layers });
        }

        call(inputs) { 
            if (this.isDisposed) throw new Error(`${this.namePrefix} MLP model is disposed.`);
            if (this.isIdentity) return tf.keep(inputs.clone());
            if (!this.model) throw new Error (`MemoryMLP_TFJS (${this.namePrefix}): Model not initialized properly.`);
            return this.model.apply(inputs);
        }
        
        getWeights() { 
            if (this.isDisposed || this.isIdentity || !this.model) return [];
            return this.model.getWeights().map(w => tf.keep(w.clone()));
        }

        setWeights(weights) { 
            if (this.isDisposed || this.isIdentity || !this.model || !weights || weights.length === 0) return;
            this.model.setWeights(weights); 
        }
        
        getTrainableVariables() {
            if (this.isDisposed || this.isIdentity || !this.model) return [];
            return this.model.trainableWeights.map(tw => tw.val); 
        }

        dispose() {
            if (this.isDisposed) return;
            if (this.model && typeof this.model.dispose === 'function') { this.model.dispose(); }
            this.model = null; this.isDisposed = true;
        }
    }

    function createNeuralMemState(seq_index = 0, layerWeights = {}, optim_state = {}) { 
        return { seq_index, layerWeights, optim_state };
    }

    function memStateDetach(state) { 
        if (!state) return null;
        const detachedLayerWeights = {};
        for (const key in state.layerWeights) {
            if (Array.isArray(state.layerWeights[key])) {
                detachedLayerWeights[key] = state.layerWeights[key].map(t => {
                    if (t && !t.isDisposed) return tf.keep(t.clone());
                    logMessage(`Warning: memStateDetach found disposed or null tensor for weight key ${key}. Returning null for this tensor.`, "warn");
                    return null; 
                }).filter(t => t !== null); 
            } else {
                logMessage(`Warning: memStateDetach encountered non-array weights for key ${key}`, "warn");
                detachedLayerWeights[key] = [];
            }
        }
        const detachedOptimState = JSON.parse(JSON.stringify(state.optim_state || {})); 
        return createNeuralMemState(state.seq_index, detachedLayerWeights, detachedOptimState);
    }

    function disposeMemStateWeights(state) { 
        if (state && state.layerWeights) {
            for (const key in state.layerWeights) {
                if (Array.isArray(state.layerWeights[key])) {
                    state.layerWeights[key].forEach(t => { if (t && !t.isDisposed) t.dispose(); });
                }
            }
            state.layerWeights = {}; 
        }
    }
    
    function disposeHnsResultsTensors(hnsResults) {
        if (!hnsResults) return;
        const tensorDictionaries = [
            hnsResults.anomalies, 
            hnsResults.weightChanges, 
            hnsResults.buNorms, 
            hnsResults.tdNorms, 
            hnsResults.extNorms
        ];
        tensorDictionaries.forEach(dict => {
            if (dict) {
                Object.values(dict).forEach(tensor => {
                    if (tensor && !tensor.isDisposed && typeof tensor.dispose === 'function') {
                        tensor.dispose();
                    }
                });
            }
        });
    }

    class NMM_TD_V5_TFJS {
        constructor(config) { 
            this.levelName = config.name; this.dim = config.dim;
            this.buInputDims = { ...(config.bu_input_dims || {}) }; 
            this.tdInputDims = { ...(config.td_input_dims || {}) }; 
            
            this.nmmParams = { 
                mem_model_depth: 2, 
                mem_model_expansion: 2.0,
                learning_rate: 0.001, 
                weight_decay: 0.001, 
                beta1: 0.9, 
                beta2: 0.999, 
                max_grad_norm: 1.0,
                external_signal_dim: config.nmm_params?.external_signal_dim || 0,
                external_signal_role: config.nmm_params?.external_signal_role || 'none',
                verbose: config.nmm_params?.verbose || false,
            };
            
            this.memoryModel = new MemoryMLP_TFJS(this.dim, this.nmmParams.mem_model_depth, this.nmmParams.mem_model_expansion, `${this.levelName}_mem_mlp`);
            this.toValueTarget = new MemoryMLP_TFJS(this.dim, 1, this.dim, `${this.levelName}_val_proj`); 

            this.buProjections = {};
            for (const name in this.buInputDims) { this.buProjections[name] = new MemoryMLP_TFJS(this.buInputDims[name], 1, this.dim, `${this.levelName}_bu_proj_${name}`); }
            this.tdProjections = {};
            for (const name in this.tdInputDims) { this.tdProjections[name] = new MemoryMLP_TFJS(this.tdInputDims[name], 1, this.dim, `${this.levelName}_td_proj_${name}`); }
            
            this.externalSignalProjection = null;
            if (this.nmmParams.external_signal_dim > 0 && this.nmmParams.external_signal_role !== 'none') {
                this.externalSignalProjection = new MemoryMLP_TFJS(this.nmmParams.external_signal_dim, 1, this.dim, `${this.levelName}_ext_proj`);
            }
            
            this.lossFn = (labels, predictions) => tf.losses.meanSquaredError(labels, predictions);
            this.optimizer = tf.train.adam(
                 this.nmmParams.learning_rate, 
                 this.nmmParams.beta1, 
                 this.nmmParams.beta2, 
                 1e-7 // epsilon
             ); 
            if(this.nmmParams.verbose) logMessage(`NMM_TD_V5_TFJS (${this.levelName}): Dim=${this.dim}, ExtDim=${this.nmmParams.external_signal_dim}, Role=${this.nmmParams.external_signal_role}, MLP Depth=${this.nmmParams.mem_model_depth}, LR=${this.nmmParams.learning_rate.toExponential(2)}, WD=${this.nmmParams.weight_decay.toExponential(2)}, GradClip=${this.nmmParams.max_grad_norm || 'None'}`);
            this.isDisposed = false;
        }

        _getLayerWeights() { 
            if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
            const weights = { memoryModel: this.memoryModel.getWeights(), toValueTarget: this.toValueTarget.getWeights() };
            for (const name in this.buProjections) { weights[`buProj_${name}`] = this.buProjections[name].getWeights(); }
            for (const name in this.tdProjections) { weights[`tdProj_${name}`] = this.tdProjections[name].getWeights(); }
            if (this.externalSignalProjection) { weights.externalSignalProjection = this.externalSignalProjection.getWeights(); }
            return weights;
        }

        _applyLayerWeights(layerWeights) { 
            if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
            if (!layerWeights) return;

            const tempClonedWeights = {};
            for (const key in layerWeights) {
                if (Array.isArray(layerWeights[key])) {
                    tempClonedWeights[key] = layerWeights[key].map(t => t && !t.isDisposed ? t.clone() : null).filter(t => t);
                }
            }

            this.memoryModel.setWeights(tempClonedWeights.memoryModel || []); 
            this.toValueTarget.setWeights(tempClonedWeights.toValueTarget || []);
            for (const name in this.buProjections) { this.buProjections[name].setWeights(tempClonedWeights[`buProj_${name}`] || []); }
            for (const name in this.tdProjections) { this.tdProjections[name].setWeights(tempClonedWeights[`tdProj_${name}`] || []); }
            if (this.externalSignalProjection && tempClonedWeights.externalSignalProjection) { this.externalSignalProjection.setWeights(tempClonedWeights.externalSignalProjection || []); }
        
            for (const key in tempClonedWeights) {
                if (Array.isArray(tempClonedWeights[key])) {
                    tempClonedWeights[key].forEach(t => { if (t && !t.isDisposed) t.dispose(); });
                }
            }
        }
        
        getInitialState() { 
            if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
            return createNeuralMemState(0, this._getLayerWeights(), { lr: this.nmmParams.learning_rate, wd: this.nmmParams.weight_decay });
        }
        
       _calculateWeightChange(oldWeightsMap, newWeightsMap) { 
            return tf.tidy(`${this.levelName}_WeightChange`,() => {
                let totalDiffSqSum = tf.tensor(0.0); 
                 for (const key in newWeightsMap) { 
                     const oldWArray = oldWeightsMap[key]; const newWArray = newWeightsMap[key];
                     if (oldWArray && newWArray && oldWArray.length === newWArray.length) {
                         for (let i = 0; i < newWArray.length; i++) { 
                             const oldW = oldWArray[i]; const newW = newWArray[i];
                             if (oldW && newW && !oldW.isDisposed && !newW.isDisposed && oldW.shape.toString() === newW.shape.toString()) {
                                 const diff = newW.sub(oldW);
                                 totalDiffSqSum = totalDiffSqSum.add(diff.square().sum());
                                 diff.dispose();
                             } else { if(this.nmmParams.verbose) logMessage(`Warning: Tensor mismatch or disposal during weight change calc for ${key}[${i}]`, "warn"); }
                         }
                     }
                 } 
                return tf.keep(totalDiffSqSum.sqrt());
            });
        }

        forwardStep(buInputs, tdSignals, currentState, externalSignal = null, detachNextState = true) {
            if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
            
            const oldWeightsForChangeCalc = this._getLayerWeights();
            this._applyLayerWeights(currentState.layerWeights); 

            const resultsTidy = tf.tidy(`${this.levelName}_NMM_ForwardStep_And_Train`, () => { 
                const preparedInputs = tf.tidy(`${this.levelName}_InputPrep`, () => {
                    const projectedBuSignals = [];
                    for (const name in buInputs) {
                        if (this.buProjections[name] && buInputs[name] && !buInputs[name].isDisposed && buInputs[name].shape) {
                            projectedBuSignals.push(this.buProjections[name].call(buInputs[name].reshape([-1, this.buInputDims[name]])));
                        } else {
                            if(this.nmmParams.verbose) logMessage(`Warning: Skipping BU input for ${name} in ${this.levelName}. Using zeros.`, "warn");
                            projectedBuSignals.push(tf.zeros([1, this.dim]));
                        }
                    }
                    const combBu = projectedBuSignals.length > 0 ? tf.addN(projectedBuSignals) : tf.zeros([1, this.dim]);
                    projectedBuSignals.forEach(t => {if (t && !t.isDisposed) t.dispose(); });
                    const cBuNorm = tf.norm(combBu);

                    const projectedTdSignals = [];
                    for (const name in tdSignals) {
                        if (this.tdProjections[name] && tdSignals[name] && !tdSignals[name].isDisposed && tdSignals[name].shape) {
                            projectedTdSignals.push(this.tdProjections[name].call(tdSignals[name].reshape([-1, this.tdInputDims[name]])));
                        } else {
                           if(this.nmmParams.verbose) logMessage(`Warning: Skipping TD input for ${name} in ${this.levelName}. Using zeros.`, "warn");
                           projectedTdSignals.push(tf.zeros([1, this.dim]));
                        }
                    }
                    const combTd = projectedTdSignals.length > 0 ? tf.addN(projectedTdSignals) : tf.zeros([1, this.dim]);
                    projectedTdSignals.forEach(t => {if (t && !t.isDisposed) t.dispose(); });
                    const cTdNorm = tf.norm(combTd);
                    
                    let projExtSig = null; 
                    let cExtNorm = tf.tensor(0.0);
                    if (this.nmmParams.external_signal_role !== 'none' && this.externalSignalProjection) {
                        if (externalSignal && !externalSignal.isDisposed && externalSignal.shape && externalSignal.shape[externalSignal.shape.length -1] === this.nmmParams.external_signal_dim) {
                           projExtSig = this.externalSignalProjection.call(externalSignal.reshape([-1, this.nmmParams.external_signal_dim]));
                        } else { 
                            if(this.nmmParams.verbose) logMessage(`Warning: External signal for ${this.levelName} invalid. Using zeros. Expected dim ${this.nmmParams.external_signal_dim}`, "warn");
                            projExtSig = tf.zeros([1, this.dim]); 
                        }
                        cExtNorm.dispose(); 
                        cExtNorm = tf.norm(projExtSig);
                    }
                    
                    let keyBaseForPredictionTarget = combBu.clone(); 
                    if (this.nmmParams.external_signal_role === 'add_to_bu' && projExtSig) {
                        keyBaseForPredictionTarget = keyBaseForPredictionTarget.add(projExtSig);
                    }
                    
                    let mInput = combBu.add(combTd); 
                    if (this.nmmParams.external_signal_role === 'add_to_bu' && projExtSig) {
                        mInput = mInput.add(projExtSig);
                    } else if (this.nmmParams.external_signal_role === 'add_to_td' && projExtSig) {
                        mInput = mInput.add(projExtSig);
                    }
                    
                    let fValTarget = this.toValueTarget.call(keyBaseForPredictionTarget);
                    if (this.nmmParams.external_signal_role === 'add_to_target' && projExtSig) {
                        fValTarget = fValTarget.add(projExtSig);
                    }
                    
                    return { memInput: mInput, finalValTarget: fValTarget, currentBuNorm: cBuNorm, currentTdNorm: cTdNorm, currentExtNorm: cExtNorm };
                }); 
                
                const keptBuNorm = tf.keep(preparedInputs.currentBuNorm);
                const keptTdNorm = tf.keep(preparedInputs.currentTdNorm);
                const keptExtNorm = tf.keep(preparedInputs.currentExtNorm);
                
                const predictionBeforeTrain = this.memoryModel.call(preparedInputs.memInput); 
                const keptPredictionForOutput = tf.keep(predictionBeforeTrain.clone().reshape([1, 1, this.dim]));

                let currentLossTensor = tf.tensor(0.0);
                
                const trainableVarsForOptimizer = [];
                this.memoryModel.getTrainableVariables().forEach(v => trainableVarsForOptimizer.push(v));
                if (this.externalSignalProjection && this.nmmParams.external_signal_role !== 'none' && this.nmmParams.external_signal_dim > 0) {
                     this.externalSignalProjection.getTrainableVariables().forEach(v => trainableVarsForOptimizer.push(v));
                }
                
                if (trainableVarsForOptimizer.length > 0) {
                    const calculateLossFn = () => {
                        const currentPred = this.memoryModel.call(preparedInputs.memInput); 
                        let mseLoss = this.lossFn(preparedInputs.finalValTarget, currentPred); 
                        
                        if (this.nmmParams.weight_decay > 0) {
                            let l2Loss = tf.tensor(0.0);
                            trainableVarsForOptimizer.forEach(v => {
                                if (v.name.includes('kernel')) { // Apply only to kernels, not biases
                                    l2Loss = l2Loss.add(v.square().sum());
                                }
                            });
                            mseLoss = mseLoss.add(l2Loss.mul(this.nmmParams.weight_decay / 2));
                            l2Loss.dispose();
                        }
                        return mseLoss;
                    };

                    if (this.nmmParams.max_grad_norm && this.nmmParams.max_grad_norm > 0) {
                        const {value, grads} = this.optimizer.computeGradients(calculateLossFn, trainableVarsForOptimizer);
                        currentLossTensor.dispose(); 
                        currentLossTensor = value ? tf.keep(value) : tf.keep(tf.tensor(0.0));

                         if (grads) {
                            const gradArray = trainableVarsForOptimizer.map(v => grads[v.name]).filter(g => g && !g.isDisposed);
                            let finalGradsForApply = {}; 
                            if (gradArray.length > 0) {
                                const globalNorm = tf.tidy('globalNormCalc', () => {
                                    let totalNormSq = tf.scalar(0.0);
                                    for (const grad of gradArray) { totalNormSq = totalNormSq.add(tf.norm(grad).square()); }
                                    return totalNormSq.sqrt();
                                });
                                const globalNormVal = globalNorm.dataSync()[0]; 
                                globalNorm.dispose(); 

                                let clipRatioScalar = null;
                                if (globalNormVal > this.nmmParams.max_grad_norm) {
                                    clipRatioScalar = tf.scalar(this.nmmParams.max_grad_norm / (globalNormVal + 1e-6));
                                }
                                trainableVarsForOptimizer.forEach(v => {
                                    if (grads[v.name] && !grads[v.name].isDisposed) {
                                        finalGradsForApply[v.name] = clipRatioScalar ? grads[v.name].mul(clipRatioScalar) : grads[v.name].clone();
                                    }
                                });
                                if (clipRatioScalar) clipRatioScalar.dispose();
                            }
                            this.optimizer.applyGradients(finalGradsForApply);
                            trainableVarsForOptimizer.forEach(v => { if (grads[v.name] && !grads[v.name].isDisposed) grads[v.name].dispose(); });
                            Object.values(finalGradsForApply).forEach(g => {if (g && !g.isDisposed) g.dispose(); });
                         } else { if(this.nmmParams.verbose) logMessage(`Warning: Grads object from computeGradients is null/undefined for NMM ${this.levelName}.`, "warn");}
                    } else { 
                        const lossTensorFromOptimizer = this.optimizer.minimize(calculateLossFn, true, trainableVarsForOptimizer); 
                        currentLossTensor.dispose();
                        currentLossTensor = lossTensorFromOptimizer ? tf.keep(lossTensorFromOptimizer) : tf.keep(tf.tensor(0.0));
                    }
                } else { if(this.nmmParams.verbose) logMessage(`Warning: No trainable variables for NMM ${this.levelName}. Training skipped.`, "warn"); }
                
                return { prediction: keptPredictionForOutput, loss: currentLossTensor, buNorm: keptBuNorm, tdNorm: keptTdNorm, extNorm: keptExtNorm };
            }); 
            
            const retrievedValForOutput = resultsTidy.prediction; 
            const lossVal = resultsTidy.loss; 
            const buNormVal = resultsTidy.buNorm; 
            const tdNormVal = resultsTidy.tdNorm; 
            const extNormVal = resultsTidy.extNorm;
            
            const newModelWeightsAfterTraining = this._getLayerWeights();
            const weightChangeVal = this._calculateWeightChange(oldWeightsForChangeCalc, newModelWeightsAfterTraining);
            
            Object.values(oldWeightsForChangeCalc).forEach(arr => arr.forEach(t => { if (t && !t.isDisposed) t.dispose(); }));
            
            const nextStateInterim = createNeuralMemState(currentState.seq_index + 1, newModelWeightsAfterTraining, currentState.optim_state);
            const nextStateFinal = detachNextState ? memStateDetach(nextStateInterim) : nextStateInterim;
            if (detachNextState) { disposeMemStateWeights(nextStateInterim); }

            return { retrievedVal: retrievedValForOutput, nextState: nextStateFinal, anomalyScore: lossVal, weightChange: weightChangeVal, buNorm: buNormVal, tdNorm: tdNormVal, extNorm: extNormVal };
        }
        
        dispose() { 
            if (this.isDisposed) return;
            this.memoryModel.dispose(); this.toValueTarget.dispose();
            Object.values(this.buProjections).forEach(p => p.dispose()); Object.values(this.tdProjections).forEach(p => p.dispose());
            if(this.externalSignalProjection) this.externalSignalProjection.dispose();
            this.isDisposed = true; logMessage(`NMM ${this.levelName} disposed.`);
        }
    }

    class HierarchicalSystemV5_TFJS {
        constructor(levelConfigsHLC, globalSimConfig) { 
            this.levelConfigsOriginal = JSON.parse(JSON.stringify(levelConfigsHLC)); 
            this.globalConfig = globalSimConfig; 
            this.numLevels = 0; this.levels = []; 
            this.levelNameToIndex = {}; this.dims = {}; this.isDisposed = false;
            this.level_expected_external_details = []; // Stores {name, dim} for the external signal each NMM expects

            this._initializeLevels();
        }

        _initializeLevels() {
            logMessage(`HS_V5_TFJS: Initializing ${this.levelConfigsOriginal.length} levels.`);
            this.levelConfigsOriginal.forEach((cfg, i) => {
                if (!cfg.name || !cfg.dim) throw new Error(`Level ${i} config missing name or dim.`);
                this.levelNameToIndex[cfg.name] = i; this.dims[cfg.name] = cfg.dim;
            });

            this.levelConfigsOriginal.forEach((hlc_level_cfg, i) => {
                const nmmConstructorConfig = { // This is the config obj passed to NMM_TD_V5_TFJS constructor
                    name: hlc_level_cfg.name,
                    dim: hlc_level_cfg.dim,
                    bu_input_dims: {},
                    td_input_dims: {},
                    nmm_params: { // Default NMM params, will be overridden by hlc_level_cfg.nmm_params
                        verbose: this.globalConfig.HNM_VERBOSE || false,
                        learning_rate: 0.001, weight_decay: 0.001, beta1: 0.9, beta2: 0.999, max_grad_norm: 1.0,
                        external_signal_dim: 0, external_signal_role: 'none',
                        mem_model_depth: 2, mem_model_expansion: 2.0,
                        ...(hlc_level_cfg.nmm_params || {}) // Override defaults with specific level nmm_params
                    }
                };
                
                // BU Inputs
                if (!hlc_level_cfg.bu_source_level_names || hlc_level_cfg.bu_source_level_names.length === 0) { 
                    if (!hlc_level_cfg.raw_sensory_input_dim || hlc_level_cfg.raw_sensory_input_dim <= 0) { throw new Error(`Lvl '${hlc_level_cfg.name}' is a sensory level but lacks a valid 'raw_sensory_input_dim'.`); }
                    nmmConstructorConfig.bu_input_dims[hlc_level_cfg.name] = hlc_level_cfg.raw_sensory_input_dim;
                } else { 
                    hlc_level_cfg.bu_source_level_names.forEach(srcName => {
                        if (!this.dims[srcName]) throw new Error(`Unknown BU source '${srcName}' for level '${hlc_level_cfg.name}'.`);
                        nmmConstructorConfig.bu_input_dims[srcName] = this.dims[srcName];
                    });
                }
                // TD Inputs
                if (hlc_level_cfg.td_source_level_names) {
                     hlc_level_cfg.td_source_level_names.forEach(srcName => {
                        if (!this.dims[srcName]) throw new Error(`Unknown TD source '${srcName}' for level '${hlc_level_cfg.name}'.`);
                        nmmConstructorConfig.td_input_dims[srcName] = this.dims[srcName];
                    });
                }
                
                // External Input for this NMM (expects one specific signal)
                // The hlc_level_cfg.external_input_config should be a single object {source_signal_name, dim, role?}
                // This is prepared by _getProcessedHLC.
                let expectedNmmExtSourceName = null;
                let nmmExtSignalDimForNMM = 0;
                // Role is primarily taken from nmm_params, but can be influenced by external_input_config if specified there.
                let nmmExtSignalRoleForNMM = nmmConstructorConfig.nmm_params.external_signal_role; 

                const specificExtConfig = hlc_level_cfg.external_input_config; // Should be an object or null
                if (specificExtConfig && specificExtConfig.source_signal_name && specificExtConfig.dim > 0) {
                    expectedNmmExtSourceName = specificExtConfig.source_signal_name;
                    nmmExtSignalDimForNMM = specificExtConfig.dim;
                    // If role is defined in external_input_config, it takes precedence for this signal
                    if (specificExtConfig.role) {
                        nmmExtSignalRoleForNMM = specificExtConfig.role;
                    } else if (nmmExtSignalDimForNMM > 0 && nmmExtSignalRoleForNMM === 'none') {
                        // If dim is present but role is 'none' in nmm_params, default to 'add_to_bu'
                        nmmExtSignalRoleForNMM = 'add_to_bu';
                    }
                }
                
                nmmConstructorConfig.nmm_params.external_signal_dim = nmmExtSignalDimForNMM;
                nmmConstructorConfig.nmm_params.external_signal_role = nmmExtSignalRoleForNMM;
                this.level_expected_external_details[i] = { name: expectedNmmExtSourceName, dim: nmmExtSignalDimForNMM };
                
                this.levels.push(new NMM_TD_V5_TFJS(nmmConstructorConfig));
            });
            this.numLevels = this.levels.length;
            logMessage(`HS_V5_TFJS: Initialization complete. ${this.levels.length} levels created.`);
        }

        getInitialStates() { 
            if (this.isDisposed) throw new Error(`HNS is disposed.`);
            return this.levels.map(level => level.getInitialState());
        }

        step(currentBotLevelStates, currentBotLastStepOutputs, sensoryInputs, externalInputsAllSources = {}, detachNextStatesMemory = true) {
            if (this.isDisposed) throw new Error(`HNS is disposed.`);
            
            const nextBotLevelStatesList = new Array(this.numLevels).fill(null);
            const newlyRetrievedValuesForAllLevelsDict = {}; 
            const stepAnomalies = {}; const stepWeightChanges = {}; 
            const stepBuNorms = {}; const stepTdNorms = {}; const stepExternalNorms = {};
            
            const currentStepIntermediateOutputs = {}; 

            for (let i = 0; i < this.numLevels; i++) {
                const lvlMgr = this.levels[i]; const cfg = this.levelConfigsOriginal[i];
                const lvlName = cfg.name; const buSrcNames = cfg.bu_source_level_names || []; const tdSrcNames = cfg.td_source_level_names || [];
                const currentLevelSpecificState = currentBotLevelStates[i]; 
                const lvlBuIn = {}; const lvlTdIn = {}; 

                if (buSrcNames.length === 0) { 
                    const rawSensoryDim = cfg.raw_sensory_input_dim; const sensoryInputTensor = sensoryInputs[lvlName]; 
                    if (sensoryInputTensor && !sensoryInputTensor.isDisposed && sensoryInputTensor.shape && sensoryInputTensor.shape.length === 3 && sensoryInputTensor.shape[0] === 1 && sensoryInputTensor.shape[1] === 1 && sensoryInputTensor.shape[2] === rawSensoryDim) {
                        lvlBuIn[lvlName] = sensoryInputTensor;
                    } else {
                        if(lvlMgr.nmmParams.verbose) logMessage(`Warning: Sensory input for ${lvlName} is invalid. Using zeros. Expected dim ${rawSensoryDim}`, "warn");
                        lvlBuIn[lvlName] = tf.keep(tf.zeros([1, 1, rawSensoryDim])); 
                    }
                } else { 
                    buSrcNames.forEach(srcName => {
                        const buSourceOutput = currentStepIntermediateOutputs[srcName]; 
                        if (buSourceOutput && !buSourceOutput.isDisposed) { lvlBuIn[srcName] = buSourceOutput; }
                        else { lvlBuIn[srcName] = tf.keep(tf.zeros([1, 1, this.dims[srcName]])); }
                    });
                }
                tdSrcNames.forEach(srcName => { 
                    const tdSourceOutput = currentBotLastStepOutputs[srcName]?.retrievedVal; 
                    if (tdSourceOutput && !tdSourceOutput.isDisposed) { lvlTdIn[srcName] = tdSourceOutput; }
                    else { lvlTdIn[srcName] = tf.keep(tf.zeros([1, 1, this.dims[srcName]])); }
                });
                
                let lvlExtInForNMMStep = null;
                const expectedExternal = this.level_expected_external_details[i];
                if (expectedExternal && expectedExternal.name && expectedExternal.dim > 0) {
                    const providedSignal = externalInputsAllSources[expectedExternal.name];
                    if (providedSignal && !providedSignal.isDisposed && providedSignal.shape && providedSignal.shape.length === 3 && providedSignal.shape[0] === 1 && providedSignal.shape[1] === 1 && providedSignal.shape[2] === expectedExternal.dim) {
                        lvlExtInForNMMStep = providedSignal;
                    } else {
                        if(lvlMgr.nmmParams.verbose) logMessage(`Warning for ${lvlName}: External signal '${expectedExternal.name}' invalid. Using zeros. Expected dim ${expectedExternal.dim}.`, "warn");
                        lvlExtInForNMMStep = tf.keep(tf.zeros([1,1,expectedExternal.dim])); 
                    }
                }
                
                const nmmOutputs = lvlMgr.forwardStep(lvlBuIn, lvlTdIn, currentLevelSpecificState, lvlExtInForNMMStep, detachNextStatesMemory);
                
                nextBotLevelStatesList[i] = nmmOutputs.nextState;
                currentStepIntermediateOutputs[lvlName] = tf.keep(nmmOutputs.retrievedVal.clone()); 
                newlyRetrievedValuesForAllLevelsDict[lvlName] = nmmOutputs.retrievedVal; 
                
                stepAnomalies[lvlName] = nmmOutputs.anomalyScore;
                stepWeightChanges[lvlName] = nmmOutputs.weightChange;
                stepBuNorms[lvlName] = nmmOutputs.buNorm;
                stepTdNorms[lvlName] = nmmOutputs.tdNorm;
                stepExternalNorms[lvlName] = nmmOutputs.extNorm;
                
                // Dispose temporary zero tensors if they were created and not the original inputs
                Object.entries(lvlBuIn).forEach(([key, t]) => { 
                    if (t !== sensoryInputs[lvlName] && t !== currentStepIntermediateOutputs[key] && t.rank === 3 && t.shape[0] === 1 && !t.isDisposed && t.dataSync().every(v => v ===0) ) t.dispose(); 
                });
                Object.entries(lvlTdIn).forEach(([key, t]) => { 
                    if (t !== currentBotLastStepOutputs[key]?.retrievedVal && t.rank === 3 && t.shape[0] === 1 && !t.isDisposed && t.dataSync().every(v => v ===0) ) t.dispose(); 
                });
                if (lvlExtInForNMMStep && lvlExtInForNMMStep !== externalInputsAllSources[expectedExternal?.name] && lvlExtInForNMMStep.rank === 3 && lvlExtInForNMMStep.shape[0] === 1 && !lvlExtInForNMMStep.isDisposed && lvlExtInForNMMStep.dataSync().every(v => v ===0) ) lvlExtInForNMMStep.dispose();
            } 
            
            Object.values(currentStepIntermediateOutputs).forEach(t => { if (t && !t.isDisposed) t.dispose(); });

            return { newlyRetrievedValues: newlyRetrievedValuesForAllLevelsDict, nextBotStates: nextBotLevelStatesList, anomalies: stepAnomalies, weightChanges: stepWeightChanges, buNorms: stepBuNorms, tdNorms: stepTdNorms, extNorms: stepExternalNorms };
        }
        
        dispose() { 
            if (this.isDisposed) return;
            this.levels.forEach(l => {if (l && typeof l.dispose === 'function') l.dispose();});
            this.levels = []; this.isDisposed = true; logMessage("HNS Disposed.");
        }
    }

    const canvasEl = document.getElementById('gridCanvas');
    const ctxGrid = canvasEl.getContext('2d');
    const statusEl = document.getElementById('status');
    const roundInfoEl = document.getElementById('round-info');
    const playerInfoEl = document.getElementById('player-info');
    const gridContainerEl = document.querySelector('.grid-container');
    const botsInfoContainerEl = document.getElementById('bots-info-container');
    const mobileControlsEl = document.getElementById('mobile-controls');
    const targetIndicatorEl = document.getElementById('target-indicator');

    const paramInputs = {}; const paramItems = {}; const rangeValueDisplays = {};
    document.querySelectorAll('.parameters .param-item').forEach(paramItemDiv => {
        const key = paramItemDiv.dataset.param; const input = paramItemDiv.querySelector('input, select, textarea');
        if (key && input && paramItemDiv) {
            paramInputs[key] = input; paramItems[key] = paramItemDiv;
            input.addEventListener('input', () => handleParamInputChange(key)); input.addEventListener('change', () => handleParamInputChange(key));
            if (input.type === 'range') {
                const valueDisplay = paramItemDiv.querySelector('.range-value');
                if (valueDisplay) { rangeValueDisplays[key] = valueDisplay; valueDisplay.textContent = `${input.value}%`; input.addEventListener('input', () => { valueDisplay.textContent = `${input.value}%`; });}
            }
        }
    });

    const startButton = document.getElementById('startButton'); const stopButton = document.getElementById('stopButton');
    const resetRoundButton = document.getElementById('resetRoundButton'); const resetFullButton = document.getElementById('resetFullButton');
    const applyParamsButton = document.getElementById('applyParamsButton'); const saveParamsButton = document.getElementById('saveParamsButton');
    const loadParamsButton = document.getElementById('loadParamsButton'); const resetParamsButton = document.getElementById('resetParamsButton');
    const joinButton = document.getElementById('joinButton'); const leaveButton = document.getElementById('leaveButton');
    const mobileUp = document.getElementById('btn-up'); const mobileLeft = document.getElementById('btn-left'); const mobileRight = document.getElementById('btn-right');
    const mobileDown = document.getElementById('btn-down'); const mobilePunch = document.getElementById('btn-punch'); const mobileClaim = document.getElementById('btn-claim'); const mobileMentalAttack = document.getElementById('btn-mental-attack');
    
    let DEFAULT_CONFIG = {
        "SIMULATION_SPEED_MS": 50, "FREEZE_DURATION": 15,
        "MENTAL_ATTACK_RANGE": 3, "MENTAL_ATTACK_DURATION": 30, "MENTAL_ATTACK_USES_RECONSTRUCTION": true,
        "NUM_ACTIONS": 7, 
        "GRID_SIZE": 20, "NUM_GOALS": 5, "NUM_HC_BOTS": 1, "NUM_LEARNING_BOTS": 2,
        "MAX_STEPS_PER_ROUND": 500, "VISIBILITY_RANGE": 8, "RANDOMIZE_ENV_PER_ROUND": true,
        "OBSTACLES_FACTOR_MIN": 0.03, "OBSTACLES_FACTOR_MAX": 0.08, 
        "MIN_GOAL_START_DISTANCE_FACTOR": 0.15, "MIN_BOT_START_DISTANCE_FACTOR": 0.25, "MIN_BOT_GOAL_DISTANCE_FACTOR": 0.15, 
        "SENSORY_INPUT_DIM": 22, 
        "HIERARCHY_LEVEL_CONFIGS": [ 
            {   
                name: "L0_SensoryMotor", dim: 64, raw_sensory_input_dim: 22,
                bu_source_level_names: [], 
                td_source_level_names: ["L1_Context"],
                external_input_config: null, // Will be set by _getProcessedHLC
                nmm_params: { 
                    mem_model_depth: 2, mem_model_expansion: 2.0,
                    learning_rate: 0.001, weight_decay: 0.0001, beta1: 0.9, beta2: 0.999,
                    max_grad_norm: 1.0, external_signal_role: "add_to_bu" // Default role for L0
                }
            },
            {   
                name: "L1_Context", dim: 96,
                bu_source_level_names: ["L0_SensoryMotor"], 
                td_source_level_names: ["L2_Executive"],
                external_input_config: null, // No external input by default for L1
                nmm_params: { 
                    mem_model_depth: 2, mem_model_expansion: 2.0,
                    learning_rate: 0.001, weight_decay: 0.0001, beta1: 0.9, beta2: 0.999,
                    max_grad_norm: 1.0, external_signal_role: "none" // Default if no ext_config
                }
            },
            {   
                name: "L2_Executive", dim: 128,
                bu_source_level_names: ["L1_Context"], 
                td_source_level_names: [],
                external_input_config: null, // No external input by default for L2
                nmm_params: { 
                    mem_model_depth: 3, mem_model_expansion: 2.0,
                    learning_rate: 0.0005, weight_decay: 0.00005, beta1: 0.9, beta2: 0.999,
                    max_grad_norm: 1.0, external_signal_role: "none" // Default if no ext_config
                }
            }
        ],
        "POLICY_HEAD_INPUT_LEVEL_NAME": "L2_Executive", 
        "USE_RULES_AS_HNS_INPUT": true, 
        "LEARNING_BOT_BASE_EXPLORATION_RATE": 15.0, "LEARNING_BOT_RULE_EXPLORE_PERCENT": 60.0, "PLAYER_CONTROL_PERCENT": 100.0,
        "AUTOSTART_SIMULATION": false, 
        "HNM_VERBOSE": false,
    };
    
    let current_config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
    let uiDefaults = JSON.parse(JSON.stringify(DEFAULT_CONFIG)); 
    let clientState = { environment: null, bots: {}, round: 0, stats: { hc_total_goals: 0, learning_total_goals: 0 }, isRunning: false, needsFullReset: false, needsRoundReset: false, playerBotId: null, playerOriginalBotId: null, playerTarget: null, hnsSystem: null };
    let visualizer = null;
    const LOCAL_STORAGE_KEY_UI = 'hierarchicalMultiBotSimParams_v6.3.0_TFJS';
    const LOCAL_STORAGE_KEY_PLAYER = 'hierarchicalMultiBotPlayerControl_v6.3.0_TFJS';
    let simulation_loop_task = null; let isDragging = false; let lastSentTargetTime = 0; const TARGET_UPDATE_INTERVAL_MS = 100;
    let player_direct_actions = {}; 

    async function setupTfBackend() {
        try {
            await tf.setBackend('webgl');
        } catch (e) {
            logMessage("WebGL backend failed, trying WASM.", "warn");
            try {
                await tf.setBackend('wasm');
            } catch (eWasm) {
                logMessage("WASM backend failed, using CPU.", "warn");
                await tf.setBackend('cpu');
            }
        }
        await tf.ready(); const backend = tf.getBackend(); logMessage(`TF.js backend: ${backend}`);
        document.getElementById('tfBackend').textContent = backend; updateTfMemoryDisplay();
    }

    function updateTfMemoryDisplay() {
        requestAnimationFrame(() => { 
            const mem = tf.memory();
            document.getElementById('tfMemoryBytes').textContent = `${(mem.numBytes / 1024 / 1024).toFixed(2)} MB`;
            document.getElementById('tfNumTensors').textContent = mem.numTensors;
            document.getElementById('tfNumDataBuffers').textContent = mem.numDataBuffers;
        });
    }

    class GridEnvironment_JS {
        constructor(size, num_goals, obstacles_factor_range, num_hc_bots, num_learning_bots, config_factors) {
            this.size = Math.max(10, parseInt(size)); this.num_goals_initial = Math.max(0, parseInt(num_goals));
            this.min_obstacles_factor = obstacles_factor_range[0]; this.max_obstacles_factor = obstacles_factor_range[1];
            this.num_hc_bots = Math.max(0, parseInt(num_hc_bots)); this.num_learning_bots = Math.max(0, parseInt(num_learning_bots));
            this.config_factors = { 'goal_dist': config_factors.MIN_GOAL_START_DISTANCE_FACTOR || 0.15, 'bot_dist': config_factors.MIN_BOT_START_DISTANCE_FACTOR || 0.25, 'bot_goal_dist': config_factors.MIN_BOT_GOAL_DISTANCE_FACTOR || 0.15 };
            this.obstacles = new Set(); this.goals = []; this.claimed_goals = new Set(); this.start_positions = []; this._initial_goals = [];
            try { this.randomize(); }
            catch (e) {
                logMessage("FATAL ERROR during environment initialization: " + e.message, "error");
                this.size = 10; this.num_goals_initial = 0; this.num_hc_bots = 0; this.num_learning_bots = 0;
                this.goals = []; this.obstacles = new Set(); this.start_positions = []; this._initial_goals = [];
            }
        }
        _manhattan_distance(pos1, pos2) { if (!pos1 || !pos2 || pos1.x === undefined || pos1.y === undefined || pos2.x === undefined || pos2.y === undefined) return Infinity; return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y); }
        randomize() {
            this.obstacles.clear(); this.goals = []; this.claimed_goals.clear(); this.start_positions = [];
            const total_bots = this.num_hc_bots + this.num_learning_bots; const total_cells = this.size * this.size; const required_items = total_bots + this.num_goals_initial;
            logMessage(`Randomizing Env: Size=${this.size}x${this.size}, Goals=${this.num_goals_initial}, HC=${this.num_hc_bots}, Lrn=${this.num_learning_bots}`);
            if (total_cells <= 0) throw new Error("Grid size must be positive.");
            const occupied = new Set(); const max_placement_attempts = Math.max(required_items * 100, total_cells * 20); let attempts = 0;
            const is_valid_placement = (pos_tuple_arr, current_occupied_set, check_dists = {}) => {
                const [x,y] = pos_tuple_arr; if (!(x >= 0 && x < this.size && y >= 0 && y < this.size)) return false; if (current_occupied_set.has(`${x},${y}`)) return false;
                const pos_dict = { x, y };
                if (check_dists.goal_min_dist && this.goals.some(g => this._manhattan_distance(pos_dict, g) < check_dists.goal_min_dist)) return false;
                if (check_dists.bot_min_dist && this.start_positions.some(sp => this._manhattan_distance(pos_dict, sp) < check_dists.bot_min_dist)) return false;
                if (check_dists.bot_goal_min_dist && this.goals.some(g => this._manhattan_distance(pos_dict, g) < check_dists.bot_goal_min_dist)) return false;
                return true;
            };
            const min_goal_dist = Math.max(2, Math.floor(this.size * this.config_factors.goal_dist)); let goal_id_counter = 0; attempts = 0;
            while (this.goals.length < this.num_goals_initial && attempts < max_placement_attempts) {
                attempts++; const pos_arr = [Math.floor(Math.random() * this.size), Math.floor(Math.random() * this.size)];
                if (is_valid_placement(pos_arr, occupied, { goal_min_dist: min_goal_dist })) { const goal = { x: pos_arr[0], y: pos_arr[1], id: `G${goal_id_counter}` }; this.goals.push(goal); occupied.add(`${pos_arr[0]},${pos_arr[1]}`); goal_id_counter++; }
            }
            if (this.goals.length < this.num_goals_initial) logMessage(`Placed only ${this.goals.length}/${this.num_goals_initial} goals after ${attempts} attempts.`, "warn");
            const min_bot_dist = Math.max(3, Math.floor(this.size * this.config_factors.bot_dist)); const min_bot_goal_dist = Math.max(3, Math.floor(this.size * this.config_factors.bot_goal_dist)); attempts = 0;
            let hc_placed_count = 0; let ln_placed_count = 0;
            while (this.start_positions.length < total_bots && attempts < max_placement_attempts) {
                attempts++; const pos_arr = [Math.floor(Math.random() * this.size), Math.floor(Math.random() * this.size)];
                if (is_valid_placement(pos_arr, occupied, { bot_min_dist: min_bot_dist, bot_goal_min_dist: min_bot_goal_dist })) {
                     const bot_type = hc_placed_count < this.num_hc_bots ? 'Hardcoded' : 'Learning'; const bot_num_in_type = bot_type === 'Hardcoded' ? hc_placed_count : ln_placed_count;
                     const bot_id = `${bot_type[0]}${bot_num_in_type}`; this.start_positions.push({ x: pos_arr[0], y: pos_arr[1], type: bot_type, id: bot_id });
                     occupied.add(`${pos_arr[0]},${pos_arr[1]}`); if (bot_type === 'Hardcoded') hc_placed_count++; else ln_placed_count++;
                }
            }
            if (this.start_positions.length < total_bots) { logMessage(`CRITICAL Warning: Placed only ${this.start_positions.length}/${total_bots} bots. Adjusting counts.`, "warn"); this.num_hc_bots = this.start_positions.filter(b => b.type === 'Hardcoded').length; this.num_learning_bots = this.start_positions.filter(b => b.type === 'Learning').length; }
            
            const num_obstacles_to_place_calc = total_cells > 0 ? Math.floor(Math.random() * (total_cells * this.max_obstacles_factor - total_cells * this.min_obstacles_factor + 1)) + Math.floor(total_cells * this.min_obstacles_factor) : 0;
            // logMessage(`Obstacle calc: total_cells=${total_cells}, min_factor=${this.min_obstacles_factor}, max_factor=${this.max_obstacles_factor}, calculated_num_to_place=${num_obstacles_to_place_calc}`);
            const num_obstacles_to_place = Math.max(0, num_obstacles_to_place_calc); // Ensure non-negative

            attempts = 0; let placed_obstacles = 0;
            while (placed_obstacles < num_obstacles_to_place && attempts < max_placement_attempts) {
                attempts++; const pos_arr = [Math.floor(Math.random() * this.size), Math.floor(Math.random() * this.size)];
                if (is_valid_placement(pos_arr, occupied)) { this.obstacles.add(`${pos_arr[0]},${pos_arr[1]}`); occupied.add(`${pos_arr[0]},${pos_arr[1]}`); placed_obstacles++; }
            }
            this._initial_goals = this.goals.map(g => ({ ...g })); logMessage(`Environment randomized. Placed ${this.goals.length} goals, ${this.start_positions.length} bots, ${this.obstacles.size} obstacles.`);
        }
        reset_round_state() { this.claimed_goals.clear(); this.goals = this._initial_goals.map(g => ({ ...g })); logMessage(`Round state reset. ${this.goals.length} goals active.`); }
        is_valid(pos) { if (!pos || pos.x === undefined || pos.y === undefined) return false; return pos.x >= 0 && pos.x < this.size && pos.y >= 0 && pos.y < this.size && !this.obstacles.has(`${pos.x},${pos.y}`); }
        find_path(start_pos, goal_pos, all_bots_dict = {}, moving_bot_id = null) {
            if (!this.is_valid(start_pos) || !goal_pos || !(goal_pos.x >= 0 && goal_pos.x < this.size && goal_pos.y >= 0 && goal_pos.y < this.size )) return null;
            const start_tuple_str = `${start_pos.x},${start_pos.y}`; const goal_tuple_str = `${goal_pos.x},${goal_pos.y}`; if (start_tuple_str === goal_tuple_str) return [];
            const current_obstacles_for_path = new Set(this.obstacles);
            if (all_bots_dict) { for (const bot_id in all_bots_dict) { if (bot_id === moving_bot_id) continue; const bot_state = all_bots_dict[bot_id]; current_obstacles_for_path.add(`${bot_state.pos.x},${bot_state.pos.y}`); } }
            const queue = [[start_pos, []]]; const visited = new Set([start_tuple_str]);
            const deltas = [{dx:0, dy:-1, action:0}, {dx:0, dy:1, action:1}, {dx:-1, dy:0, action:2}, {dx:1, dy:0, action:3}]; // U(0), D(1), L(2), R(3)
            const max_path_len = this.size * this.size;
            while (queue.length > 0) {
                const [current_node_pos, path] = queue.shift(); if (path.length >= max_path_len) continue;
                for (const {dx, dy, action} of deltas) {
                    const next_x = current_node_pos.x + dx; const next_y = current_node_pos.y + dy; const next_pos_str = `${next_x},${next_y}`;
                    if (next_pos_str === goal_tuple_str) return [...path, action];
                    if (next_x >= 0 && next_x < this.size && next_y >= 0 && next_y < this.size && !current_obstacles_for_path.has(next_pos_str) && !visited.has(next_pos_str)) { visited.add(next_pos_str); queue.push([{x: next_x, y: next_y}, [...path, action]]); }
                }
            } return null;
        }
        get_sensory_data(acting_bot, all_bots_dict, visibility_range) {
            const bot_pos = acting_bot.pos; const vis_range = Math.max(1, parseInt(visibility_range));
            let senses = { 'wall_distance_N': bot_pos.y, 'wall_distance_S': this.size - 1 - bot_pos.y, 'wall_distance_W': bot_pos.x, 'wall_distance_E': this.size - 1 - bot_pos.x, 'nearest_goal_dist': vis_range + 1, 'nearest_goal_dx': 0, 'nearest_goal_dy': 0, 'num_visible_goals': 0, 'nearest_opponent_dist': vis_range + 1, 'nearest_opponent_dx': 0, 'nearest_opponent_dy': 0, 'opponent_is_frozen': 0.0, 'opponent_type_HC': 0.0, 'opponent_type_LN': 0.0, 'opponent_type_PL': 0.0, 'self_is_frozen': (acting_bot.freezeTimer > 0 ? 1.0 : 0.0), 'is_hallucinating': (acting_bot.mental_attack_timer > 0 ? 1.0 : 0.0), '_visibleGoals': [], '_nearestOpponent': null };
            let min_goal_dist = vis_range + 1; let nearest_goal_obj = null;
            this.goals.forEach(goal => { if (!this.claimed_goals.has(goal.id)) { const dist = this._manhattan_distance(bot_pos, goal); if (dist <= vis_range) { senses.num_visible_goals++; senses._visibleGoals.push({ ...goal, dist }); if (dist < min_goal_dist) { min_goal_dist = dist; nearest_goal_obj = goal; } } } });
            senses.nearest_goal_dist = min_goal_dist; if (nearest_goal_obj) { senses.nearest_goal_dx = nearest_goal_obj.x - bot_pos.x; senses.nearest_goal_dy = nearest_goal_obj.y - bot_pos.y; }
            let min_opp_dist = vis_range + 1; let nearest_opponent_obj = null;
            for (const opp_id in all_bots_dict) { if (opp_id === acting_bot.id) continue; const opponent_bot = all_bots_dict[opp_id]; const dist = this._manhattan_distance(bot_pos, opponent_bot.pos); if (dist <= vis_range && dist < min_opp_dist) { min_opp_dist = dist; nearest_opponent_obj = opponent_bot; } }
            senses.nearest_opponent_dist = min_opp_dist;
            if (nearest_opponent_obj) { senses._nearestOpponent = nearest_opponent_obj; senses.nearest_opponent_dx = nearest_opponent_obj.pos.x - bot_pos.x; senses.nearest_opponent_dy = nearest_opponent_obj.pos.y - bot_pos.y; senses.opponent_is_frozen = (nearest_opponent_obj.freezeTimer > 0 ? 1.0 : 0.0); const is_player = nearest_opponent_obj.is_player_controlled || false; if (is_player) senses.opponent_type_PL = 1.0; else if (nearest_opponent_obj.type === 'Hardcoded') senses.opponent_type_HC = 1.0; else if (nearest_opponent_obj.type === 'Learning') senses.opponent_type_LN = 1.0; }
            senses._visibleGoals.sort((a, b) => a.dist - b.dist); return senses;
        }
        perform_move_action(bot_pos, action_index) { const next_pos = { ...bot_pos }; const delta = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}]; if (action_index >= 0 && action_index <= 3) { next_pos.x += delta[action_index].dx; next_pos.y += delta[action_index].dy; } return next_pos; }
        get_adjacent_unclaimed_goal(bot_pos) { for (const goal of this.goals) { if (!this.claimed_goals.has(goal.id) && this._manhattan_distance(bot_pos, goal) === 1) return goal; } return null; }
        claim_goal(goal_id, bot_id) { if (this.claimed_goals.has(goal_id)) return false; const goal_exists = this.goals.some(g => g.id === goal_id); if (goal_exists) { this.claimed_goals.add(goal_id); return true; } return false; }
        are_all_goals_claimed() { return this._initial_goals.length > 0 && this.claimed_goals.size >= this._initial_goals.length; }
        get_state() { const active_goals = this.goals.filter(g => !this.claimed_goals.has(g.id)); return { size: this.size, goals: active_goals, obstacles: Array.from(this.obstacles).map(obs_str => obs_str.split(',').map(Number)), claimedGoals: Array.from(this.claimed_goals) }; }
    }

    function create_hardcoded_bot_instance(bot_id, start_pos) {
        return {
            id: bot_id, type: 'Hardcoded', pos: { ...start_pos }, steps: 0, goalsReachedThisRound: 0, goalsReachedTotal: 0,
            freezeTimer: 0, mental_attack_timer: 0, lastAction: -1, mode: 'Init', senses: {}, lastPos: { x: -1, y: -1 },
            stuckCounter: 0, lastMoveAttempt: -1, currentPath: null, targetGoalId: null, randomMoveCounter: 0,
            is_player_controlled: false, target_coordinate: null, 
            is_hallucinating_state: false,
        };
    }

    function create_learning_bot_instance(bot_id, start_pos, config, sharedHnsSystem) {
        if (!sharedHnsSystem || sharedHnsSystem.isDisposed) {
            throw new Error(`HNS not ready for learning bot ${bot_id}.`);
        }
        const initial_hier_mem_states = sharedHnsSystem.getInitialStates(); 
        const initial_last_step_outputs = {};
        sharedHnsSystem.levelConfigsOriginal.forEach(levelConfig => { 
            initial_last_step_outputs[levelConfig.name] = {
                retrievedVal: tf.keep(tf.zeros([1, 1, levelConfig.dim])) 
            };
        });

        const policyHeadInputLevelName = config.POLICY_HEAD_INPUT_LEVEL_NAME;
        const policyHeadInputLevelConfig = sharedHnsSystem.levelConfigsOriginal.find(l => l.name === policyHeadInputLevelName);
        if (!policyHeadInputLevelConfig) {
            throw new Error(`Policy head input level '${policyHeadInputLevelName}' not found in HLC.`);
        }
        const policyHeadInputDim = policyHeadInputLevelConfig.dim;

        const policyHead = tf.sequential({name: `${bot_id}_policy_head`});
        policyHead.add(tf.layers.dense({
            units: config.NUM_ACTIONS,
            inputShape: [policyHeadInputDim], 
            kernelInitializer: 'glorotUniform',
            biasInitializer: 'zeros',
        }));
        
        return {
            id: bot_id, type: 'Learning', pos: { ...start_pos }, steps: 0, goalsReachedThisRound: 0, goalsReachedTotal: 0,
            freezeTimer: 0, mental_attack_timer: 0, lastAction: -1, mode: 'Init', senses: {},
            hierarchicalSystem: sharedHnsSystem, 
            memoryState: initial_hier_mem_states, 
            lastStepOutputs: initial_last_step_outputs, 
            policyHead: policyHead, 
            last_anomaly_sum: 0.0, 
            is_player_controlled: false, target_coordinate: null,
            original_bot_id: bot_id, 
            lastPos: { x: -1, y: -1 }, stuckCounter: 0, lastMoveAttempt: -1,
            currentPath: null, targetGoalId: null, randomMoveCounter: 0,
            is_hallucinating_state: false,
        };
    }
    
    function get_hardcoded_action(bot_state, senses, env, all_bots_dict) {
        const bot_id = bot_state.id; const pos = bot_state.pos;
        bot_state.stuckCounter = bot_state.stuckCounter || 0; bot_state.currentPath = bot_state.currentPath || null;
        bot_state.lastAction = bot_state.lastAction === undefined ? -1 : bot_state.lastAction; bot_state.targetGoalId = bot_state.targetGoalId || null;
        bot_state.lastPos = bot_state.lastPos || { x: -1, y: -1 }; bot_state.randomMoveCounter = bot_state.randomMoveCounter || 0;
        if (pos.x === bot_state.lastPos.x && pos.y === bot_state.lastPos.y) bot_state.stuckCounter++;
        else { bot_state.stuckCounter = 0; bot_state.lastPos = { ...pos }; bot_state.randomMoveCounter = 0; }

        if (bot_state.freezeTimer > 0) return [-1, "Frozen"];
        if (bot_state.mental_attack_timer > 0) return [-1, "Hallucinating (Idle)"];


        const adjacent_goal = env.get_adjacent_unclaimed_goal(pos);
        if (adjacent_goal) { bot_state.stuckCounter = 0; bot_state.currentPath = null; bot_state.targetGoalId = null; bot_state.randomMoveCounter = 0; return [5, `Claim ${adjacent_goal.id}`]; }
        const nearest_opponent = senses._nearestOpponent;
        if (nearest_opponent && senses.nearest_opponent_dist === 1 && !senses.opponent_is_frozen && (!nearest_opponent.mental_attack_timer || nearest_opponent.mental_attack_timer <=0) ) { bot_state.stuckCounter = 0; bot_state.currentPath = null; bot_state.targetGoalId = null; bot_state.randomMoveCounter = 0; return [4, `Punch ${nearest_opponent.id}`]; }
        if (nearest_opponent && senses.nearest_opponent_dist >=1 && senses.nearest_opponent_dist <= current_config.MENTAL_ATTACK_RANGE && (!nearest_opponent.mental_attack_timer || nearest_opponent.mental_attack_timer <=0) && (!nearest_opponent.freezeTimer || nearest_opponent.freezeTimer <=0) ) { bot_state.stuckCounter = 0; bot_state.currentPath = null; bot_state.targetGoalId = null; bot_state.randomMoveCounter = 0; return [6, `MAtt ${nearest_opponent.id}`]; }

        if (bot_state.stuckCounter >= 5 && bot_state.randomMoveCounter < 3) {
            bot_state.randomMoveCounter++; bot_state.currentPath = null; bot_state.targetGoalId = null; const valid_moves = [];
            for (let action_idx = 0; action_idx < 4; action_idx++) { const next_p = env.perform_move_action(pos, action_idx); const occupied_by_active = Object.values(all_bots_dict).some(b => b.id !== bot_id && b.pos.x === next_p.x && b.pos.y === next_p.y && (b.freezeTimer || 0) <= 0 ); if (env.is_valid(next_p) && !occupied_by_active) valid_moves.push(action_idx); }
            if (valid_moves.length > 0) return [valid_moves[Math.floor(Math.random() * valid_moves.length)], `StuckRandom (${bot_state.stuckCounter})`];
            else return [-1, "StuckBlocked"];
        } else if (bot_state.stuckCounter >= 5) { return [-1, `Stuck (${bot_state.stuckCounter})`]; }

        if (bot_state.currentPath && bot_state.currentPath.length > 0) {
            const next_action = bot_state.currentPath[0]; const intended_pos = env.perform_move_action(pos, next_action);
            const is_pos_valid = env.is_valid(intended_pos); const is_pos_occupied_by_other = Object.values(all_bots_dict).some( other_bot => other_bot.id !== bot_id && other_bot.pos.x === intended_pos.x && other_bot.pos.y === intended_pos.y );
            if (is_pos_valid && !is_pos_occupied_by_other) { bot_state.currentPath.shift(); let mode_str = `Path (${bot_state.currentPath.length} left)`; if (bot_state.currentPath.length === 0) { bot_state.targetGoalId = null; mode_str = "Path End"; } bot_state.randomMoveCounter = 0; return [next_action, mode_str];
            } else { bot_state.currentPath = null; bot_state.targetGoalId = null; }
        }
        const visible_goals = senses._visibleGoals || []; let target_goal_obj = null;
        if (bot_state.targetGoalId) { target_goal_obj = visible_goals.find(g => g.id === bot_state.targetGoalId) || null; if (!target_goal_obj) bot_state.targetGoalId = null; }
        if (!target_goal_obj && visible_goals.length > 0) { target_goal_obj = visible_goals[0]; bot_state.targetGoalId = target_goal_obj.id; }
        if (target_goal_obj) {
            const path_to_goal = env.find_path(pos, target_goal_obj, all_bots_dict, bot_id);
            if (path_to_goal && path_to_goal.length > 0) { bot_state.currentPath = path_to_goal; const next_action = bot_state.currentPath.shift(); let mode_str = `NewPath (${bot_state.currentPath.length} left)`; if (bot_state.currentPath.length === 0) { bot_state.targetGoalId = null; mode_str="NewPath End"; } bot_state.randomMoveCounter = 0; return [next_action, mode_str];
            } else { bot_state.targetGoalId = null; bot_state.currentPath = null; }
        }
        const valid_moves = []; for (let action_idx = 0; action_idx < 4; action_idx++) { const next_p = env.perform_move_action(pos, action_idx); const occupied_by_active = Object.values(all_bots_dict).some(b => b.id !== bot_id && b.pos.x === next_p.x && b.pos.y === next_p.y && (b.freezeTimer || 0) <= 0 ); if (env.is_valid(next_p) && !occupied_by_active) valid_moves.push(action_idx); }
        if (valid_moves.length === 0) return [-1, "Blocked"];
        const last_act = bot_state.lastAction; let reverse_action = -1; if (last_act >= 0 && last_act <= 3) { const reverse_map = {0:1, 1:0, 2:3, 3:2}; reverse_action = reverse_map[last_act]; }
        const non_reverse_moves = valid_moves.filter(m => m !== reverse_action); let chosen_move = -1;
        if (non_reverse_moves.length > 0) chosen_move = non_reverse_moves[Math.floor(Math.random() * non_reverse_moves.length)];
        else if (valid_moves.length > 0) chosen_move = valid_moves[Math.floor(Math.random() * valid_moves.length)];
        bot_state.currentPath = null; return [chosen_move, `Random (${bot_state.stuckCounter})`];
    }

    function _get_input_tensor_for_bot_hierarchy(bot_state, senses, config) { 
        const features = []; const vis_range = config.VISIBILITY_RANGE;
        const norm_capped = (val, cap = vis_range) => { const v = parseFloat(val); const c = parseFloat(cap); if (isNaN(v)) return 0.0; return (c <= 0) ? 0.0 : Math.sign(v) * Math.min(Math.abs(v), c) / c; };
        features.push(norm_capped(senses.wall_distance_N)); features.push(norm_capped(senses.wall_distance_S)); features.push(norm_capped(senses.wall_distance_W)); features.push(norm_capped(senses.wall_distance_E));
        features.push(norm_capped(senses.nearest_goal_dist)); features.push(norm_capped(senses.nearest_goal_dx)); features.push(norm_capped(senses.nearest_goal_dy));
        features.push(Math.min(1.0, Math.max(0.0, (senses.num_visible_goals || 0) / 5.0)));
        features.push(norm_capped(senses.nearest_opponent_dist)); features.push(norm_capped(senses.nearest_opponent_dx)); features.push(norm_capped(senses.nearest_opponent_dy));
        features.push(senses.opponent_is_frozen || 0.0); features.push(senses.opponent_type_HC || 0.0); features.push(senses.opponent_type_LN || 0.0); features.push(senses.opponent_type_PL || 0.0);
        features.push(senses.self_is_frozen || 0.0); features.push(senses.is_hallucinating || 0.0);
        for (let i = features.length; i < config.SENSORY_INPUT_DIM; i++) { features.push(0.0); }
        const final_features = features.slice(0, config.SENSORY_INPUT_DIM);
        return tf.tensor2d([final_features], [1, config.SENSORY_INPUT_DIM],'float32').expandDims(0);
    }

    function get_learning_action(bot_state, senses, env, all_bots_dict, direct_player_action, config) {
        let chosen_action = -1; let mode_code = 5; let mode_str = "Idle";
        
        const results = tf.tidy(`${bot_state.id}_LearningActionTidy`, () => {
            if (bot_state.freezeTimer > 0) { bot_state.target_coordinate = null; return { action: -1, mode_str: "Frozen", mode_code: 5 }; }
            
            let sensory_input_tensor;
            const is_mental_attack_active = bot_state.mental_attack_timer > 0;
            bot_state.is_hallucinating_state = is_mental_attack_active;

            if (is_mental_attack_active && config.MENTAL_ATTACK_USES_RECONSTRUCTION && bot_state.hierarchicalSystem) {
                const l0Name = bot_state.hierarchicalSystem.levelConfigsOriginal[0].name;
                const l0Reconstruction = bot_state.lastStepOutputs[l0Name]?.retrievedVal; 
                if (l0Reconstruction && !l0Reconstruction.isDisposed && l0Reconstruction.shape[2] === config.SENSORY_INPUT_DIM) {
                    sensory_input_tensor = tf.keep(l0Reconstruction.clone());
                    mode_str = "Hallucinating (Recon)"; mode_code = 6;
                } else {
                    sensory_input_tensor = _get_input_tensor_for_bot_hierarchy(bot_state, senses, config);
                    mode_str = "Hallucinating (Sensory Fallback)"; mode_code = 6;
                }
            } else {
                sensory_input_tensor = _get_input_tensor_for_bot_hierarchy(bot_state, senses, config);
                if (is_mental_attack_active) { mode_str = "Hallucinating (No Recon)"; mode_code = 6;} 
            }

            const hierarchy_inputs = { [bot_state.hierarchicalSystem.levelConfigsOriginal[0].name]: sensory_input_tensor };
            const external_inputs_for_hns_step = {};
            
            const motorActionIdx = (bot_state.lastAction >= 0 && bot_state.lastAction < config.NUM_ACTIONS) ? bot_state.lastAction : 0; 
            const motorTensor = tf.oneHot(tf.tensor1d([motorActionIdx],'int32'), config.NUM_ACTIONS).cast('float32').reshape([1,1,config.NUM_ACTIONS]);
            
            const l0ExpectedExternal = bot_state.hierarchicalSystem.level_expected_external_details[0]; // L0 is index 0
            if (l0ExpectedExternal && l0ExpectedExternal.name) {
                if (config.USE_RULES_AS_HNS_INPUT && l0ExpectedExternal.name === "L0_combined_motor_rule") {
                    const ruleActionTuple = get_hardcoded_action(bot_state, senses, env, all_bots_dict);
                    const ruleAction = ruleActionTuple[0];
                    const ruleActionIdx = (ruleAction >= 0 && ruleAction < config.NUM_ACTIONS) ? ruleAction : 0; 
                    const ruleTensor = tf.oneHot(tf.tensor1d([ruleActionIdx],'int32'), config.NUM_ACTIONS).cast('float32').reshape([1,1,config.NUM_ACTIONS]);
                    external_inputs_for_hns_step[l0ExpectedExternal.name] = tf.concat([motorTensor, ruleTensor], 2);
                    ruleTensor.dispose(); // Disposed after concat if not kept elsewhere
                } else if (l0ExpectedExternal.name === "L0_external_motor_efference") {
                    external_inputs_for_hns_step[l0ExpectedExternal.name] = motorTensor.clone(); // Clone as motorTensor might be disposed by tidy
                }
            }
            motorTensor.dispose(); // Dispose original motorTensor after use or clone
            
            const hnsStepResults = bot_state.hierarchicalSystem.step(bot_state.memoryState, bot_state.lastStepOutputs, hierarchy_inputs, external_inputs_for_hns_step, true);
            
            bot_state.memoryState.forEach(levelState => disposeMemStateWeights(levelState));
            bot_state.memoryState = hnsStepResults.nextBotStates; // these are already detached and kept if needed
            
            // Correctly dispose old tensors and update with new ones, maintaining structure
            Object.keys(bot_state.lastStepOutputs).forEach(levelName => {
                // Dispose the old tensor for this level
                if (bot_state.lastStepOutputs[levelName] && bot_state.lastStepOutputs[levelName].retrievedVal && !bot_state.lastStepOutputs[levelName].retrievedVal.isDisposed) {
                    bot_state.lastStepOutputs[levelName].retrievedVal.dispose();
                }
                // Update with the new tensor from hnsStepResults, wrapped in the expected object structure
                // hnsStepResults.newlyRetrievedValues[levelName] is already kept by HNS step if it's to be used.
                if (hnsStepResults.newlyRetrievedValues[levelName] && !hnsStepResults.newlyRetrievedValues[levelName].isDisposed) {
                    bot_state.lastStepOutputs[levelName] = { retrievedVal: hnsStepResults.newlyRetrievedValues[levelName] };
                } else {
                    // If no new tensor (e.g., error or already disposed), ensure the structure is maintained with a placeholder
                    logMessage(`Warning: New retrieved value for level ${levelName} is invalid or missing in get_learning_action. Resetting to zeros.`, "warn");
                    const dimForLevel = bot_state.hierarchicalSystem.dims[levelName] || config.SENSORY_INPUT_DIM; // Fallback dim
                    bot_state.lastStepOutputs[levelName] = { retrievedVal: tf.keep(tf.zeros([1, 1, dimForLevel])) };
                }
             });

            let action_logits;
            const policyHeadInputTensorName = config.POLICY_HEAD_INPUT_LEVEL_NAME;
            const policyInputTensor = bot_state.lastStepOutputs[policyHeadInputTensorName]?.retrievedVal;

            if (!policyInputTensor || policyInputTensor.isDisposed) {
                logMessage(`Error: Policy input tensor ${policyHeadInputTensorName} is invalid. Defaulting action.`, "error");
                chosen_action = -1; mode_str = "Error (Policy Input)";
            } else {
                if (bot_state.is_player_controlled) {
                    const control_influence_percent = Math.max(0.0, Math.min(100.0, config.PLAYER_CONTROL_PERCENT));
                    let player_action = -1; let player_mode_str = "Player Idle"; let player_mode_code = 5;
                    if (direct_player_action !== null && direct_player_action >= 0 && direct_player_action < config.NUM_ACTIONS) { player_action = direct_player_action; player_mode_str = `Player Direct (${player_action})`; player_mode_code = 3; bot_state.target_coordinate = null; }
                    else if (bot_state.target_coordinate) {
                        const target = bot_state.target_coordinate; const current_pos = bot_state.pos; const dist = env._manhattan_distance(current_pos, target); player_mode_code = 4;
                        if (dist === 0) { player_action = -1; player_mode_str = "Player Target Reached"; bot_state.target_coordinate = null;}
                        else {
                            let temp_action = -1;
                            if (dist === 1) { const opp = Object.values(all_bots_dict).find(b => b.id !== bot_state.id && b.pos.x === target.x && b.pos.y === target.y && (b.freezeTimer || 0) <= 0 && (!b.mental_attack_timer || b.mental_attack_timer <=0)); if (opp) { temp_action = 4; player_mode_str = "Player Target Punch"; } else { const goal = env.goals.find(g => !env.claimed_goals.has(g.id) && g.x === target.x && g.y === target.y); if (goal) { temp_action = 5; player_mode_str = "Player Target Claim"; } } }
                            if (temp_action === -1 && dist >=1 && dist <= config.MENTAL_ATTACK_RANGE) { const opp_ma = Object.values(all_bots_dict).find(b => b.id !== bot_state.id && b.pos.x === target.x && b.pos.y === target.y && (b.freezeTimer || 0) <= 0 && (!b.mental_attack_timer || b.mental_attack_timer <=0)); if (opp_ma) { temp_action = 6; player_mode_str = "Player Target MAtt"; } }
                            if (temp_action === -1) { const path = env.find_path(current_pos, target, all_bots_dict, bot_state.id); if (path && path.length > 0) { temp_action = path[0]; player_mode_str = `Player Target Move ${temp_action}`; } else { temp_action = -1; player_mode_str = "Player Target Blocked"; } }
                            player_action = temp_action;
                        }
                    }
                    if (control_influence_percent < 100.0 && player_action !== -1) {
                        const squeezed_policy_input = policyInputTensor.squeeze([1]);
                        action_logits = bot_state.policyHead.apply(squeezed_policy_input);
                        const ai_action = action_logits.argMax(-1).dataSync()[0];
                        if (Math.random() * 100 < control_influence_percent) { chosen_action = player_action; mode_str = player_mode_str; mode_code = player_mode_code; }
                        else { chosen_action = ai_action; mode_str = "AI Blend"; mode_code = 0; }
                    } else { chosen_action = player_action; mode_str = player_mode_str; mode_code = player_mode_code; }
                } else { 
                     if (is_mental_attack_active && config.MENTAL_ATTACK_USES_RECONSTRUCTION) { 
                        const squeezed_policy_input = policyInputTensor.squeeze([1]);
                        action_logits = bot_state.policyHead.apply(squeezed_policy_input); 
                        chosen_action = action_logits.argMax(-1).dataSync()[0];
                    } else if (is_mental_attack_active && !config.MENTAL_ATTACK_USES_RECONSTRUCTION) {
                        chosen_action = -1; 
                        mode_str = "Hallucinating (Action Blocked)"; mode_code = 6;
                    } else {
                        const base_explore_rate_percent = config.LEARNING_BOT_BASE_EXPLORATION_RATE; 
                        const current_anomaly_sum_for_explore = hnsStepResults.anomalies ? Object.values(hnsStepResults.anomalies).reduce((sum, t) => sum + t.dataSync()[0], 0) : 0;
                        const anomaly_factor = Math.min(3.0, 1.0 + current_anomaly_sum_for_explore * 10.0);
                        const current_exploration_threshold_percent = Math.min(98.0, base_explore_rate_percent * anomaly_factor); 
                        const is_exploring = Math.random() * 100 < current_exploration_threshold_percent;
                        if (is_exploring) {
                            const rule_explore_percent_chance = config.LEARNING_BOT_RULE_EXPLORE_PERCENT;
                            if (Math.random() * 100 < rule_explore_percent_chance) { mode_code = 2; let hc_mode; [chosen_action, hc_mode] = get_hardcoded_action(bot_state, senses, env, all_bots_dict); mode_str = `Explore Rule (${current_exploration_threshold_percent.toFixed(1)}%) -> ${hc_mode}`; }
                            else { mode_code = 1; chosen_action = Math.floor(Math.random() * config.NUM_ACTIONS); mode_str = `Explore Random (${current_exploration_threshold_percent.toFixed(1)}%)`; }
                        } else {
                            mode_code = 0; 
                            const squeezed_policy_input = policyInputTensor.squeeze([1]);
                            action_logits = bot_state.policyHead.apply(squeezed_policy_input); 
                            chosen_action = action_logits.argMax(-1).dataSync()[0]; mode_str = `Exploit (Predict ${chosen_action})`;
                        }
                    }
                }
            }
            
            let current_total_anomaly = 0;
            if(hnsStepResults.anomalies) {
                for(const lvlName in hnsStepResults.anomalies) { 
                    const anomalyTensor = hnsStepResults.anomalies[lvlName]; 
                    if (anomalyTensor && !anomalyTensor.isDisposed) current_total_anomaly += anomalyTensor.dataSync()[0]; 
                }
            }
            bot_state.last_anomaly_sum = current_total_anomaly; 
            
            disposeHnsResultsTensors(hnsStepResults); 

            if (typeof chosen_action !== 'number' || chosen_action < -1 || chosen_action >= config.NUM_ACTIONS) { 
                chosen_action = -1; 
                if (mode_code !== 5 && mode_code !== 6) mode_str += " -> IdleFallback"; 
            }
            return { action: chosen_action, mode_str, mode_code }; 
        }); 
        return results;
    }

    function disposeBotResources(bot) {
        if (bot.type === 'Learning') {
            if (bot.memoryState) { 
                bot.memoryState.forEach(levelState => disposeMemStateWeights(levelState));
                bot.memoryState = null; 
            }
            if (bot.lastStepOutputs) { 
                Object.values(bot.lastStepOutputs).forEach(out => { 
                    if(out.retrievedVal && !out.retrievedVal.isDisposed) out.retrievedVal.dispose(); 
                }); 
                bot.lastStepOutputs = {}; 
            }
            if (bot.policyHead && typeof bot.policyHead.dispose === 'function') { 
                bot.policyHead.dispose(); bot.policyHead = null; 
            }
            logMessage(`Disposed TFJS resources for Learning Bot ${bot.id}`);
        }
    }
    
    function _getProcessedHLC(rawHLC, globalConfig) {
        const processedHLC = JSON.parse(JSON.stringify(rawHLC)); 
        processedHLC.forEach(levelCfg => {
            if (levelCfg.name === "L0_SensoryMotor") {
                const motorDim = globalConfig.NUM_ACTIONS;
                if (globalConfig.USE_RULES_AS_HNS_INPUT) {
                    levelCfg.external_input_config = { 
                        source_signal_name: "L0_combined_motor_rule", 
                        dim: motorDim + globalConfig.NUM_ACTIONS,
                        // role for L0 NMM is taken from its nmm_params.external_signal_role
                    };
                } else {
                    levelCfg.external_input_config = {
                        source_signal_name: "L0_external_motor_efference",
                        dim: motorDim
                        // role for L0 NMM is taken from its nmm_params.external_signal_role
                    };
                }
            } else { 
                // For L1+, external_input_config should be a single object or null.
                // If it's an array in rawHLC, take the first. If not an object, set to null.
                if (Array.isArray(levelCfg.external_input_config) && levelCfg.external_input_config.length > 0) {
                    levelCfg.external_input_config = levelCfg.external_input_config[0]; 
                } else if (!levelCfg.external_input_config || typeof levelCfg.external_input_config !== 'object' || Array.isArray(levelCfg.external_input_config)) {
                    levelCfg.external_input_config = null; 
                }
            }
        });
        return processedHLC;
    }


    function setup_simulation(full_reset = false, new_environment_setting = false) {
        logMessage(`--- Setting up Simulation (Full Reset: ${full_reset}, New Env Config: ${new_environment_setting}) ---`);
        if (full_reset) {
            logMessage("Performing full reset..."); clientState.round = 0; clientState.stats = { hc_total_goals: 0, learning_total_goals: 0 };
            if (clientState.bots) { Object.values(clientState.bots).forEach(bot => { if (bot.type === 'Learning') disposeBotResources(bot); }); }
            clientState.bots = {}; 
            if (clientState.hnsSystem && typeof clientState.hnsSystem.dispose === 'function' && !clientState.hnsSystem.isDisposed) { 
                clientState.hnsSystem.dispose(); 
                clientState.hnsSystem = null; 
            }
            tf.disposeVariables(); logMessage("Disposed old HNS, bot tensors, and TF variables."); updateTfMemoryDisplay();
            clientState.environment = null; new_environment_setting = true; 
        } else { 
            clientState.round++;
            if (clientState.environment) {
                 let env_changed_flag = false;
                 let change_details = "Env structure change detected. Differences:\n";
                 let changed_any = false;

                 if (current_config.GRID_SIZE !== clientState.environment.size) {
                     change_details += `GRID_SIZE: config=${current_config.GRID_SIZE}, env=${clientState.environment.size}\n`;
                     changed_any = true;
                 }
                 if (current_config.NUM_HC_BOTS !== clientState.environment.num_hc_bots) {
                     change_details += `NUM_HC_BOTS: config=${current_config.NUM_HC_BOTS}, env=${clientState.environment.num_hc_bots}\n`;
                     changed_any = true;
                 }
                 if (current_config.NUM_LEARNING_BOTS !== clientState.environment.num_learning_bots) {
                     change_details += `NUM_LEARNING_BOTS: config=${current_config.NUM_LEARNING_BOTS}, env=${clientState.environment.num_learning_bots}\n`;
                     changed_any = true;
                 }
                 if (current_config.NUM_GOALS !== clientState.environment.num_goals_initial) {
                     change_details += `NUM_GOALS: config=${current_config.NUM_GOALS}, env=${clientState.environment.num_goals_initial}\n`;
                     changed_any = true;
                 }
                 env_changed_flag = changed_any;

                 if (env_changed_flag) {
                    logMessage(change_details + "Forcing full reset...", "warn");
                    return setup_simulation(true, true);
                 }
                 else if (new_environment_setting || current_config.RANDOMIZE_ENV_PER_ROUND) {
                    logMessage("Randomizing env for new round...");
                    clientState.environment.randomize();
                 }
                 else {
                    clientState.environment.reset_round_state();
                 }
            } else { // clientState.environment is null
                new_environment_setting = true;
            }
        }
        player_direct_actions = {}; 
        if (new_environment_setting || !clientState.environment) {
             logMessage("Recreating environment...");
             try {
                 const obs_range = [current_config.OBSTACLES_FACTOR_MIN, current_config.OBSTACLES_FACTOR_MAX];
                 const dist_factors = { MIN_GOAL_START_DISTANCE_FACTOR: current_config.MIN_GOAL_START_DISTANCE_FACTOR, MIN_BOT_START_DISTANCE_FACTOR: current_config.MIN_BOT_START_DISTANCE_FACTOR, MIN_BOT_GOAL_DISTANCE_FACTOR: current_config.MIN_BOT_GOAL_DISTANCE_FACTOR };
                 clientState.environment = new GridEnvironment_JS(current_config.GRID_SIZE, current_config.NUM_GOALS, obs_range, current_config.NUM_HC_BOTS, current_config.NUM_LEARNING_BOTS, dist_factors);
                 
                 if (clientState.environment.num_hc_bots !== current_config.NUM_HC_BOTS || clientState.environment.num_learning_bots !== current_config.NUM_LEARNING_BOTS) {
                     logMessage(`Env adjusted bot counts: HC=${clientState.environment.num_hc_bots}, Lrn=${clientState.environment.num_learning_bots}. Updating config.`, "warn");
                     current_config.NUM_HC_BOTS = clientState.environment.num_hc_bots;
                     current_config.NUM_LEARNING_BOTS = clientState.environment.num_learning_bots;
                     updateUIFromConfig(current_config); 
                 }
                 // If environment creation happened, it implies a full reset scenario or equivalent.
                 // The 'full_reset' flag for subsequent logic should reflect this.
                 if (!full_reset) { // If we weren't already in a full_reset path but created a new env
                    full_reset = true; // Treat as if it was a full reset for bot re-initialization
                 }
             } catch (e) { logMessage("FATAL: Environment creation failed: " + e.message, "error"); return false; }
        }
        
        const processedHLCForHNS = _getProcessedHLC(current_config.HIERARCHY_LEVEL_CONFIGS, current_config);

        if (full_reset || !clientState.hnsSystem || clientState.hnsSystem.isDisposed) { 
            if (clientState.hnsSystem && typeof clientState.hnsSystem.dispose === 'function' && !clientState.hnsSystem.isDisposed) clientState.hnsSystem.dispose();
            clientState.hnsSystem = new HierarchicalSystemV5_TFJS(processedHLCForHNS, current_config);
        }

        const new_bots = {}; const bot_starts = clientState.environment.start_positions || [];
        const required_bots_count = clientState.environment.num_hc_bots + clientState.environment.num_learning_bots;
        if (bot_starts.length !== required_bots_count) { logMessage(`FATAL MISMATCH: Env starts (${bot_starts.length}) != env bot counts (${required_bots_count}). Setup failed.`, "error"); return false; }
        try {
            for (const start_pos_data of bot_starts) {
                const bot_id = start_pos_data.id; const bot_type = start_pos_data.type; const start_pos = { x: start_pos_data.x, y: start_pos_data.y };
                if (clientState.bots[bot_id] && !full_reset) { 
                    const existing_bot = clientState.bots[bot_id];
                    existing_bot.pos = { ...start_pos }; existing_bot.steps = 0; existing_bot.goalsReachedThisRound = 0; existing_bot.freezeTimer = 0; existing_bot.mental_attack_timer = 0; existing_bot.lastAction = -1; existing_bot.mode = 'Reset'; existing_bot.senses = {}; existing_bot.lastPos = {x:-1,y:-1}; existing_bot.stuckCounter = 0; existing_bot.lastMoveAttempt = -1; existing_bot.currentPath = null; existing_bot.targetGoalId = null; existing_bot.randomMoveCounter = 0; existing_bot.is_hallucinating_state = false;
                    if (bot_type === 'Learning') {
                         existing_bot.last_anomaly_sum = 0.0; existing_bot.target_coordinate = null;
                         if (existing_bot.memoryState) { // Check if memoryState exists before disposing
                            existing_bot.memoryState.forEach(levelState => disposeMemStateWeights(levelState));
                         }
                         existing_bot.memoryState = clientState.hnsSystem.getInitialStates(); 
                         Object.values(existing_bot.lastStepOutputs).forEach(out => { if(out.retrievedVal && !out.retrievedVal.isDisposed) out.retrievedVal.dispose(); }); 
                         existing_bot.lastStepOutputs = {}; 
                         clientState.hnsSystem.levelConfigsOriginal.forEach(lvlConfig => { 
                             existing_bot.lastStepOutputs[lvlConfig.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lvlConfig.dim])) }; 
                         }); 
                         existing_bot.is_player_controlled = (clientState.playerBotId === bot_id);
                    } new_bots[bot_id] = existing_bot;
                } else { 
                    if (clientState.bots[bot_id] && clientState.bots[bot_id].type === 'Learning') disposeBotResources(clientState.bots[bot_id]);
                    if (bot_type === 'Hardcoded') new_bots[bot_id] = create_hardcoded_bot_instance(bot_id, start_pos);
                    else if (bot_type === 'Learning') { 
                        const new_learning_bot = create_learning_bot_instance(bot_id, start_pos, current_config, clientState.hnsSystem); 
                        if (clientState.playerOriginalBotId === bot_id) { new_learning_bot.is_player_controlled = true; clientState.playerBotId = bot_id; } 
                        new_bots[bot_id] = new_learning_bot; 
                    }
                }
            }
            clientState.bots = new_bots;
            if (clientState.playerOriginalBotId && !clientState.bots[clientState.playerOriginalBotId]) { logMessage(`Player's original bot ${clientState.playerOriginalBotId} no longer exists. Player removed.`, "warn"); clientState.playerBotId = null; clientState.playerOriginalBotId = null; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); }
            else if (clientState.playerOriginalBotId && clientState.bots[clientState.playerOriginalBotId]) { clientState.bots[clientState.playerOriginalBotId].is_player_controlled = true; clientState.playerBotId = clientState.playerOriginalBotId; }
        } catch (e) { logMessage("Error: Bot creation/reset failed: " + e.message + "\nStack: " + e.stack, "error"); return false; }
        logMessage(`Setup complete for Round ${clientState.round}. Active Bots: ${Object.keys(clientState.bots).join(', ')}`); updateTfMemoryDisplay(); return true;
    }
    
    function simulation_step() {
        if (!clientState.environment || !clientState.bots || Object.keys(clientState.bots).length === 0) return false; 
        let round_over = false; let max_steps_reached_for_all = true;
        const bot_ids_this_step = Object.keys(clientState.bots); const current_direct_actions = { ...player_direct_actions }; player_direct_actions = {}; 
        for (const bot_id of bot_ids_this_step) {
            if (!clientState.bots[bot_id]) continue; const bot_state = clientState.bots[bot_id];
            if (bot_state.steps >= current_config.MAX_STEPS_PER_ROUND) continue; else max_steps_reached_for_all = false;
            let action_val = -1; let mode_str = "Idle"; let mode_code = 5; let next_pos = { ...bot_state.pos };
            try {
                bot_state.senses = clientState.environment.get_sensory_data(bot_state, clientState.bots, current_config.VISIBILITY_RANGE);
                if (bot_state.type === 'Hardcoded') { [action_val, mode_str] = get_hardcoded_action(bot_state, bot_state.senses, clientState.environment, clientState.bots); mode_code = 2; }
                else if (bot_state.type === 'Learning') { let direct_action_val = null; if (bot_state.is_player_controlled && current_direct_actions[bot_id] !== undefined) { direct_action_val = current_direct_actions[bot_id]; } const learningResult = get_learning_action(bot_state, bot_state.senses, clientState.environment, clientState.bots, direct_action_val, current_config); action_val = learningResult.action; mode_str = learningResult.mode_str; mode_code = learningResult.mode_code; }
                bot_state.mode = mode_str; const action_attempted = action_val; 
                
                let can_act = bot_state.freezeTimer <= 0;
                if (bot_state.mental_attack_timer > 0 && !current_config.MENTAL_ATTACK_USES_RECONSTRUCTION) {
                    can_act = false; 
                    if (bot_state.type === 'Learning') bot_state.mode = "Hallucinating (Action Blocked)";
                }


                if (action_attempted !== -1 && can_act) {
                    if (action_attempted >= 0 && action_attempted <= 3) { const intended_pos = clientState.environment.perform_move_action(bot_state.pos, action_attempted); const occupied = Object.values(clientState.bots).some(b => b.id !== bot_id && b.pos.x === intended_pos.x && b.pos.y === intended_pos.y); if (clientState.environment.is_valid(intended_pos) && !occupied) next_pos = intended_pos; else bot_state.mode += " (Blocked)"; }
                    else if (action_attempted === 4) { const target_bot = Object.values(clientState.bots).find(ob => ob.id !== bot_id && clientState.environment._manhattan_distance(bot_state.pos, ob.pos) === 1 && (ob.freezeTimer || 0) <= 0 && (!ob.mental_attack_timer || ob.mental_attack_timer <=0)); if (target_bot) { target_bot.freezeTimer = current_config.FREEZE_DURATION; bot_state.mode += ` (Hit ${target_bot.id})`;} else bot_state.mode += " (Punch Miss)"; }
                    else if (action_attempted === 5) { const adj_goal = clientState.environment.get_adjacent_unclaimed_goal(bot_state.pos); if (adj_goal && clientState.environment.claim_goal(adj_goal.id, bot_id)) { bot_state.goalsReachedThisRound++; bot_state.goalsReachedTotal++; if (bot_state.type === 'Hardcoded') clientState.stats.hc_total_goals++; else clientState.stats.learning_total_goals++; bot_state.mode += ` (Claimed ${adj_goal.id})`; if (clientState.environment.are_all_goals_claimed()) { round_over = true; logMessage(`--- Round ${clientState.round} Over: All goals claimed! ---`);}} else bot_state.mode += " (Claim Failed)"; }
                    else if (action_attempted === 6) { bot_state.mode += " (MAtt)"; const potential_targets = []; for (const ob_id in clientState.bots) { const ob_state = clientState.bots[ob_id]; if (ob_id === bot_id || ob_state.freezeTimer > 0 || ob_state.mental_attack_timer > 0) continue; const dist = clientState.environment._manhattan_distance(bot_state.pos, ob_state.pos); if (dist >= 1 && dist <= current_config.MENTAL_ATTACK_RANGE) potential_targets.push(ob_state); } if (potential_targets.length > 0) { potential_targets.sort((a,b) => clientState.environment._manhattan_distance(bot_state.pos, a.pos) - clientState.environment._manhattan_distance(bot_state.pos, b.pos)); const target_bot_to_attack = potential_targets[0]; target_bot_to_attack.mental_attack_timer = current_config.MENTAL_ATTACK_DURATION; bot_state.mode += ` (Hit ${target_bot_to_attack.id})`; } else bot_state.mode += " (NoTgt)"; }
                }
                bot_state.pos = next_pos; bot_state.steps++; if (bot_state.freezeTimer > 0) bot_state.freezeTimer--; if (bot_state.mental_attack_timer > 0) bot_state.mental_attack_timer--; bot_state.lastAction = action_attempted;
            } catch (e) { logMessage(`CRITICAL Error processing bot ${bot_id}: ${e.message}. Stack: ${e.stack}`, "error"); clientState.isRunning = false; statusEl.textContent = `Status: Error processing bot ${bot_id}. Simulation stopped.`; return false; }
        } 
        if (!round_over && max_steps_reached_for_all) { round_over = true; logMessage(`--- Round ${clientState.round} Over: Max steps reached! ---`); }
        return !round_over; 
    }

    function simulation_loop() {
        if (!clientState.isRunning) return;
        const loop_start_time = performance.now(); 
        const continue_round = simulation_step(); 
        
        if (!clientState.isRunning) { 
            stopSimulation(); 
            return; 
        }

        if (!continue_round) { 
             const new_env_next = current_config.RANDOMIZE_ENV_PER_ROUND;
             if (setup_simulation(false, new_env_next)) { 
                 statusEl.textContent = `Status: Starting Round ${clientState.round}...`; 
                 visualizer.update(clientState); 
                 updateInfoPanel(); 
                 updateButtonStates(); 
                 updateMobileControls(); 
             } else { 
                 logMessage("Error: Failed next round setup. Stopping.", "error"); 
                 stopSimulation(); 
                 statusEl.textContent = 'Status: Error setting up next round. Stopped.'; 
                 return; 
             }
        } else { 
            visualizer.update(clientState); 
            updateInfoPanel(); 
        }
        const elapsed_time = performance.now() - loop_start_time; const target_delay = current_config.SIMULATION_SPEED_MS; const delay = Math.max(1, target_delay - elapsed_time); 
        simulation_loop_task = setTimeout(simulation_loop, delay);
        
        if (clientState.round % 2 === 0 && clientState.bots[Object.keys(clientState.bots)[0]]?.steps % 20 === 0) {
             updateTfMemoryDisplay();
        }
    }

    class Visualizer { 
        constructor(canvasCtx, gridContainer) { this.ctx = canvasCtx; this.canvas = canvasCtx.canvas; this.gridContainer = gridContainer; this.gridSize = 0; this.cellSize = 0; this.currentGoals = []; this.currentObstacles = new Set(); this.claimedGoalsIDs = new Set(); this.lastContainerWidth = 0; this.ctx.imageSmoothingEnabled = false; }
        updateGridDimensions(newGridSize) { if (!this.gridContainer || newGridSize === undefined || newGridSize <= 0) return; const gridSizeNum = Number(newGridSize); if (isNaN(gridSizeNum) || gridSizeNum <= 0) return; const availableWidth = Math.max(300, this.gridContainer.offsetWidth - 2); const newCellSize = Math.max(4, Math.floor(availableWidth / gridSizeNum)); if (gridSizeNum !== this.gridSize || newCellSize !== this.cellSize || this.gridContainer.offsetWidth !== this.lastContainerWidth) { this.gridSize = gridSizeNum; this.cellSize = newCellSize; this.canvas.width = this.gridSize * this.cellSize; this.canvas.height = this.gridSize * this.cellSize; this.lastContainerWidth = this.gridContainer.offsetWidth; } }
        updateData(environmentState) { if (!environmentState) return; this.updateGridDimensions(environmentState.size); this.currentGoals = environmentState.goals || []; this.currentObstacles = new Set((environmentState.obstacles || []).map(obs => `${obs[0]},${obs[1]}`)); this.claimedGoalsIDs = new Set(environmentState.claimedGoals || []); }
        drawGrid() { if (!this.ctx || !this.gridSize || !this.cellSize) return; const canvasWidth = this.canvas.width; const canvasHeight = this.canvas.height; this.ctx.clearRect(0, 0, canvasWidth, canvasHeight); this.ctx.fillStyle = '#ffffff'; this.ctx.fillRect(0, 0, canvasWidth, canvasHeight); if (this.cellSize > 5) { this.ctx.strokeStyle = '#f0f0f0'; this.ctx.lineWidth = 1; for (let i = 0; i <= this.gridSize; i++) { const pos = Math.round(i * this.cellSize) + 0.5; this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, canvasHeight); this.ctx.stroke(); this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(canvasWidth, pos); this.ctx.stroke(); } } else { this.ctx.strokeStyle = '#e0e0e0'; this.ctx.lineWidth = 0.5; this.ctx.strokeRect(0.5, 0.5, canvasWidth - 1, canvasHeight - 1); } this.ctx.fillStyle = '#595959'; this.currentObstacles.forEach(obsString => { try { const [x, y] = obsString.split(',').map(Number); if(x>=0 && x<this.gridSize && y>=0 && y<this.gridSize) { this.ctx.fillRect(Math.floor(x * this.cellSize), Math.floor(y * this.cellSize), Math.ceil(this.cellSize), Math.ceil(this.cellSize)); } } catch(e){ /* ignore */ } }); this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; const goalRadius = Math.max(1.5, this.cellSize * 0.35); const goalFontSize = Math.max(7, Math.floor(this.cellSize * 0.5)); this.currentGoals.forEach((goal) => { if(!goal || goal.x === undefined) return; const drawX = Math.floor(goal.x * this.cellSize); const drawY = Math.floor(goal.y * this.cellSize); const centerX = drawX + this.cellSize / 2; const centerY = drawY + this.cellSize / 2; if(goal.x>=0 && goal.x<this.gridSize && goal.y>=0 && goal.y<this.gridSize) { if (this.claimedGoalsIDs.has(goal.id)) { this.ctx.fillStyle = '#d9d9d9'; this.ctx.fillRect(drawX, drawY, Math.ceil(this.cellSize), Math.ceil(this.cellSize)); if (this.cellSize > 8) { this.ctx.fillStyle = '#8c8c8c'; this.ctx.font = `bold ${goalFontSize}px sans-serif`; this.ctx.fillText("X", centerX, centerY); } } else { this.ctx.fillStyle = 'gold'; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, goalRadius, 0, Math.PI * 2); this.ctx.fill(); if (this.cellSize > 4) { this.ctx.strokeStyle = '#d48806'; this.ctx.lineWidth = 0.5; this.ctx.stroke(); } if (this.cellSize > 10) { this.ctx.fillStyle = '#434343'; this.ctx.font = `bold ${goalFontSize*0.8}px sans-serif`; this.ctx.fillText("G", centerX, centerY + 1); } } } }); this.ctx.lineWidth = 1; }
        drawBot(bot) { if (!bot || !bot.pos || bot.pos.x === undefined) return; const drawX = bot.pos.x * this.cellSize; const drawY = bot.pos.y * this.cellSize; const centerX = drawX + this.cellSize / 2; const centerY = drawY + this.cellSize / 2; const radius = Math.max(2, this.cellSize * 0.4); let color = '#888'; let isAvailableToJoin = false; if (bot.type === 'Hardcoded') { color = getComputedStyle(document.documentElement).getPropertyValue('--hardcoded-color').trim() || '#1890ff'; } else if (bot.type === 'Learning') { if (bot.is_player_controlled) { color = getComputedStyle(document.documentElement).getPropertyValue('--player-controlled-color').trim() || '#52c41a'; } else { color = getComputedStyle(document.documentElement).getPropertyValue('--learning-color').trim() || '#f5222d'; if (clientState.playerBotId === null) { isAvailableToJoin = true; } } } this.ctx.fillStyle = color; this.ctx.globalAlpha = (bot.mental_attack_timer > 0) ? 0.5 : 0.95; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); this.ctx.fill(); if (bot.is_player_controlled) { this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--player-controlled-color').trim(); this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.15)); this.ctx.setLineDash([Math.max(1, this.cellSize * 0.1), Math.max(1, this.cellSize * 0.1)]); this.ctx.stroke(); this.ctx.setLineDash([]); } else if (isAvailableToJoin) { this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--learning-available-color').trim(); this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.1)); this.ctx.setLineDash([Math.max(2, this.cellSize * 0.15), Math.max(1, this.cellSize * 0.1)]); this.ctx.strokeRect(drawX + this.ctx.lineWidth / 2, drawY + this.ctx.lineWidth / 2, this.cellSize - this.ctx.lineWidth, this.cellSize - this.ctx.lineWidth); this.ctx.setLineDash([]); } if (bot.freezeTimer > 0) { this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--frozen-color').trim(); this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.1)); this.ctx.globalAlpha = 0.8; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, radius * 1.15, 0, 2 * Math.PI); this.ctx.stroke(); } if (bot.mental_attack_timer > 0) { this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--hallucinating-color').trim(); this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.1)); this.ctx.globalAlpha = 0.7; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, radius * 0.7, 0, 2 * Math.PI); this.ctx.stroke(); } this.ctx.globalAlpha = 1.0; if (this.cellSize > 14) { this.ctx.fillStyle = 'white'; this.ctx.font = `bold ${Math.max(6, Math.floor(this.cellSize * 0.35))}px sans-serif`; const idNum = bot.id.match(/\d+/); const label = bot.id[0] + (idNum ? idNum[0] : ''); this.ctx.fillText(label, centerX, centerY + 1); } this.ctx.lineWidth = 1; }
        drawTarget(targetCoord) { if (!targetCoord || !this.cellSize || targetCoord.x === null || targetCoord.y === null) return; const centerX = targetCoord.x * this.cellSize + this.cellSize / 2; const centerY = targetCoord.y * this.cellSize + this.cellSize / 2; const crossSize = this.cellSize * 0.4; this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--target-crosshair-color').trim(); this.ctx.lineWidth = Math.max(1, this.cellSize * 0.08); this.ctx.globalAlpha = 0.8; this.ctx.beginPath(); this.ctx.moveTo(centerX - crossSize, centerY); this.ctx.lineTo(centerX + crossSize, centerY); this.ctx.moveTo(centerX, centerY - crossSize); this.ctx.lineTo(centerX, centerY + crossSize); this.ctx.stroke(); this.ctx.globalAlpha = 1.0; this.ctx.lineWidth = 1; }
        update(state) { if (!state) return; if (state.environment && typeof state.environment.get_state === 'function') { this.updateData(state.environment.get_state()); } else if (state.environment) { this.updateData(state.environment); } this.drawGrid(); Object.values(state.bots || {}).forEach(bot => this.drawBot(bot)); if (clientState.playerBotId && clientState.playerTarget) { this.drawTarget(clientState.playerTarget); } }
        getBotAtCoord(gridX, gridY) { for (const botId in clientState.bots) { const bot = clientState.bots[botId]; if (bot.pos && bot.pos.x === gridX && bot.pos.y === gridY) return bot; } return null; }
    }
    
    function updateInfoPanel() { roundInfoEl.textContent = `Round: ${clientState.round}`; document.getElementById('hc-total-goals').textContent = clientState.stats.hc_total_goals || 0; document.getElementById('learning-total-goals').textContent = clientState.stats.learning_total_goals || 0; let botCounts = { Hardcoded: 0, Learning: 0 }; let botInfoHTML = ''; let totalAnomalySum = 0; let learningBotCountWithAnomaly = 0; const sortedBotIds = Object.keys(clientState.bots || {}).sort((a, b) => { const typeA = clientState.bots[a]?.type || ''; const typeB = clientState.bots[b]?.type || ''; const isPlayerA = clientState.bots[a]?.is_player_controlled || false; const isPlayerB = clientState.bots[b]?.is_player_controlled || false; if(isPlayerA && !isPlayerB) return -1; if(!isPlayerA && isPlayerB) return 1; const typeOrder = { 'Learning': 1, 'Hardcoded': 2 }; if(typeOrder[typeA] !== typeOrder[typeB]) return (typeOrder[typeA] || 99) - (typeOrder[typeB] || 99); const numA = parseInt(a.match(/\d+/)?.[0] || '0'); const numB = parseInt(b.match(/\d+/)?.[0] || '0'); return numA - numB; }); sortedBotIds.forEach(botId => { const bot = clientState.bots[botId]; if (!bot) return; const type = bot.type || 'Unknown'; let typeClass = ''; const isPlayerControlled = bot.is_player_controlled || false; if (type === 'Hardcoded') typeClass = 'hc-color'; else if (type === 'Learning') typeClass = isPlayerControlled ? 'pl-color' : 'ln-color'; if(type in botCounts) botCounts[type]++; let statusText = "Active"; let statusClasses = "status-tag"; if (bot.freezeTimer > 0) { statusText = `Frozen (${bot.freezeTimer})`; statusClasses += " frozen-status"; } else if (bot.mental_attack_timer > 0) { statusText = `Hallucinating (${bot.mental_attack_timer})`; statusClasses += " hallucinating-status"; } let anomalyText = ''; if (type === 'Learning' && bot.last_anomaly_sum !== undefined && bot.last_anomaly_sum !== null) { totalAnomalySum += bot.last_anomaly_sum; learningBotCountWithAnomaly++; anomalyText = ` | Anomaly Sum: ${bot.last_anomaly_sum.toFixed(4)}`; } const playerMarker = isPlayerControlled ? '<span class="player-controlled-marker">(Player)</span>' : ''; botInfoHTML += `<div class="bot-type-info"><b><span class="${typeClass}">${type} ${bot.id}</span></b>${playerMarker} Pos: (${bot.pos?.x ?? '?', bot.pos?.y ?? '?'}) | Mode: ${bot.mode || 'N/A'} | Status: <span class="${statusClasses}">${statusText}</span> | Goals: ${bot.goalsReachedThisRound || 0} ${anomalyText}</div>`; }); const avgAnomaly = learningBotCountWithAnomaly > 0 ? (totalAnomalySum / learningBotCountWithAnomaly).toFixed(4) : 'N/A'; document.getElementById('learning-avg-anomaly').textContent = avgAnomaly; botsInfoContainerEl.innerHTML = botInfoHTML || '<div class="bot-type-info"><b>No bots found.</b></div>'; }
    function updateButtonStates() { const hasChanges = !!document.querySelector('.param-item.changed'); const canJoin = Object.values(clientState.bots || {}).some(b => b.type === 'Learning' && !b.is_player_controlled); const isPlayer = clientState.playerBotId !== null; startButton.disabled = clientState.isRunning || clientState.needsFullReset || clientState.needsRoundReset || hasChanges; stopButton.disabled = !clientState.isRunning; resetRoundButton.disabled = clientState.isRunning; resetFullButton.disabled = clientState.isRunning; applyParamsButton.disabled = clientState.isRunning || !hasChanges; joinButton.disabled = isPlayer || !canJoin; joinButton.style.display = 'flex'; leaveButton.disabled = !isPlayer; leaveButton.style.display = isPlayer ? 'flex' : 'none'; saveParamsButton.disabled = false; loadParamsButton.disabled = clientState.isRunning; resetParamsButton.disabled = clientState.isRunning; document.querySelectorAll('.param-item').forEach(item => { const key = item.dataset.param; const hintEl = item.querySelector('.reset-hint'); if (!hintEl) return; const rAllK = ['GRID_SIZE', 'NUM_HC_BOTS', 'NUM_LEARNING_BOTS', 'NUM_GOALS', 'SENSORY_INPUT_DIM', 'HIERARCHY_LEVEL_CONFIGS', 'POLICY_HEAD_INPUT_LEVEL_NAME', 'USE_RULES_AS_HNS_INPUT', 'NUM_ACTIONS']; const rRndK = ['MAX_STEPS_PER_ROUND', 'VISIBILITY_RANGE', 'OBSTACLES_FACTOR_MIN', 'OBSTACLES_FACTOR_MAX', 'MIN_GOAL_START_DISTANCE_FACTOR', 'MIN_BOT_START_DISTANCE_FACTOR', 'MIN_BOT_GOAL_DISTANCE_FACTOR', 'MENTAL_ATTACK_RANGE', 'MENTAL_ATTACK_DURATION']; let needsReset = false; let resetText = ''; if (clientState.needsFullReset && rAllK.includes(key)) { needsReset = true; resetText = '(Reset All Req.)'; } else if (clientState.needsRoundReset && (rRndK.includes(key) || rAllK.includes(key))) { needsReset = true; resetText = '(Reset Req.)'; } item.classList.toggle('needs-reset', needsReset); hintEl.style.display = needsReset ? 'inline' : 'none'; hintEl.textContent = resetText; }); }
    function updateMobileControls() { if (clientState.playerBotId && clientState.isRunning) mobileControlsEl.classList.add('enabled'); else mobileControlsEl.classList.remove('enabled'); }
    function copyConfig(configObj) { try { return JSON.parse(JSON.stringify(configObj || {})); } catch(e) { console.error("Failed to copy config", e); return {}; } }
    function updateUIFromConfig(configToUse) { if (!configToUse) return; for(const key in paramInputs) { if (configToUse.hasOwnProperty(key)) { const input = paramInputs[key]; let value = configToUse[key]; if (input.type === 'checkbox') { input.checked = Boolean(value); } else if (input.type === 'range') { input.value = Number(value || 0); if (rangeValueDisplays[key]) rangeValueDisplays[key].textContent = `${input.value}%`; } else if (input.tagName === 'SELECT') { input.value = String(value ?? ''); } else if (input.tagName === 'TEXTAREA') { input.value = (typeof value === 'string') ? value : JSON.stringify(value, null, 2); } else { if (typeof value === 'number' && input.step && input.step.includes('.')) { const decimals = (input.step.split('.')[1] || '').length; if (decimals > 0) value = parseFloat(value || 0).toFixed(decimals); } else if (typeof value === 'number'){ value = Math.round(value); } input.value = String(value ?? ''); } } } markParamsApplied(); updateButtonStates(); updateMobileControls(); }
    function getUIConfig() { const config = {}; const baseConfig = Object.keys(current_config).length > 0 ? current_config : uiDefaults; for(const key in paramInputs) { const input = paramInputs[key]; let value; if (input.type === 'checkbox') { value = input.checked; } else { value = input.value; } let defaultType = 'string'; const defaultValue = baseConfig[key] ?? null; if (defaultValue !== null) defaultType = typeof defaultValue; else if (input.type === 'number' || input.type === 'range') defaultType = 'number'; else if (input.type === 'checkbox') defaultType = 'boolean'; else if (input.tagName === 'TEXTAREA') defaultType = 'object'; try { if (input.type !== 'checkbox' && input.tagName !== 'TEXTAREA' && value === '' && defaultValue !== null) { value = defaultValue; input.value = defaultValue; if (input.type === 'range' && rangeValueDisplays[key]) rangeValueDisplays[key].textContent = `${defaultValue}%`; } if (defaultType === 'number' || input.type === 'range') { value = parseFloat(value); if (isNaN(value)) throw new Error("NaN"); if (input.min !== "" && value < parseFloat(input.min)) value = parseFloat(input.min); if (input.max !== "" && value > parseFloat(input.max)) value = parseFloat(input.max); if (input.step && !input.step.includes('.')) { value = Math.round(value); } else if (input.step && input.step.includes('.')) { const decimals = (input.step.split('.')[1] || '').length; if(decimals > 0) value = parseFloat(value.toFixed(decimals)); } } else if (defaultType === 'boolean') { value = input.checked; } else if (defaultType === 'object' && input.tagName === 'TEXTAREA') { try { value = JSON.parse(value); } catch (jsonErr) { throw new Error("Invalid JSON in textarea"); } } else { value = String(value); } config[key] = value; } catch (e) { logMessage(`Error parsing UI value for ${key} ('${input.value}'), using default: ${defaultValue}. Error: ${e.message}`, "error"); config[key] = defaultValue; if (defaultValue !== null) { if (input.tagName === 'TEXTAREA') input.value = JSON.stringify(defaultValue, null, 2); else input.value = defaultValue; if (input.type === 'range' && rangeValueDisplays[key]) rangeValueDisplays[key].textContent = `${defaultValue}%`; } else input.value = (input.tagName === 'TEXTAREA') ? '[]' : ''; } } return config; }
    function markParamChanged(key) { if(clientState.isRunning) return; const paramItem = paramItems[key]; const input = paramInputs[key]; if (!paramItem || !input || !current_config) return; const uiConf = getUIConfig(); const uiValue = uiConf[key]; const serverValue = current_config[key]; let isDifferent = false; if (typeof uiValue === 'object' && typeof serverValue === 'object') { isDifferent = JSON.stringify(uiValue) !== JSON.stringify(serverValue); } else if (typeof uiValue === 'number' && typeof serverValue === 'number') { isDifferent = Math.abs(uiValue - serverValue) > 1e-9; } else { isDifferent = String(uiValue) !== String(serverValue); } if (isDifferent) { paramItem.classList.add('changed'); } else { paramItem.classList.remove('changed'); } updateButtonStates(); updateMobileControls(); }
    function markParamsApplied() { document.querySelectorAll('.param-item.changed').forEach(el => el.classList.remove('changed')); updateButtonStates(); updateMobileControls(); }
    function clearResetHints() { clientState.needsFullReset = false; clientState.needsRoundReset = false; updateButtonStates(); updateMobileControls(); }
    
    function handleParamInputChange(key) {
        markParamChanged(key);
    }

    function checkForNeededResets() { if(clientState.isRunning) return; const uiConfig = getUIConfig(); let needsF = false; let needsR = false; const rAllK = ['GRID_SIZE', 'NUM_HC_BOTS', 'NUM_LEARNING_BOTS', 'NUM_GOALS', 'SENSORY_INPUT_DIM', 'HIERARCHY_LEVEL_CONFIGS', 'POLICY_HEAD_INPUT_LEVEL_NAME', 'USE_RULES_AS_HNS_INPUT', 'NUM_ACTIONS']; const rRndK = ['MAX_STEPS_PER_ROUND', 'VISIBILITY_RANGE', 'OBSTACLES_FACTOR_MIN', 'OBSTACLES_FACTOR_MAX', 'MIN_GOAL_START_DISTANCE_FACTOR', 'MIN_BOT_START_DISTANCE_FACTOR', 'MIN_BOT_GOAL_DISTANCE_FACTOR', 'MENTAL_ATTACK_RANGE', 'MENTAL_ATTACK_DURATION']; let hasAnyChanges = false; for(const key in uiConfig) { if(current_config && current_config.hasOwnProperty(key)) { const uiVal = uiConfig[key]; const srvVal = current_config[key]; let different = false; if (typeof uiVal === 'object' && typeof srvVal === 'object') { different = JSON.stringify(uiVal) !== JSON.stringify(srvVal); } else if (typeof uiVal === 'number' && typeof srvVal === 'number') { different = Math.abs(uiVal - srvVal) > 1e-9; } else { different = String(uiVal) !== String(srvVal); } const item = paramItems[key]; if(different) { hasAnyChanges = true; if(item) item.classList.add('changed'); if (rAllK.includes(key)) needsF = true; else if (rRndK.includes(key)) needsR = true; } else { if(item) item.classList.remove('changed'); } } } clientState.needsFullReset = needsF; clientState.needsRoundReset = needsR || needsF; updateButtonStates(); updateMobileControls(); }
    function saveParamsToLocalStorage() { try { const uiConf = getUIConfig(); localStorage.setItem(LOCAL_STORAGE_KEY_UI, JSON.stringify(uiConf)); alert('UI Parameters saved!'); } catch (e) { logMessage('Failed to save UI params: ' + e.message, "error"); alert('Error saving UI parameters.'); } }
    function loadParamsFromLocalStorage() { if(clientState.isRunning) { alert("Stop simulation first."); return; } try { const saved = localStorage.getItem(LOCAL_STORAGE_KEY_UI); if (saved) { const parsed = JSON.parse(saved); updateUIFromConfig(parsed); markParamsApplied(); statusEl.textContent = "Status: UI Params Loaded. Apply or check resets."; checkForNeededResets(); alert('UI Parameters loaded. Review & Apply/Reset if needed.'); } else alert('No saved UI parameters found.'); } catch (e) { logMessage('Failed to load UI params: ' + e.message, "error"); alert('Error loading UI parameters.'); } }
    function resetParamsToDefault() { if(clientState.isRunning) { alert("Stop simulation first."); return; } const baseConfig = copyConfig(DEFAULT_CONFIG); updateUIFromConfig(baseConfig); markParamsApplied(); statusEl.textContent = "Status: UI Reset to Default. Apply/Reset check."; checkForNeededResets(); }
    function updateTargetIndicator() { if (clientState.playerTarget && clientState.playerBotId) { targetIndicatorEl.textContent = `Target: (${clientState.playerTarget.x}, ${clientState.playerTarget.y})`; targetIndicatorEl.style.display = 'block'; } else { targetIndicatorEl.textContent = 'Target: None'; targetIndicatorEl.style.display = 'none'; } }
    function sendTargetUpdate(targetCoord) { const now = Date.now(); if (isDragging && lastSentTargetTime && now - lastSentTargetTime < TARGET_UPDATE_INTERVAL_MS) return; if (clientState.playerBotId) { const currentTarget = clientState.playerTarget; const changed = (targetCoord === null && currentTarget !== null) || (targetCoord !== null && currentTarget === null) || (targetCoord !== null && currentTarget !== null && (targetCoord.x !== currentTarget.x || targetCoord.y !== currentTarget.y)); if (changed) { clientState.playerTarget = targetCoord; if (clientState.bots[clientState.playerBotId]) { clientState.bots[clientState.playerBotId].target_coordinate = targetCoord; } updateTargetIndicator(); if (isDragging) lastSentTargetTime = now; } } }
    function handleCanvasInteraction(event) { if (!visualizer || !visualizer.cellSize) return; event.preventDefault(); const rect = canvasEl.getBoundingClientRect(); let clientX, clientY; if (event.type.startsWith('touch')) { if (event.type === 'touchend' && event.changedTouches.length > 0) { clientX = event.changedTouches[0].clientX; clientY = event.changedTouches[0].clientY; } else if (event.type === 'touchmove' && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else if (event.type === 'touchstart' && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else { return; } } else { clientX = event.clientX; clientY = event.clientY; } const canvasX = clientX - rect.left; const canvasY = clientY - rect.top; const targetGridX = Math.floor(canvasX / visualizer.cellSize); const targetGridY = Math.floor(canvasY / visualizer.cellSize); if (targetGridX < 0 || targetGridX >= visualizer.gridSize || targetGridY < 0 || targetGridY >= visualizer.gridSize) { if (isDragging) isDragging = false; return; } if (clientState.playerBotId) { const playerBot = clientState.bots[clientState.playerBotId]; if (!playerBot) { clientState.playerBotId = null; clientState.playerOriginalBotId = null; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); updatePlayerInfo(); updateButtonStates(); updateMobileControls(); return; } if (targetGridX === playerBot.pos.x && targetGridY === playerBot.pos.y && (event.type === 'mouseup' || event.type === 'touchend')) { sendTargetUpdate(null); } else { sendTargetUpdate({ x: targetGridX, y: targetGridY }); } } else { if (event.type === 'mouseup' || event.type === 'touchend') { const clickedBot = visualizer.getBotAtCoord(targetGridX, targetGridY); if (clickedBot && clickedBot.type === 'Learning' && !clickedBot.is_player_controlled) { handleJoinGame(clickedBot.id); } } } }
    canvasEl.addEventListener('mousedown', (e) => { isDragging = true; handleCanvasInteraction(e); }); canvasEl.addEventListener('mousemove', (e) => { if (isDragging) { handleCanvasInteraction(e); } }); canvasEl.addEventListener('mouseup', (e) => { handleCanvasInteraction(e); isDragging = false; }); canvasEl.addEventListener('mouseleave', () => { isDragging = false; }); canvasEl.addEventListener('touchstart', (e) => { isDragging = true; handleCanvasInteraction(e); }, { passive: false }); canvasEl.addEventListener('touchmove', (e) => { if (isDragging) { handleCanvasInteraction(e); } }, { passive: false }); canvasEl.addEventListener('touchend', (e) => { handleCanvasInteraction(e); isDragging = false; }, { passive: false }); canvasEl.addEventListener('touchcancel', () => { isDragging = false; });
    const addMobileButtonListener = (button, actionCode) => { if (button) { const sendAction = (e) => { if(!mobileControlsEl.classList.contains('enabled')) return; e.preventDefault(); if (clientState.playerBotId && clientState.isRunning) { player_direct_actions[clientState.playerBotId] = actionCode; } }; button.addEventListener('touchstart', sendAction, { passive: false }); button.addEventListener('click', sendAction); } };
    addMobileButtonListener(mobileUp, 0); addMobileButtonListener(mobileDown, 1); addMobileButtonListener(mobileLeft, 2); addMobileButtonListener(mobileRight, 3); addMobileButtonListener(mobilePunch, 4); addMobileButtonListener(mobileClaim, 5); addMobileButtonListener(mobileMentalAttack, 6);
    function updatePlayerInfo() { if (clientState.playerBotId) { playerInfoEl.textContent = `CONTROLLING BOT: ${clientState.playerBotId}`; } else { playerInfoEl.textContent = 'Player Bot ID: None'; } }
    function handleJoinGame(target_bot_id_param = null) { if (clientState.playerBotId) { alert('Already controlling a bot.'); return; } if (!clientState.environment || !clientState.bots) { alert('Simulation not ready.'); return; } let target_bot_id = target_bot_id_param; let available_bot_id = null; if (target_bot_id) { if (clientState.bots[target_bot_id] && clientState.bots[target_bot_id].type === 'Learning' && !clientState.bots[target_bot_id].is_player_controlled) { available_bot_id = target_bot_id; } else { alert(`Bot ${target_bot_id} is not available or not a learning bot.`); return; } } else { available_bot_id = Object.keys(clientState.bots).find(bid => clientState.bots[bid].type === 'Learning' && !clientState.bots[bid].is_player_controlled ); } if (available_bot_id) { const original_id = clientState.bots[available_bot_id].original_bot_id; clientState.bots[available_bot_id].is_player_controlled = true; clientState.bots[available_bot_id].target_coordinate = null; clientState.bots[available_bot_id].mode = "Player Control"; clientState.playerBotId = available_bot_id; clientState.playerOriginalBotId = original_id; localStorage.setItem(LOCAL_STORAGE_KEY_PLAYER, JSON.stringify({ originalBotId: original_id })); statusEl.textContent = `Status: Joined, controlling ${clientState.playerBotId}.`; clientState.playerTarget = null; updateTargetIndicator(); updatePlayerInfo(); } else { alert("No available Learning Bots to control."); } updateButtonStates(); updateMobileControls(); }
    function handleRejoinGame() { const savedPlayer = localStorage.getItem(LOCAL_STORAGE_KEY_PLAYER); if (savedPlayer) { try { const playerData = JSON.parse(savedPlayer); if (playerData && playerData.originalBotId) { const original_bot_id = playerData.originalBotId; if (clientState.bots[original_bot_id] && clientState.bots[original_bot_id].type === 'Learning' && !clientState.bots[original_bot_id].is_player_controlled) { clientState.bots[original_bot_id].is_player_controlled = true; clientState.bots[original_bot_id].target_coordinate = null; clientState.bots[original_bot_id].mode = "Player Control (Rejoin)"; clientState.playerBotId = original_bot_id; clientState.playerOriginalBotId = original_bot_id; statusEl.textContent = `Status: Rejoined, controlling ${clientState.playerBotId}.`; clientState.playerTarget = null; updateTargetIndicator(); updatePlayerInfo(); logMessage(`Player rejoined control of ${original_bot_id}`); } else { localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } } else { localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } } catch (e) { logMessage("Error parsing saved player data: " + e.message, "error"); localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } } updateButtonStates(); updateMobileControls(); }
    function handleLeaveGame() { if (clientState.playerBotId) { if (clientState.bots[clientState.playerBotId]) { clientState.bots[clientState.playerBotId].is_player_controlled = false; clientState.bots[clientState.playerBotId].target_coordinate = null; clientState.bots[clientState.playerBotId].mode = "AI Control"; } clientState.playerBotId = null; clientState.playerOriginalBotId = null; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); clientState.playerTarget = null; updateTargetIndicator(); updatePlayerInfo(); statusEl.textContent = `Status: Left bot control.`; } else { alert('Not controlling a bot.'); } updateButtonStates(); updateMobileControls(); }
    function startSimulation() { if (clientState.isRunning) { alert('Simulation already running.'); return; } if (clientState.needsFullReset || clientState.needsRoundReset || document.querySelector('.param-item.changed')) { alert("Apply changes or reset simulation before starting."); return; } clientState.isRunning = true; statusEl.textContent = "Status: Running..."; clearTimeout(simulation_loop_task); simulation_loop_task = setTimeout(simulation_loop, 0); updateButtonStates(); updateMobileControls(); }
    function stopSimulation() { clientState.isRunning = false; clearTimeout(simulation_loop_task); simulation_loop_task = null; statusEl.textContent = "Status: Stopped."; updateButtonStates(); updateMobileControls(); }
    function handleResetRound() { if (clientState.isRunning) { stopSimulation(); } const new_env = current_config.RANDOMIZE_ENV_PER_ROUND; if (setup_simulation(false, new_env)) { visualizer.update(clientState); updateInfoPanel(); statusEl.textContent = 'Status: New Round Ready.'; } else { statusEl.textContent = 'Status: Error resetting round.'; } clearResetHints(); updateButtonStates(); updateMobileControls(); }
    function handleResetFull() { if (clientState.isRunning) { stopSimulation(); } if (setup_simulation(true, true)) { visualizer.update(clientState); updateInfoPanel(); statusEl.textContent = 'Status: Full Reset Complete.'; } else { statusEl.textContent = 'Status: Error during full reset.'; } clearResetHints(); updateButtonStates(); updateMobileControls(); }
    function handleApplyParams() { if (clientState.isRunning) { alert('Stop simulation before changing parameters.'); return; } const new_ui_config = getUIConfig(); current_config = copyConfig(new_ui_config); markParamsApplied(); checkForNeededResets(); let msg = "Parameters Applied from UI."; if (clientState.needsFullReset) msg += " 'Reset All' required."; else if (clientState.needsRoundReset) msg += " 'New Round' or 'Reset All' required."; statusEl.textContent = `Status: ${msg}`; updateButtonStates(); updateMobileControls(); }
    function setupButtonListeners() { startButton.addEventListener('click', startSimulation); stopButton.addEventListener('click', stopSimulation); resetRoundButton.addEventListener('click', handleResetRound); resetFullButton.addEventListener('click', handleResetFull); applyParamsButton.addEventListener('click', handleApplyParams); saveParamsButton.addEventListener('click', saveParamsToLocalStorage); loadParamsButton.addEventListener('click', loadParamsFromLocalStorage); resetParamsButton.addEventListener('click', resetParamsToDefault); joinButton.addEventListener('click', () => handleJoinGame(null)); leaveButton.addEventListener('click', handleLeaveGame); }

    window.addEventListener('load', async () => {
        logMessage("Client Initializing (TFJS Hierarchical v6.3.0 Enhanced HNM)...");
        await setupTfBackend(); 
        
        const hlcTextarea = document.getElementById('param-HIERARCHY_LEVEL_CONFIGS');
        if (hlcTextarea) { 
             const initialProcessedHLC = _getProcessedHLC(DEFAULT_CONFIG.HIERARCHY_LEVEL_CONFIGS, DEFAULT_CONFIG);
             hlcTextarea.value = JSON.stringify(initialProcessedHLC, null, 2); 
             DEFAULT_CONFIG.HIERARCHY_LEVEL_CONFIGS = initialProcessedHLC; // Update default with processed one for consistency
        }

        updateUIFromConfig(DEFAULT_CONFIG); 
        current_config = copyConfig(DEFAULT_CONFIG); 
        uiDefaults = copyConfig(DEFAULT_CONFIG);

        visualizer = new Visualizer(ctxGrid, gridContainerEl);
        if (!setup_simulation(true, true)) { statusEl.textContent = "Status: Initialization Failed!"; return; }
        
        visualizer.update(clientState); 
        updateInfoPanel(); 
        updateButtonStates(); 
        updateMobileControls(); 
        updatePlayerInfo(); 
        handleRejoinGame(); 
        statusEl.textContent = "Status: Ready."; 
        setupButtonListeners();
        if (current_config.AUTOSTART_SIMULATION) { startSimulation(); }
    });
    let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if (visualizer && clientState.environment) { try { visualizer.updateGridDimensions(clientState.environment.size); visualizer.update(clientState); } catch(e){ logMessage("Resize error: " + e.message, "error"); } } }, 150); });
</script>
</body>
</html>

